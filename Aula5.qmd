# Leitura de dados

Tendo visto os fundamentos básicos da programação em *R*, o próximo passo é aprender a efetuar a leitura de informações para o uso posterior na linguagem. Os dados são a estrutura básica das mais variadas ferramentas interativas geradas pela programação e também consistem na ferramenta fundamental para as constatações científicas empíricas, seja na economia, seja em qualquer outra ciência.

Os dados são armazenados em diversos tipos de arquivo, cada um deles com as suas respectivas propriedades e usuabilidade. Cada tipo de arquivo possui características que precisam ser levadas em consideração, seja na hora de elaborar uma base de dados do zero, seja na hora de ler uma base de dados pronta. Cabe ao usuário conhecer cada uma dessas propriedades e estar pronto para lidar com as particularidades dos mais variados tipos de arquivos.

Nesse capítulo, iremos conhecer as propriedades dos principais tipos de arquivos comumente utilizados para armazenar informações. Também aprenderemos sobre os principais tipos de dados e os seus possíveis usos. Por fim, serão expostas as principais técnicas que possibilitam a importação e a leitura de bases de dados previamente prontas para a linguagem *R*. O objetivo principal desse capítulo é repassar ao estudante o conhecimento necessário para que ele possa dominar a leitura de bases de dados em *R* por meio do domínio de técnicas de importação dos mais variados tipos de arquivo.

## O problema da memória

Um dos principais desafios enfrentados na construção de bases de dados é o tamanho dos arquivos. Processar grandes bases de dados exige um grande poder computacional uma vez que, quanto maior o volume de informações, maior é a requisição de memória computacional para realizar o processamento.

Uma base de dados geralmente é composta por objetos que são formados por linhas e colunas. Cada linha e cada coluna adicionada em um objeto aumenta o seu tamanho e por consequência aumenta também a quantidade de memória computacional necessária para processar essas informações. Em vista desse problema, a engenharia de dados está em uma busca constante por soluções que permitam reduzir o tamanho dos arquivos ou a quantidade de memória necessária para processá-lo. Uma das soluções mais fáceis e rápidas para tal é escolher um tipo de arquivo adequado para armazenar as informações. Por exemplo, bases de dados com poucas linhas e poucas colunas podem facilmente ser armazenadas em um arquivo excel, pois apesar de ser uma extensão que exige mais memória, o baixo volume de informações não impedirá um usuário use essa base de dados mesmo com uma máquina com baixo poder computacional. Em contrapartida, uma máquina comum com baixa capacidade de processamento terá dificuldades para gerenciar uma base de dados com inúmeras linhas e colunas armazenadas em um arquivo desse tipo.

Em vista desses conceitos, esse material lista a seguir as principais extensões de arquivos utilizados para armazenar informações nas bases de dados, esclarecendo as suas principais propriedades e usuabilidades, além de demosntrar as técnicas necessárias para abrir esses arquivos na linguagem *R*.

## Arquivos nativos da linguagem *R*

A linguagem *R* possui duas extensões de arquivos nativas, a extensão *.Rdata* e a extensão *.Rds*. Quando o usuário possui múltiplos objetos no seu ambiente de trabalho e deseja salvar todos esses objetos em um único arquivo, então o ideal é usar a extensão *.Rdata*. Esse procedimento também é conhecido como "salvar objetos como imagem". Nesse caso, o usuário pode salvar o seu ambiente de trabalho completo ou parte dele em um único arquivo que poderá ser usado posteriormente. Para demonstrar, vamos importar três bases de dados nativas para o ambiente de trabalho:

```{r}
base1 = mtcars
base2 = CO2
base3 = ChickWeight
```

Imagine que seja necessário salvar todo o ambiente de trabalho com as três bases de dados incluídas nele em um único arquivo. Nesse caso, salvar como uma imagem *.Rdata* pode ser a melhor alternativa. Para tanto, o primeiro passo é informar à linguagem em qual pasta da sua máquina os arquivos devem ser salvos. Isso é feito indicando um diretório de trabalho por meio do comando *setwd()*, indicando dentro do parênteses a pasta de interesse entre aspas. **Nota: no sistema Windows as barras à esquerda devem sempre ser substituídas por barras duplas na fixação do diretório de trabalho**.

```{r, eval=FALSE}
setwd("Endereço da pasta em que os arquivos serão salvos")
```

Após fixar o diretório de trabalho, o próximo passo é salvar o diretório de trabalho como imagem *.Rdata*. Para tanto, deve-se usar o comando *save.image()* e indicar o nome pelo qual o arquivo será salvo sucedido do indicativo do formato *.Rdata*. Por exemplo, imagine que queiramos salvar todo o ambiente de trabalho com o nome *bases_de_dados*. Nesse caso, deve-se proceder da seguinte maneira:

```{r, eval=FALSE}
save.image("bases_de_dados.Rdata")
```

Uma vez que o arquivo está salvo no seu diretório de trabalho com a extensão *.Rdata*, para importá-lo para a linguagem *R* basta usar o comando *load()* indicando no parênteses e entre aspas o nome do arquivo que será importado.

```{r, eval=FALSE}
load("bases_de_dados.Rdata")
```

Já a extensão *.rds* é aplicada quando o usuário quer salvar um único arquivo do ambiente de trabalho no diretório da sua máquina. Diferente da extensão *.Rdata*, na extensão *.rds* o salvamento dos arquivos ocorre com o comando *saveRDS()*, onde dentro do parênteses deve ser indicado o nome do objeto que está no ambiente de trabalho e que será salvo, sucedido do nome pelo qual o usuário deseja salvar o arquivo. Por exemplo, imagine que queiramos salvar o objeto de nome *base1* com o nome *base1.rds*. Nesse caso, devemos proceder conforme indicado a seguir:

```{r, eval=FALSE}
saveRDS(base1, file = "base1.rds")
```

Uma vez que o objeto está salvo com a extensão *.rds* na sua máquina, para importá-lo para a linguagem *R* basta usar o comando *readRDS()*, indicando no parênteses e entre aspas o nome do arquivo de interesse. Por exemplo, para ler o arquivo salvo com o nome *base1.rds* deve-se proceder conforme indicado a seguir:

```{r, eval=FALSE}
readRDS("base1.rds")
```

## Arquivos em formato *.csv*

Os arquivos *.csv* geralmente são utilizados para guardar informações textuais, ou seja, são ideais para armazenar textos. Assim, um arquivo nessa extensão sempre terá uma única coluna, podendo conter, entretanto, múltiplas linhas. No entanto, esse tipo de arquivo pode ser utilizado para armazenar informações em múltiplas colunas desde que essas colunas estejam dispersas em uma única coluna comum sendo separadas por um separador. Por exemplo, considere a tabela a seguir:

| Nome  | Idade | Sexo |
|-------|-------|------|
| João  | 28    | M    |
| Maria | 26    | F    |
| Ana   | 21    | F    |

Em uma estrutura de texto, todas essas informações estariam unidas na mesma coluna, isto é:

| NomeIdadeSexo |
|---------------|
| João28M       |
| Maria26F      |
| Ana21F        |

Em uma estrutura do tipo *.csv* todas as informações também estarão na mesma coluna, porém, o final de cada coluna pode ser identificado por um separador de colunas. Para exemplificar, suponha que no caso do exemplo anterior esse separador seja a vírgula. Nesse caso, a tabela anterior passa a ser escrita como:

| Nome,Idade,Sexo |
|-----------------|
| João,28,M       |
| Maria,26,F      |
| Ana,21,F        |

Como esse separador de colunas éconhecido, então fica fácil reconhecer as informações armazenadas nesse arquivo de texto.

Em *R*, a leitura de arquivos no formato *.csv* pode ser feita de diferentes maneiras. Uma das formas mais comuns de executar essa tarefa é por meio do uso da função *read.csv* que é uma função nativa e não necessita de instalação. O uso da função deve obedecer a seguinte forma funcional:

```{r, eval=FALSE}
read.csv(
  "Endereço/nome do arquivo.csv",
  header = TRUE, # TRUE se a primeira linha indica o nome das colunas e FALSE caso contrário
  sep = "," # aqui o separador de colunas deve ser indicado entre aspas
)
```

### Exemplo: Importando dados via link url

Para exemplificar, considere a planilha de registros fictícios de clientes disponível no endereço <https://drive.google.com/uc?id=1zO8ekHWx9U7mrbx_0Hoxxu6od7uxJqWw&export=download>. A planilha possui 100 linhas, cada uma delas correspondendo às informações de um cliente específico. Caso o usuário baixe esse arquivo em sua máquina e abra esse arquivo em um editor de texto, notará que as colunas estão delimitadas por uma vírgula. Vamos importar esse arquivo no formato de um data frame nomeando-o de *"clientes"*.

```{r, eval=FALSE}
clientes = read.csv(
  file = "https://drive.google.com/uc?id=1zO8ekHWx9U7mrbx_0Hoxxu6od7uxJqWw&export=download",
  header = TRUE, # indicando que a primeira linha contém o nome das colunas
  sep = ",", # indicando que as colunas estão separadas por vírgula
  dec = "." #indicando que o separador decimal é o ponto
)

head(clientes) # mostra as primeiras linhas da planilha
```

Caso esse arquivo esteja em uma pasta do seu computador em vez de um link url, etão no parâmetro *file* você deverá proceder como *file = Endereço da pasta que contém o arquivo/nome do arquivo.csv"*.

Agora considere essa mesma planilha disponível no endereço [https://drive.google.com/uc?id=1vPCLNpy6LEhHDvQlHtFBu5L2QzB5bTnv&export=download](https://drive.google.com/uc?id=1vPCLNpy6LEhHDvQlHtFBu5L2QzB5bTnv&export=downloa). Note que se replicarmos o script anterior alterando o endereço para esse link um erro será reportado. Isso ocorre porque nesse caso há um cabeçalho na planilha, isto é, existem linhas na parte superior da planilha que não possuem as mesmas especificações textuais do restante do csv e devem ser desconsideradas no ato da importação. Em outras palavras, as linhas do cabeçalho precisam ser *"puladas"*. Isso é feito por meio do parâmetro *skip* dentro da função *read.csv*. Esse parâmetro recebe a quantidade de linhas que precisam ser puladas. Como o cabeçalho desse exemplo possui duas linhas, então deve-se adicionar *skip = 2* no comando, ou seja:

```{r, eval=FALSE}
clientes = read.csv(
  file = "https://drive.google.com/uc?id=1vPCLNpy6LEhHDvQlHtFBu5L2QzB5bTnv&export=download",
  header = TRUE, # indicando que a primeira linha contém o nome das colunas
  sep = ",", # indicando que as colunas estão separadas por vírgula
  dec = ".", #indicando que o separador decimal é o ponto
  skip = 2 # Pula as duas primeiras linhas da planilha
)

head(clientes) # mostra as primeiras linhas da planilha
```

O usuário pode testar que quando *skip \< 2*, o erro será reportado mesmo assim, ao passo que quando *skip \> 2*, a importação funciona, porém, ajustes precisam ser feitos para que o nome das colunas apareça de maneira correta no data frame.

É importante ressaltar que a função *read.csv* possui vários outros parâmetros além desses aqui especificados. O usuário pode checar as demais possibilidades de uso de parâmetros da função executando o comando *?read.csv*.
