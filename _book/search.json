[
  {
    "objectID": "aula2.html",
    "href": "aula2.html",
    "title": "2  Indexação e operações indexadas",
    "section": "",
    "text": "2.1 Indexação de objetos\nNesse módulo estão expressos os detalhes básicos acerca de operações fundamentais com diferentes tipos de objetos. O módulo ainda apresenta os conceitos e as normas básicas sobre posições de elementos em um objeto (indexação) e também mostra as operações que usam essa indexação e que podem ser úteis na análise de dados.\nOs objetos são compostos por elementos e esses elementos ocupam uma posição dentro do objeto. Por exemplo, imagine um vetor \\(x = [Maria, Paulo, Pedro, Ana]\\). Esse vetor é composto por quatro elementos, maria na posição 1, Paulo na posição 2, Pedro na posição 3 e Ana na posição 4. Agora considere que essas mesmas informações estejam dispostas em uma matriz.\n\\[\\left[\\begin{array}{cc}\nMaria & Paulo\\\\ Pedro & Ana \\end{array}\n\\right]\n\\]\nAgora a posição deve ser visualizada como “linha por coluna”. Maria está na linha 1 e coluna 1 (posição [1, 1]), Paulo está na linha 1 e coluna 2 (posição [1, 2]), Pedro está na linha 2 e coluna 1 (posição [2, 1]) e Ana está na linha 2 e coluna 2 (posição [2, 2]). A essa posição dá-se o nome de indexação. A indexação nada mais é do que a posição de um elemento em um conjunto, que nesse caso são os objetos no ambiente de trabalho.\nPara verificar qual elemento está em uma determinada posição do objeto, deve-se informar o nome do objeto precedido da posição entre colchetes, isto é, nome do objeto[posição na linha, posição na coluna]. Por exemplo, na matriz anterior, caso queiramos consultar quem está na linha 1 da coluna 1, devemos proceder conforme a seguir:\nnomes = matrix(c(\"Maria\", \"Paulo\", \"Pedro\", \"Ana\"), byrow = TRUE, nrow = 2, ncol = 2)\nnomes[1,1]\n\n[1] \"Maria\"\nA lógica é a mesma em um data frame,\ndf = data.frame(\n  coluna1 = c(\"Maria\", \"Pedro\"),\n  coluna2 = c(\"Paulo\", \"Ana\")\n)\ndf[1,1]\n\n[1] \"Maria\"\nSe quisermos nos referir apenas às linhas, então a posição da coluna deve ficar vazia, isto é, nome do objeto[posição na linha,]. Seguindo o exemplo anterior, caso queiramos checar quem está na linha 1 da matriz, devemos proceder conforme a seguir:\nnomes[1,]\n\n[1] \"Maria\" \"Paulo\"\nA mesma lógica se aplica aos data frames.\ndf[1,]\n\n  coluna1 coluna2\n1   Maria   Paulo\nSe quisermos nos referir apenas às colunas, então a posição da linha deve ficar vazia, isto é, nome do objeto[, posição na coluna]. Seguindo o exemplo anterior, caso queiramos checar quem está na coluna 1 da matriz, devemos proceder conforme a seguir:\nnomes[,1]\n\n[1] \"Maria\" \"Pedro\"\nA mesma lógica se aplica aos data frames.\ndf[,1]\n\n[1] \"Maria\" \"Pedro\"\nA posição das linhas e colunas também pode ser referenciada de acordo com os nomes. Nesse caso, o procedimento é nome do objeto[“nome da linha”, “nome da coluna”]. Para exemplificar, vamos dar nomes às linhas e as colunas da matriz e do data frame usados nos exemplos anteriores.\nrownames(nomes) = c(\"linha 1\", \"linha 2\")\ncolnames(nomes) = c(\"coluna 1\", \"coluna 2\")\nprint(nomes)\n\n        coluna 1 coluna 2\nlinha 1 \"Maria\"  \"Paulo\" \nlinha 2 \"Pedro\"  \"Ana\"\nrownames(df) = c(\"linha 1\", \"linha 2\")\nprint(nomes)\n\n        coluna 1 coluna 2\nlinha 1 \"Maria\"  \"Paulo\" \nlinha 2 \"Pedro\"  \"Ana\"\nPara checar quem está na linha 1, proceda conforme a seguir:\nnomes[\"linha 1\",]\n\ncoluna 1 coluna 2 \n \"Maria\"  \"Paulo\"\nE no data frame:\ndf[\"linha 1\", ]\n\n        coluna1 coluna2\nlinha 1   Maria   Paulo\nPara checar quem está na coluna 1, proceda conforme a seguir:\nnomes[, \"coluna 1\"]\n\nlinha 1 linha 2 \n\"Maria\" \"Pedro\"\nE no data frame:\ndf[, \"coluna1\"]\n\n[1] \"Maria\" \"Pedro\"\nNos data frames, a indexação das colunas pode ser mais simplificada devido a possibilidade de referenciar as colunas plo nome usando o cifrão “$”. Nesse caso, o procedimento a se fazer é nome do objeto$nome da coluna. Por exemplo, para se referir a coluna 1 do data frame anterior, deve-se proceder conforme a seguir:\ndf$coluna1\n\n[1] \"Maria\" \"Pedro\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#adicionando-linhas-a-um-data-frame",
    "href": "aula2.html#adicionando-linhas-a-um-data-frame",
    "title": "2  Indexação e operações indexadas",
    "section": "2.2 Adicionando linhas a um data frame",
    "text": "2.2 Adicionando linhas a um data frame\nTendo comopreendido como funciona a indexação, o próximo passo é aprender como essa indexação pode ser usada para adicionar, excluir ou alterar elementos de um objeto. Caso a intenção seja adicionar uma linha em um data frame, então o procedimento a se fazer é nome do objeto[número de linhas do objeto + 1,]. Para exemplificar, vamos incluir uma linha na data frame de nomes contendo os valores [João, Clara]. Esse procedimento deve ser feito conforme especificado a seguir:\n\ndf[3,] = c(\"João\", \"Clara\")\nprint(df)\n\n        coluna1 coluna2\nlinha 1   Maria   Paulo\nlinha 2   Pedro     Ana\n3          João   Clara",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#adicionando-linhas-em-uma-matriz",
    "href": "aula2.html#adicionando-linhas-em-uma-matriz",
    "title": "2  Indexação e operações indexadas",
    "section": "2.3 Adicionando linhas em uma matriz",
    "text": "2.3 Adicionando linhas em uma matriz\nPara adicionar linhas em uma matriz é preciso usar a função rbind(). Essa função também funciona perfeitamente para data frames. Nesse caso, o procedimento a se fazer é rbind(nome do objeto, vetor com os valores da linha adicionada). Por exemplo, para adicionar uma linha com os valores [João, Clara] no data frame de nomes, deve-se proceder conforme a seguir:\n\nnomes = rbind(nomes, c(\"João\", \"Clara\"))\nprint(nomes)\n\n        coluna 1 coluna 2\nlinha 1 \"Maria\"  \"Paulo\" \nlinha 2 \"Pedro\"  \"Ana\"   \n        \"João\"   \"Clara\" \n\n\nA mesma lógica se aplica aos data frames:\n\nrbind(df, c(\"João\", \"Clara\"))\n\n        coluna1 coluna2\nlinha 1   Maria   Paulo\nlinha 2   Pedro     Ana\n3          João   Clara\n4          João   Clara",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#removendo-linhas-de-um-objeto",
    "href": "aula2.html#removendo-linhas-de-um-objeto",
    "title": "2  Indexação e operações indexadas",
    "section": "2.4 Removendo linhas de um objeto",
    "text": "2.4 Removendo linhas de um objeto\nA remoção de linhas de um objeto é feita adicionando um sinal de menos antes do número da linha indicado em colchetes. Por exemplo, caso queiramos remover a linha 3 da matriz de nomes, devemos proceder conforme a seguir:\n\nnomes[-3,]\n\n        coluna 1 coluna 2\nlinha 1 \"Maria\"  \"Paulo\" \nlinha 2 \"Pedro\"  \"Ana\"   \n\n\nA mesma lógica se aplica aos data frames:\n\ndf[-3,]\n\n        coluna1 coluna2\nlinha 1   Maria   Paulo\nlinha 2   Pedro     Ana\n\n\nCaso a intenção seja remover múltiplas linhas, então o número das linhas que serão removidas deve ser indicado em um vetor precedido do sinal de menos dentro do colchetes. Por exemplo, caso queiramos remover as linhas 2 e 3 da matriz de nomes, devemos proceder conforme a seguir:\n\nnomes[-c(2,3),]\n\ncoluna 1 coluna 2 \n \"Maria\"  \"Paulo\" \n\n\nA mesma lógica se aplica aos data frames:\n\ndf[-c(2,3),]\n\n        coluna1 coluna2\nlinha 1   Maria   Paulo",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#adicionando-colunas-em-um-data-frame",
    "href": "aula2.html#adicionando-colunas-em-um-data-frame",
    "title": "2  Indexação e operações indexadas",
    "section": "2.5 Adicionando colunas em um data frame",
    "text": "2.5 Adicionando colunas em um data frame\nExistem várias maneiras de adicionar colunas em um data frame. O usuário pode indicar a posição da coluna entre colchetes e em seguida indicar os valores, pode indicar o nome da coluna em colchetes e em seguida indicar os valores, pode usar o sifrão para indicar o nome da coluna criada, …\nPara exemplificar, suponha que queiramos adicionar uma coluna com os valores *[pessoa 1, pessoa 2, pessoa 3] no dtaframe df. Essa tarefa pode ser feita das seguintes maneiras:\n\nIndicando a posição em colchetes\n\n\ndf[,3] = c(\"pessoa 1\", \"pessoa 2\", \"pessoa 3\")\nprint(df)\n\n        coluna1 coluna2       V3\nlinha 1   Maria   Paulo pessoa 1\nlinha 2   Pedro     Ana pessoa 2\n3          João   Clara pessoa 3\n\n\n\nIndicando o nome da coluna no colchetes.\n\n\ndf[, \"coluna3\"] = c(\"pessoa 1\", \"pessoa 2\", \"pessoa 3\")\nprint(df)\n\n        coluna1 coluna2  coluna3\nlinha 1   Maria   Paulo pessoa 1\nlinha 2   Pedro     Ana pessoa 2\n3          João   Clara pessoa 3\n\n\n\ndf=df[,-3]\n\n\nUsando o cifrão.\n\n\ndf$coluna3 = c(\"pessoa 1\", \"pessoa 2\", \"pessoa 3\")\nprint(df)\n\n        coluna1 coluna2  coluna3\nlinha 1   Maria   Paulo pessoa 1\nlinha 2   Pedro     Ana pessoa 2\n3          João   Clara pessoa 3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#adicionando-colunas-em-uma-matriz",
    "href": "aula2.html#adicionando-colunas-em-uma-matriz",
    "title": "2  Indexação e operações indexadas",
    "section": "2.6 Adicionando colunas em uma matriz",
    "text": "2.6 Adicionando colunas em uma matriz\nPara adicionar colunas em uma matriz é preciso usar a função cbind(). Essa função tem a mesma lógica de uso da função rbind() apresentada anteriormente, com a diferença de que a função cbind() posiciona os novos elementos em uma coluna em vez de uma linha. Para exemplificar, vamos adicionar a mesma coluna incluída no data frame df na matriz de nomes.\n\nnomes = cbind(nomes, c(\"pessoa 1\", \"pessoa 2\", \"pessoa 3\"))\nprint(nomes)\n\n        coluna 1 coluna 2           \nlinha 1 \"Maria\"  \"Paulo\"  \"pessoa 1\"\nlinha 2 \"Pedro\"  \"Ana\"    \"pessoa 2\"\n        \"João\"   \"Clara\"  \"pessoa 3\"\n\n\nA mesma lógica pode ser aplicada aos data frames fazendo df = cbind(df, c(“pessoa 1”, “pessoa 2”, “pessoa 3”)).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#renomeando-colunas-e-linhas-específicas",
    "href": "aula2.html#renomeando-colunas-e-linhas-específicas",
    "title": "2  Indexação e operações indexadas",
    "section": "2.7 Renomeando colunas e linhas específicas",
    "text": "2.7 Renomeando colunas e linhas específicas\nComo visto no capítulo anterior, a função colnames() pode ser usada para renomear colunas de uma matriz ou data frame. Porém, caso o objetivo seja renomear uma única coluna específica é possível usar a indexação para realizar essa tarefa. Por exemplo, considere renomear apenas a coluna 3 do data frame de nomes atribuindo a essa coluna o nome “coluna3”.\n\ncolnames(nomes)[3] = \"Coluna3\"\nprint(nomes)\n\n        coluna 1 coluna 2 Coluna3   \nlinha 1 \"Maria\"  \"Paulo\"  \"pessoa 1\"\nlinha 2 \"Pedro\"  \"Ana\"    \"pessoa 2\"\n        \"João\"   \"Clara\"  \"pessoa 3\"\n\n\nO mesmo pode ser feito para as linhas. Por exemplo, caso queiramos renomear apenas a linha 3 do data frame de nomes, podemos proceder conforme a seguir:\n\nrownames(nomes)[3] = \"linha 3\"\nprint(nomes)\n\n        coluna 1 coluna 2 Coluna3   \nlinha 1 \"Maria\"  \"Paulo\"  \"pessoa 1\"\nlinha 2 \"Pedro\"  \"Ana\"    \"pessoa 2\"\nlinha 3 \"João\"   \"Clara\"  \"pessoa 3\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#operações-com-colunas",
    "href": "aula2.html#operações-com-colunas",
    "title": "2  Indexação e operações indexadas",
    "section": "2.8 Operações com colunas",
    "text": "2.8 Operações com colunas\nEm um data frame novas colunas podem ser geradas por meio de operações com colunas existentes. Para exemplificar, considere um dataframe com informações sobre medidas de alunos de uma academia.\n\nalunos = data.frame(\nnome = c(\"Aluno 1\", \"Aluno 2\", \"Aluno 3\"),\npeso = c(65, 70, 90),\naltura = c(1.60, 1.70, 1.78)\n)\nprint(alunos)\n\n     nome peso altura\n1 Aluno 1   65   1.60\n2 Aluno 2   70   1.70\n3 Aluno 3   90   1.78\n\n\nImagine que seja necessário adicionar nesse data frame uma nova coluna com o índice de massa corporal dos alunos (IMC). Sabe-se que:\n\\[\nIMC = \\frac{Peso}{Altura^2}\n\\]\nA nova coluna pode ser adicionada indexando a sua posição:\n\nalunos[,4] = alunos[,2]/(alunos[,3]^2)\nprint(alunos)\n\n     nome peso altura       V4\n1 Aluno 1   65   1.60 25.39062\n2 Aluno 2   70   1.70 24.22145\n3 Aluno 3   90   1.78 28.40550\n\n\nIndexando o nome da coluna:\n\nalunos[\"imc\"] = alunos[\"peso\"]/(alunos[\"altura\"]^2)\nprint(alunos)\n\n     nome peso altura      imc\n1 Aluno 1   65   1.60 25.39062\n2 Aluno 2   70   1.70 24.22145\n3 Aluno 3   90   1.78 28.40550\n\n\nOu utilizando o cifrão:\n\nalunos$imc = alunos$peso/(alunos$altura^2)\nprint(alunos)\n\n     nome peso altura      imc\n1 Aluno 1   65   1.60 25.39062\n2 Aluno 2   70   1.70 24.22145\n3 Aluno 3   90   1.78 28.40550\n\n\n\n2.8.1 Criando uma nova coluna como recorte de uma coluna existente\nImagine o caso em que seja preciso criar uma coluna como um recorte de valores de uma coluna existente em um data frame. Falando com outras palavras, imagine que seja preciso adicionar uma coluna contendo uma parte dos valores contidos em outra coluna. Por exemplo, no data frame de alunos da academia, imagine que seja preciso mostrar apenas o número do aluno em uma nova coluna, isto é, em vez de mostrar o termo “Aluno 1” suponha que seja preciso mostrar apenas o número “1”.\nEsse procedimento pode ser feito usando a função substr. Essa função é nativa da linguagem R e serve para desmembrar valores de acordo com a posição dos caracteres desses valores. Exemplificando, o termo “Aluno 1” tem sete caracteres que correspondem a seis letras, um espaço e um número. O número ocupa a sétima posição no termo. Na função substr temos que indicar a posição inicial e a posição final do conjunto de caracteres que queremos desmembrar do valor objetivo. A maneira correta de usar essa função é fazendo substr(nome do elemento, posição inicial, posição final). Por exemplo, se fizermos substr(“Aluno 1”, 1, 2) o resultado será “Al” que corresponde aos dois primeiros caracteres do termo utilizado.\nNo nosso exemplo como o número do aluno inicia e termina na sétima posição, então o correto a se fazer é:\n\nalunos$num_aluno = substr(alunos$nome, 7, 7)\nprint(alunos)\n\n     nome peso altura      imc num_aluno\n1 Aluno 1   65   1.60 25.39062         1\n2 Aluno 2   70   1.70 24.22145         2\n3 Aluno 3   90   1.78 28.40550         3\n\n\n\n\n2.8.2 Mesclando colunas\nEm vez de separar valores de uma coluna, imagine o caso em que seja preciso juntar valores. Em R isso pode ser facilmente feito usando a função paste(). Essa função junta múltiplos valores separando-os com um searador indicado pelo usuário. Para usar a função, basta indicar entre parênteses os valores que serão unificados e indicar o separador com o parâmetro “sep”. Por exemplo:\n\nnome = \"João\"\nsobrenome = \"Silva\"\nnome_completo = paste(nome, sobrenome, sep = \" \")\nprint(nome_completo)\n\n[1] \"João Silva\"\n\n\nEssa função pode ser usada para unir colunas. Para exemploficar, considere o novo data frame com as características dos alunos de uma academia indicado a seguir:\n\nalunos2 = alunos\nalunos2$nome = c(\"João\", \"Maria\", \"João\")\n\nE imagine que seja preciso criar um código do aluno, unindo o nome e o número do aluno separando o nome e um número por um traço. Esse procedimento pode ser feito conforme indicado a seguir:\n\nalunos2$cod_aluno = paste(alunos2$nome, alunos2$num_aluno, sep = \"-\")\nprint(alunos2)\n\n   nome peso altura      imc num_aluno cod_aluno\n1  João   65   1.60 25.39062         1    João-1\n2 Maria   70   1.70 24.22145         2   Maria-2\n3  João   90   1.78 28.40550         3    João-3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#reposicionando-linhas-e-colunas",
    "href": "aula2.html#reposicionando-linhas-e-colunas",
    "title": "2  Indexação e operações indexadas",
    "section": "2.9 Reposicionando linhas e colunas",
    "text": "2.9 Reposicionando linhas e colunas\nConhecendo a posição de cada linha e cada coluna, é possível reordená-las de acordo com as necessidades ou preferências do usuário usando operações indexadas. Por exemplo, suponha que seja preciso reordenar as linhas do data frame de alunos para posicionar o aluno 3 na primeira linha, o aluno 2 na segunda linha e o aluno 1 na terceira linha. Esse procedimento pode ser feito conforme a seguir:\n\nalunos = alunos[c(3,2,1),]\nprint(alunos)\n\n     nome peso altura      imc num_aluno\n3 Aluno 3   90   1.78 28.40550         3\n2 Aluno 2   70   1.70 24.22145         2\n1 Aluno 1   65   1.60 25.39062         1\n\n\nAgora suponha que seja necessário posicionar o nome do aluno na primeira coluna, a altura na segunda coluna, o peso na terceira coluna e o imc na última coluna, isto é, suponha que seja preciso inverter a posição do peso e da altura no data frame. Esse procedimento pode ser feito conforme indicado a seguir:\n\nalunos = alunos[, c(1,3,2,4)]\nprint(alunos)\n\n     nome altura peso      imc\n3 Aluno 3   1.78   90 28.40550\n2 Aluno 2   1.70   70 24.22145\n1 Aluno 1   1.60   65 25.39062",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#operações-básicas",
    "href": "aula2.html#operações-básicas",
    "title": "2  Indexação e operações indexadas",
    "section": "2.10 Operações básicas",
    "text": "2.10 Operações básicas\nNovas linhas e colunas podem ser adicionadas em um data frame usando operações básicas como soma, produto, ou estatísticas básicas. Para demonstrar, considere um data frame contendo a idade de cinco pessoas conforme a seguir:\n\ndf = data.frame(\n  pessoa = c(\"pessoa1\", \"pessoa2\", \"pessoa3\", \"pessoa4\", \"pessoa\"),\n  idade = c(25, 50, 68,45,NA)\n)\nprint(df)\n\n   pessoa idade\n1 pessoa1    25\n2 pessoa2    50\n3 pessoa3    68\n4 pessoa4    45\n5  pessoa    NA\n\n\nNote que há um valor faltante, indicado pelo termo NA que representa a sigla do “não disponível” (do inglês not available). Qualquer operação contendo essa coluna deve indicar que esse valor ausente deve ser ignorado. Isso pode ser feito adicionando a opção na.rm = TRUE.\n\n2.10.1 Soma total\nSuponha que queiramos encontrar o somatório da idade de todas as pessoas contidas no data frame. Isso pode ser facilmente executado usando a função sum(), conforme indicado a seguir:\n\nsum(df$idade, na.rm = TRUE)\n\n[1] 188\n\n\n\n\n2.10.2 Produto total\nCaso o objetivo seja encontrar o produto de todos os valores de uma dada coluna, então o ideal é usar a função prod(), conforme demonstrado a seguir:\n\nprod(df$idade, na.rm = TRUE)\n\n[1] 3825000\n\n\n\n\n2.10.3 Média\nJá a média pode ser obtida com a função mean(), conforme demonstrado a seguir:\n\nmean(df$idade, na.rm = TRUE)\n\n[1] 47\n\n\n\n\n2.10.4 Mínimo\nO valor mínimo de um dado objeto pode ser computado por meio da função min(), conforme demonstrado a seguir:\n\nmin(df$idade, na.rm = TRUE)\n\n[1] 25\n\n\n\n\n2.10.5 Máximo\nO valor máximo de um dado objeto pode ser computado por meio da função max(), conforme demonstrado a seguir:\n\nmax(df$idade, na.rm = TRUE)\n\n[1] 68\n\n\n\n\n2.10.6 Desvio padrão\nO desvio padrão de um dado objeto pode ser computado por meio da função sd(), conforme demonstrado a seguir:\n\nsd(df$idade, na.rm = TRUE)\n\n[1] 17.68238\n\n\n\n\n2.10.7 Número de observações\nO número de observações - ou comprimento - de um dado objeto pode ser verificado com o uso da função length(), conforme demonstrado a seguir:\n\nlength(df$idade)\n\n[1] 5\n\n\nNote que nesse caso é preciso despresar a omissão dos valores NA.\n\n\n2.10.8 Exemplo: Criando uma tabela de estatísticas descritivas\nUma tabela de estatísticas descritivas mostra o perfil básico de um banco de dados e geralmente expressa o número de observações, o valor médio, o desvio padrão, o valor máximo e o valor mínimo de cada variável. Para representar, considere usar o banco de dados nativo do R sobre características das flores (iris). Esse banco de dados possui cinco colunas (Sepal.Length, Sepal.Width, Petal.Length, Petal.Width, Species) que mostram o comprimento e a largura da pétala e da sépala de cada espécie de flor. Elaborar uma tabela de estatísticas descritivas dessa base de dados seria o mesmo que preencher a seguinte tabela:\n\n\n\n\n\n\n\n\n\n\n\n\nObservações\nMédia\nDesvio Padrão\nMínimo\nMáximo\n\n\n\n\nSepal.Length\n\n\n\n\n\n\n\nSepal.Width\n\n\n\n\n\n\n\nPetal.Length\n\n\n\n\n\n\n\nPetal.Width\n\n\n\n\n\n\n\n\nPara esse propósito, vamos usar a indexação aos nomes das linhas e colunas e vamos usar as estatísticas básicas mostradas anteriormente. O primeiro passo para tal é criar um data frame vazio com os mesmos padrões da tabela anterior:\n\nest_desc = data.frame(\n  Observacoes = c(rep(NA, 4)),\n  Media = c(rep(NA, 4)),\n  Desvio_Padrao = c(rep(NA, 4)),\n  Minimo = c(rep(NA, 4)),\n  Maximo  = c(rep(NA, 4))\n)\nrownames(est_desc) = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", 'Petal.Width')\nprint(est_desc)\n\n             Observacoes Media Desvio_Padrao Minimo Maximo\nSepal.Length          NA    NA            NA     NA     NA\nSepal.Width           NA    NA            NA     NA     NA\nPetal.Length          NA    NA            NA     NA     NA\nPetal.Width           NA    NA            NA     NA     NA\n\n\nO próximo passo é preencher cada célula do data frame com as estatísticas correspondentes. Inicialmente, vamos preencher a coluna referente ao número de observações:\n\nest_desc[\"Sepal.Length\", \"Observacoes\"] = length(iris$Sepal.Length)\nest_desc[\"Sepal.Width\", \"Observacoes\"] = length(iris$Sepal.Width)\nest_desc[\"Petal.Length\", \"Observacoes\"] = length(iris$Petal.Length)\nest_desc[\"Petal.Width\", \"Observacoes\"] = length(iris$Petal.Width)\n\nAgora vamos preencher a coluna da média:\n\nest_desc[\"Sepal.Length\", \"Media\"] = mean(iris$Sepal.Length)\nest_desc[\"Sepal.Width\", \"Media\"] = mean(iris$Sepal.Width)\nest_desc[\"Petal.Length\", \"Media\"] = mean(iris$Petal.Length)\nest_desc[\"Petal.Width\", \"Media\"] = mean(iris$Petal.Width)\n\nAgora vamos preencher a coluna do desvio padrão:\n\nest_desc[\"Sepal.Length\", \"Desvio_Padrao\"] = sd(iris$Sepal.Length)\nest_desc[\"Sepal.Width\", \"Desvio_Padrao\"] = sd(iris$Sepal.Width)\nest_desc[\"Petal.Length\", \"Desvio_Padrao\"] = sd(iris$Petal.Length)\nest_desc[\"Petal.Width\", \"Desvio_Padrao\"] = sd(iris$Petal.Width)\n\nAgora vamos fazer o mesmo para a coluna do valor mínimo:\n\nest_desc[\"Sepal.Length\", \"Minimo\"] = min(iris$Sepal.Length)\nest_desc[\"Sepal.Width\", \"Minimo\"] = min(iris$Sepal.Width)\nest_desc[\"Petal.Length\", \"Minimo\"] = min(iris$Petal.Length)\nest_desc[\"Petal.Width\", \"Minimo\"] = min(iris$Petal.Width)\n\nPor fim, vamos preencher a coluna do valor máximo:\n\nest_desc[\"Sepal.Length\", \"Maximo\"] = max(iris$Sepal.Length)\nest_desc[\"Sepal.Width\", \"Maximo\"] = max(iris$Sepal.Width)\nest_desc[\"Petal.Length\", \"Maximo\"] = max(iris$Petal.Length)\nest_desc[\"Petal.Width\", \"Maximo\"] = max(iris$Petal.Width)\n\nO resultado desse procedimento é o data frame a seguir:\n\nprint(est_desc, digits = 4)\n\n             Observacoes Media Desvio_Padrao Minimo Maximo\nSepal.Length         150 5.843        0.8281    4.3    7.9\nSepal.Width          150 3.057        0.4359    2.0    4.4\nPetal.Length         150 3.758        1.7653    1.0    6.9\nPetal.Width          150 1.199        0.7622    0.1    2.5\n\n\nExistem maneiras mais rápidas e mais eficientes de preparar uma tabela de estatísticas descritivas, porém, isso exige artifícios que só serão vistos em capítulos posteriores.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#exercício",
    "href": "aula2.html#exercício",
    "title": "2  Indexação e operações indexadas",
    "section": "2.11 Exercício",
    "text": "2.11 Exercício\nConsidere usar a base de dados nativa sobre carros mtcars.\n\ndf = mtcars\n\n(1) Remova o carro Fiat X1-9.\n(2) Usando o nome das linhas e das colunas, encontre o consumo (mpg) do Toyota Corolla.\n(3) Crie uma nova coluna de nome difCorolla mostrando a diferença entre o consumo médio de cada carro e o consumo médio do Toyota Corolla.\n(4) Crie uma nova coluna de nome consumo_peso mostrando o consumo (mpg) dos carros para cada tonelada de peso (wt).\n(5) Apague os carros de câmbio manual (carros com am = 0).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula3.html",
    "href": "aula3.html",
    "title": "3  Classes de elementos",
    "section": "",
    "text": "3.1 Elementos textuais: (strings)\nOs elementos textuais sempre devem ser declarados entre aspas, sejam aspas simples ou duplas, do contrário, a linguagem R não reconhecerá esse elemento como texto. A linguagem R não suporta operações matemáticas com elementos textuais, ao contrário de outras linguagens como Python onde operações matemáticas básicas podem ser aplicadas a esses elementos.\nImagine que seja necessário criar um data frame com o nome dos estados e os nomes das capitais da região Sul do Brasil. Nesse caso, os elemento são textuais e cada nome de estado e capital deve ser informado entre aspas conforme demonstrado a seguir:\nsul = data.frame(\n  estados = c(\"Paraná\", \"Santa Cararina\", \"Rio Grande do Sul\"),\n  capital = c(\"Curitiba\", \"Florianópolis\", \"Porto Alegre\")\n)\nprint(\"Sul\")\n\n[1] \"Sul\"\nCaso os elementos não sejam declarados entre aspas, a execução do comando retornará um erro.\nÉ possível checar qual a classe de um dado elemento ou de um dado objeto por meio do comando class(), informando o nome do objeto entre parêntesis. Por exemplo, é possível checar se o objeto criado anteriormente com o nome sul é um data frame, um vetor, um array, etc.\nclass(sul)\n\n[1] \"data.frame\"\nO comando class() também pode ser usado para verificar se um objeto possui ou não uma classe textual. Caso se trate de um objeto textual, então o comando class() retornará o output “character”, indicando que se trata de um caracter. Por exemplo, vamos verificar a classe da coluna de nome estados do objeto de nome sul:\nclass(sul$estados)\n\n[1] \"character\"\nElementos númericos ou outros tipos de elementos muitas vezes podem ser reconhecidos, declarados ou transformados em caracteres. Nesse caso, cabe ao usuário saber identificar a classe dos elementos e transformá-lo na classe desejada. Para exemplificar, considere incluir no data frame anterior o código de unidade federativa do ibge:\nsul$codigo_uf = c(41, 42, 43)\nprint(sul)\n\n            estados       capital codigo_uf\n1            Paraná      Curitiba        41\n2    Santa Cararina Florianópolis        42\n3 Rio Grande do Sul  Porto Alegre        43\nNote que os números não estão em aspas, indicando que não são caracteres. Abrindo o data frame, o usuário verá facilmente que as duas primeiras colunas estão com os valores alinhados à esquerda, enquanto a última coluna está alinhada à direita. Nesse caso, apenas visualizando esse alinhamento é possível afirmar que as duas primeiras colunas têm elementos textuais. No entanto, o usuário pode checar se as colunas são de fato strings usando o comando is.character(), indicando o nome do objeto ou elemento no parênteses. Por exemplo, para checar se o código do estado é um elemento textual, proceda conforme a seguir:\nis.character(sul$codigo_uf)\n\n[1] FALSE\nNote que o output foi FALSE, indicando que não se trata de um elemento textual. Caso o usuário precise dessa coluna como um elemento de texto, então ele pode usar o comando as.character(), indicando o nome do objeto ou elemento no parênteses. Nesse caso, o objeto ou elemento indicado será transformado forçadamente em um elemento textual. Para exemplificar, vamos transformar o código do estado em um caracter:\nsul$codigo_uf = as.character(sul$codigo_uf)\nChecando agora a classe da coluna, nota-se que se trata de um elemento textual:\nclass(sul$codigo_uf)\n\n[1] \"character\"\nExistem operações no âmbito da análise de dados que são usadas com esse tipo de elemento. Por exemplo, as análises de sentimento baseiam-se fundamentalmente em coletas de dados de texto. Um exemplo factível é a mensuração da sensibilidade do mercado financeiro em relação a intensidade do texto da ata do banco central. Esse procedimento é feito pela contagem de palavras pré-definidas na ata. Para esse tipo de operação existem bibliotecas que auxiliam o usuário e que serão vistas posteriormente quando estivermos abordando operações com strings.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "aula3.html#elementos-numéricos",
    "href": "aula3.html#elementos-numéricos",
    "title": "3  Classes de elementos",
    "section": "3.2 Elementos numéricos",
    "text": "3.2 Elementos numéricos\nOs elementos numéricos são todos os elementos representados na forma de números, sejam eles de quaisquer um dos conjuntos numéricos. Por exemplo, 2 é um elemento numérico do conjunto dos naturais inteiros, ao passo que 2.5 é um elemento numérico do conjunto dos números racionais. É possível checar se um elemento é numérico usando o comando class(), no entanto, é mais adequado usar o is.numeric(), indicando o nome do elemento em parênteses. Para exemplificar, vamos checar se a coluna codigo_uf do data frame de nome sul é numérico.\n\nis.numeric(sul$codigo_uf)\n\n[1] FALSE\n\n\nNote que o resultado é FALSE, indicando que não se trata de um elemento numérico. Caso o usuário precise transformar essa coluna em um elemento numérico, então ele pode usar o comando as.numeric(), indicando o nome do elemento em parêntesis:\n\nsul$codigo_uf = as.numeric(sul$codigo_uf)\n\nAgora podemos verificar novamente se a coluna é ou não numérica.\n\nis.numeric(sul$codigo_uf)\n\n[1] TRUE\n\n\nEm um data frame, as colunas numéricas sempre estarão alinhadas à direita e o usuário pode checar a classe dessa coluna posicionando o cursor sobre o seu nome no data frame.\nExiste, contudo, um problema associado ao uso do comando as.numeric(), dado que a transformação de um elemento não numérico para um elemento numérico só funciona perfeitamente caso o objeto não numérico seja composto por números declarados como caracteres, como é o caso da coluna codigo_uf. Do contrário, o resultado pode ser composto por NAs. Para exemplificar, vamos tentar transformar o nome dos estados em um objeto numérico:\n\nas.numeric(sul$estados)\n\nWarning: NAs introduzidos por coerção\n\n\n[1] NA NA NA\n\n\nPor esse motivo, antes de efetuar qualquer operação com um elemento numérico, é fundamental checar a sua classe para garantir que o resultado esteja de acordo com o esperado. Por exemplo, imagine o caso em que seja preciso calcular o pib per capita de um estado, sendo que o pib seja numérico e a população seja um caracter. Nesse caso, se o usuário não conhece a classe da população e não a transforma em um elemento numérico, o cálculo do pib per capita será feito dividindo um número por uma palavra, o que é algo inviável, resultando em um elemento do tipo NA.\n\n3.2.1 Subclasses dos numéricos: inteiros (integer)\nComo mencionado anteriormente, os elementos numéricos podem estar contidos em quaisquer um dos conjuntos numéricos. Uma subclasse bastante comum na economia são é a subclasse dos inteiros. Essa subclasse abriga os números inteiros positivos ou negativos e se caracteriza por abrigar um L após o número. Por exemplo, 10 é um elemento da classe numérica, mas 10L é um elemento da subclasse dos inteiros pertencente à classe dos numéricos.\nPara checar se um elemento é inteiro, use o comando is.integer(), indicando o elemento no parêntesis. Por exemplo, vamos checar se 10 é inteiro:\n\nis.integer(10)\n\n[1] FALSE\n\n\nNote que o resultado é FALSE, indicando que 10 não é inteiro. Isso ocore porque os números inteiros devem obrigatoriamente ser sucedidos da letra L. Informando corretamente tem-se:\n\nis.integer(10L)\n\n[1] TRUE\n\n\nPara transformar um elemento numérico na subclasse dos inteiros, basta usar a função as.integer(), informando o elemento no parênteses. Por exemplo, vamos transformar o código do estado no data frame de nome sul em inteiro.\n\nsul$codigo_uf = as.integer(sul$codigo_uf)\nprint(sul)\n\n            estados       capital codigo_uf\n1            Paraná      Curitiba        41\n2    Santa Cararina Florianópolis        42\n3 Rio Grande do Sul  Porto Alegre        43\n\n\nNote que visivelmente não há mudanças nas propriedades da coluna modificada, porém agora quando consultarmos se essa coluna pertence ao conjunto dos inteiros, o output é verdadeiro:\n\nis.integer(sul$codigo_uf)\n\n[1] TRUE\n\n\n\n\n3.2.2 Subclasses dos numéricos: racionais (doubles)\nOs números racionais são declarados como doubles na linguagem R. Esse conjunto abriga também os inteiros e os naturais, isto é, um inteiro sempre será um double, assim como um natural sempre será um double. Para checar se um número pertence a essa categoria, use a função is.double(), indicando o elemento de interesse no parênteses.\n\nis.double(10.5555)\n\n[1] TRUE\n\n\nDe maneira análoga, um elemento numérico declarado como texto pode ser trannsformado em racional usando a função as.double(), indicando o elemento de interesse no parênteses.\n\nas.double(\"10.5\")\n\n[1] 10.5\n\n\nEm alguns casos, os números racionais possuem múltiplas casas decimais e é preciso reduzir essas casas decimais arredondando a última casa. Isso pode ser facilmente resolvido usando a função round(), que possui o seguinte modo de uso: round(nome do objeto ou elemento, número de casas decimais). Por exemeplo, imagine que queiramos reduzir o número 5.56413 para apenas uma casa decimal. Nesse caso, devemos proceder conforme a seguir:\n\nround(5.564132, 1)\n\n[1] 5.6",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "aula3.html#elementos-lógicos-true-e-false",
    "href": "aula3.html#elementos-lógicos-true-e-false",
    "title": "3  Classes de elementos",
    "section": "3.3 Elementos lógicos: (TRUE e FALSE)",
    "text": "3.3 Elementos lógicos: (TRUE e FALSE)\nOs elementos lógicos podem assumir dois valores, verdadeiro (TRUE) ou falso (FALSE). Sempre que o elemento lógico for verdadeiro, o R atribui valor 1 a este elemento, ao passo que sempre que o elemento lógico for falso, o R atribui valor 0 a este elemento. Assim, é possível aplicar operações matemáticas aos elementos pertencentes a essa classe. Isso advém da premissa de que as linguagens de programação são baseados em sistemas binários de afirmação e negação comentada no capítulo 1.\nEssa classe de elementos é bastante utilizada na economia para representar variáveis binárias onde a categoria de interesse recebe o valor unitário. Por exemplo, imagine uma pesquisa com foco no diferencial de salário por sexo. Nesse tipo de pesquisa é ideal saber se o indivíduo é homem ou mulher. Se a categoria de interesse for o sexo masculino, então os homens recebem valor TRUE e as mulheres recebem vaor FALSE. Isso equivale a atribuir 1 para os homens e 0 para as mulheres.\nPara verificar se um elemento pertence a essa categoria, use a função is.logical(), indicando o nome do elemento entre o parênteses. Para exemplificar, vamos criar uma nova coluna no data frame de estados da regiao sul com o nome parana que identifica se o estado em questão é ou não o estado do Paraná.\n\nsul$parana = c(1,0,0)\nprint(sul)\n\n            estados       capital codigo_uf parana\n1            Paraná      Curitiba        41      1\n2    Santa Cararina Florianópolis        42      0\n3 Rio Grande do Sul  Porto Alegre        43      0\n\n\nAgora vamos checar se essa coluna é um elemento lógico.\n\nis.logical(sul$parana)\n\n[1] FALSE\n\n\nNote que o output é FALSE, indicando que não se trata de um elemento lógico, o que é esperado dado que se trata de um elemento numérico. Para transformar essa coluna em um elemento lógico, basta usar a função as.logical(), indicando o nome do elemento de interesse no parênteses.\n\nsul$parana = as.logical(sul$parana)\nprint(sul)\n\n            estados       capital codigo_uf parana\n1            Paraná      Curitiba        41   TRUE\n2    Santa Cararina Florianópolis        42  FALSE\n3 Rio Grande do Sul  Porto Alegre        43  FALSE\n\n\nAgora vamos checar novamente se essa coluna é um elemento lógico.\n\nis.logical(sul$parana)\n\n[1] TRUE\n\n\nNote que o output é TRUE, indicando que se trata de um elemento lógico.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "aula3.html#valores-multicategóricos-fatores-factors",
    "href": "aula3.html#valores-multicategóricos-fatores-factors",
    "title": "3  Classes de elementos",
    "section": "3.4 Valores multicategóricos: Fatores (factors)",
    "text": "3.4 Valores multicategóricos: Fatores (factors)\nOs factors são elementos usados para representar valores multicategóricos. Por exemplo, imagine uma variável que expressa a situação do empregado no mercado de trabalho. Ele pode estar (1) apenas trabalhando, (2) apenas estudando, (3) trabalhando e estudando, (4) nem trabalhando nem estudando porém procurando emprego, ou (5) nem trabalhando nem estudando nem procurando emprego. Note que são cinco possibilidades que agora não podem ser representadas pelos elementos lógicos.\nPara declarar um elemento multicategórico é necessário usar o comando factor() que tem a seguinte forma de uso: factor(x = elemento, levels = níveis das categorias). Para exemplificar, vamos criar um objeto de nome emprego com as possibilidades indicadas no parágrafo anterior e os seus respectivos valores.\n\nemprego = factor(\n  x = c(\n    \"apenas trabalhando\", \n    \"apenas estudando\", \n    \"trabalhando e estudando\", \n    \"nem trabalhando nem estudando porém procurando emprego\",\n    \"nem trabalhando nem estudando nem procurando emprego\"\n  ),\n  levels = c(\n    \"apenas trabalhando\", \n    \"apenas estudando\", \n    \"trabalhando e estudando\", \n    \"nem trabalhando nem estudando porém procurando emprego\",\n    \"nem trabalhando nem estudando nem procurando emprego\"\n  )\n)\n\nprint(emprego)\n\n[1] apenas trabalhando                                    \n[2] apenas estudando                                      \n[3] trabalhando e estudando                               \n[4] nem trabalhando nem estudando porém procurando emprego\n[5] nem trabalhando nem estudando nem procurando emprego  \n5 Levels: apenas trabalhando apenas estudando ... nem trabalhando nem estudando nem procurando emprego\n\n\nSerá atribuído valor 1 para a primeira categoria indicada no vetor de níveis (levels), 2 para a segunda categoria e assim sucessivamente.\nPara checar se um elemento é multicategórico, devs-se usar a função is.factor(), indicando o nome do elemento no parênteses.\n\nis.factor(emprego)\n\n[1] TRUE",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "aula3.html#exercício-1",
    "href": "aula3.html#exercício-1",
    "title": "3  Classes de elementos",
    "section": "3.5 Exercício 1",
    "text": "3.5 Exercício 1\nConsidere o seguinte data frame:\n\nset.seed(10)\ndados = data.frame(\n  pessoa = 1:30,\n  idade = sample(8:85,30, replace = T),\n  sexo = sample(c(\"M\", \"F\"), 30, replace = T),\n  estado_civil = sample(c(\"Solteiro\", \"Casado\", \"Viúvo\", \"Divorciado\"), 30, replace = T),\n  salario = rnorm(30, mean = 1200, sd = 300)\n)\n\n(1) Crie uma variável de nome sexo2 transformando a variável sexo em um elemento lógico atribuindo o valor unitário para as mulheres.\n(2) Crie uma variável de nome fase_vida atribuindo os nomes infância para as pessoas com menos de 12 anos, adolescência para as pessoas com idade entre 12 e 18 anos, adulta para as pessoas com idade entre 18 e 65 anos e velhice para as pessoas com mais de 65 anos.\n(3) Crie uma nova variável de nome fase_vida2 transformando a variável fase_vida em um factor ordenando as categorias de acordo com a fase da vida em ordem crescente.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "aula3.html#exercício-2",
    "href": "aula3.html#exercício-2",
    "title": "3  Classes de elementos",
    "section": "3.6 Exercício 2",
    "text": "3.6 Exercício 2\nConsidere a base de dados sobre carros mtcars:\n\ncarros = mtcars\n\n(1) Crie uma coluna de nome automatico transformando a coluna am em um elemento lógico.\n(2) Transforme a coluna cyl em um factor onde o atributo x recebe os valores “4 cilindros”, “6 cilindore” e “8 cilindros” ordenados na forma crescente.\n(3) Crie uma nova coluna de nome carro contendo o nome dos carros indicados nos nomes das linhas do data frame.\n(4) Verifique a casse da coluna criada na questão.\n(5) Verifique se a coluna criada nas questões 1 e 2 são factors.\n(6) Verifique se a coluna mpg é inteiro e caso não seja transforme-a em inteiro.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "Aula3.html",
    "href": "Aula3.html",
    "title": "3  Classes de elementos",
    "section": "",
    "text": "3.1 Elementos textuais: (strings)\nOs dados podem assumir diversos formatos, por exemplo, números, textos, imagens, etc. A depender da ocasião, o usuário precisará lidar com um tipo de dado específico. Por exemplo, um economista prevendo preços no mercado de ações utilizará objetos numéricos para representar o preço dos ativos. Um técnico em radiologia coleta informações em imagem de um paciente. Um especialista em análise de sentimento em redes sociais coleta os textos das postagens para extrair delas informações úteis. Cada tipo de informação tem uma utilidade e um propósito e cada tipo de informação possui propriedades que o analista de dados precisa conhecer.\nUm objeto criado possui múltiplos elementos e esses elementos podem ser de diferentes tipos. Esses “tipos” de elementos recebem o nome de classe. Existem operações que são aplicadas adequadamente a uma classe de elementos específica, por exemplo, é possível somar dois elementos numéricos mas é estranho pensar em somar duas palavras. Nesse capítulo vamos conhecer as principais classes de dados, suas características e as principais operações que podem ser realizadas com cada classe.\nOs elementos textuais sempre devem ser declarados entre aspas, sejam aspas simples ou duplas, do contrário, a linguagem R não reconhecerá esse elemento como texto. A linguagem R não suporta operações matemáticas com elementos textuais, ao contrário de outras linguagens como Python onde operações matemáticas básicas podem ser aplicadas a esses elementos.\nImagine que seja necessário criar um data frame com o nome dos estados e os nomes das capitais da região Sul do Brasil. Nesse caso, os elemento são textuais e cada nome de estado e capital deve ser informado entre aspas conforme demonstrado a seguir:\nsul = data.frame(\n  estados = c(\"Paraná\", \"Santa Cararina\", \"Rio Grande do Sul\"),\n  capital = c(\"Curitiba\", \"Florianópolis\", \"Porto Alegre\")\n)\nprint(\"Sul\")\n\n[1] \"Sul\"\nCaso os elementos não sejam declarados entre aspas, a execução do comando retornará um erro.\nÉ possível checar qual a classe de um dado elemento ou de um dado objeto por meio do comando class(), informando o nome do objeto entre parêntesis. Por exemplo, é possível checar se o objeto criado anteriormente com o nome sul é um data frame, um vetor, um array, etc.\nclass(sul)\n\n[1] \"data.frame\"\nO comando class() também pode ser usado para verificar se um objeto possui ou não uma classe textual. Caso se trate de um objeto textual, então o comando class() retornará o output “character”, indicando que se trata de um caracter. Por exemplo, vamos verificar a classe da coluna de nome estados do objeto de nome sul:\nclass(sul$estados)\n\n[1] \"character\"\nElementos númericos ou outros tipos de elementos muitas vezes podem ser reconhecidos, declarados ou transformados em caracteres. Nesse caso, cabe ao usuário saber identificar a classe dos elementos e transformá-lo na classe desejada. Para exemplificar, considere incluir no data frame anterior o código de unidade federativa do ibge:\nsul$codigo_uf = c(41, 42, 43)\nprint(sul)\n\n            estados       capital codigo_uf\n1            Paraná      Curitiba        41\n2    Santa Cararina Florianópolis        42\n3 Rio Grande do Sul  Porto Alegre        43\nNote que os números não estão em aspas, indicando que não são caracteres. Abrindo o data frame, o usuário verá facilmente que as duas primeiras colunas estão com os valores alinhados à esquerda, enquanto a última coluna está alinhada à direita. Nesse caso, apenas visualizando esse alinhamento é possível afirmar que as duas primeiras colunas têm elementos textuais. No entanto, o usuário pode checar se as colunas são de fato strings usando o comando is.character(), indicando o nome do objeto ou elemento no parênteses. Por exemplo, para checar se o código do estado é um elemento textual, proceda conforme a seguir:\nis.character(sul$codigo_uf)\n\n[1] FALSE\nNote que o output foi FALSE, indicando que não se trata de um elemento textual. Caso o usuário precise dessa coluna como um elemento de texto, então ele pode usar o comando as.character(), indicando o nome do objeto ou elemento no parênteses. Nesse caso, o objeto ou elemento indicado será transformado forçadamente em um elemento textual. Para exemplificar, vamos transformar o código do estado em um caracter:\nsul$codigo_uf = as.character(sul$codigo_uf)\nChecando agora a classe da coluna, nota-se que se trata de um elemento textual:\nclass(sul$codigo_uf)\n\n[1] \"character\"\nExistem operações no âmbito da análise de dados que são usadas com esse tipo de elemento. Por exemplo, as análises de sentimento baseiam-se fundamentalmente em coletas de dados de texto. Um exemplo factível é a mensuração da sensibilidade do mercado financeiro em relação a intensidade do texto da ata do banco central. Esse procedimento é feito pela contagem de palavras pré-definidas na ata. Para esse tipo de operação existem bibliotecas que auxiliam o usuário e que serão vistas posteriormente quando estivermos abordando operações com strings.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "Aula3.html#elementos-numéricos",
    "href": "Aula3.html#elementos-numéricos",
    "title": "3  Classes de elementos",
    "section": "3.2 Elementos numéricos",
    "text": "3.2 Elementos numéricos\nOs elementos numéricos são todos os elementos representados na forma de números, sejam eles de quaisquer um dos conjuntos numéricos. Por exemplo, 2 é um elemento numérico do conjunto dos naturais inteiros, ao passo que 2.5 é um elemento numérico do conjunto dos números racionais. É possível checar se um elemento é numérico usando o comando class(), no entanto, é mais adequado usar o is.numeric(), indicando o nome do elemento em parênteses. Para exemplificar, vamos checar se a coluna codigo_uf do data frame de nome sul é numérico.\n\nis.numeric(sul$codigo_uf)\n\n[1] FALSE\n\n\nNote que o resultado é FALSE, indicando que não se trata de um elemento numérico. Caso o usuário precise transformar essa coluna em um elemento numérico, então ele pode usar o comando as.numeric(), indicando o nome do elemento em parêntesis:\n\nsul$codigo_uf = as.numeric(sul$codigo_uf)\n\nAgora podemos verificar novamente se a coluna é ou não numérica.\n\nis.numeric(sul$codigo_uf)\n\n[1] TRUE\n\n\nEm um data frame, as colunas numéricas sempre estarão alinhadas à direita e o usuário pode checar a classe dessa coluna posicionando o cursor sobre o seu nome no data frame.\nExiste, contudo, um problema associado ao uso do comando as.numeric(), dado que a transformação de um elemento não numérico para um elemento numérico só funciona perfeitamente caso o objeto não numérico seja composto por números declarados como caracteres, como é o caso da coluna codigo_uf. Do contrário, o resultado pode ser composto por NAs. Para exemplificar, vamos tentar transformar o nome dos estados em um objeto numérico:\n\nas.numeric(sul$estados)\n\nWarning: NAs introduzidos por coerção\n\n\n[1] NA NA NA\n\n\nPor esse motivo, antes de efetuar qualquer operação com um elemento numérico, é fundamental checar a sua classe para garantir que o resultado esteja de acordo com o esperado. Por exemplo, imagine o caso em que seja preciso calcular o pib per capita de um estado, sendo que o pib seja numérico e a população seja um caracter. Nesse caso, se o usuário não conhece a classe da população e não a transforma em um elemento numérico, o cálculo do pib per capita será feito dividindo um número por uma palavra, o que é algo inviável, resultando em um elemento do tipo NA.\n\n3.2.1 Subclasses dos numéricos: inteiros (integer)\nComo mencionado anteriormente, os elementos numéricos podem estar contidos em quaisquer um dos conjuntos numéricos. Uma subclasse bastante comum na economia são é a subclasse dos inteiros. Essa subclasse abriga os números inteiros positivos ou negativos e se caracteriza por abrigar um L após o número. Por exemplo, 10 é um elemento da classe numérica, mas 10L é um elemento da subclasse dos inteiros pertencente à classe dos numéricos.\nPara checar se um elemento é inteiro, use o comando is.integer(), indicando o elemento no parêntesis. Por exemplo, vamos checar se 10 é inteiro:\n\nis.integer(10)\n\n[1] FALSE\n\n\nNote que o resultado é FALSE, indicando que 10 não é inteiro. Isso ocore porque os números inteiros devem obrigatoriamente ser sucedidos da letra L. Informando corretamente tem-se:\n\nis.integer(10L)\n\n[1] TRUE\n\n\nPara transformar um elemento numérico na subclasse dos inteiros, basta usar a função as.integer(), informando o elemento no parênteses. Por exemplo, vamos transformar o código do estado no data frame de nome sul em inteiro.\n\nsul$codigo_uf = as.integer(sul$codigo_uf)\nprint(sul)\n\n            estados       capital codigo_uf\n1            Paraná      Curitiba        41\n2    Santa Cararina Florianópolis        42\n3 Rio Grande do Sul  Porto Alegre        43\n\n\nNote que visivelmente não há mudanças nas propriedades da coluna modificada, porém agora quando consultarmos se essa coluna pertence ao conjunto dos inteiros, o output é verdadeiro:\n\nis.integer(sul$codigo_uf)\n\n[1] TRUE\n\n\n\n\n3.2.2 Subclasses dos numéricos: racionais (doubles)\nOs números racionais são declarados como doubles na linguagem R. Esse conjunto abriga também os inteiros e os naturais, isto é, um inteiro sempre será um double, assim como um natural sempre será um double. Para checar se um número pertence a essa categoria, use a função is.double(), indicando o elemento de interesse no parênteses.\n\nis.double(10.5555)\n\n[1] TRUE\n\n\nDe maneira análoga, um elemento numérico declarado como texto pode ser trannsformado em racional usando a função as.double(), indicando o elemento de interesse no parênteses.\n\nas.double(\"10.5\")\n\n[1] 10.5\n\n\nEm alguns casos, os números racionais possuem múltiplas casas decimais e é preciso reduzir essas casas decimais arredondando a última casa. Isso pode ser facilmente resolvido usando a função round(), que possui o seguinte modo de uso: round(nome do objeto ou elemento, número de casas decimais). Por exemeplo, imagine que queiramos reduzir o número 5.56413 para apenas uma casa decimal. Nesse caso, devemos proceder conforme a seguir:\n\nround(5.564132, 1)\n\n[1] 5.6",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "Aula3.html#elementos-lógicos-true-e-false",
    "href": "Aula3.html#elementos-lógicos-true-e-false",
    "title": "3  Classes de elementos",
    "section": "3.3 Elementos lógicos: (TRUE e FALSE)",
    "text": "3.3 Elementos lógicos: (TRUE e FALSE)\nOs elementos lógicos podem assumir dois valores, verdadeiro (TRUE) ou falso (FALSE). Sempre que o elemento lógico for verdadeiro, o R atribui valor 1 a este elemento, ao passo que sempre que o elemento lógico for falso, o R atribui valor 0 a este elemento. Assim, é possível aplicar operações matemáticas aos elementos pertencentes a essa classe. Isso advém da premissa de que as linguagens de programação são baseados em sistemas binários de afirmação e negação comentada no capítulo 1.\nEssa classe de elementos é bastante utilizada na economia para representar variáveis binárias onde a categoria de interesse recebe o valor unitário. Por exemplo, imagine uma pesquisa com foco no diferencial de salário por sexo. Nesse tipo de pesquisa é ideal saber se o indivíduo é homem ou mulher. Se a categoria de interesse for o sexo masculino, então os homens recebem valor TRUE e as mulheres recebem vaor FALSE. Isso equivale a atribuir 1 para os homens e 0 para as mulheres.\nPara verificar se um elemento pertence a essa categoria, use a função is.logical(), indicando o nome do elemento entre o parênteses. Para exemplificar, vamos criar uma nova coluna no data frame de estados da regiao sul com o nome parana que identifica se o estado em questão é ou não o estado do Paraná.\n\nsul$parana = c(1,0,0)\nprint(sul)\n\n            estados       capital codigo_uf parana\n1            Paraná      Curitiba        41      1\n2    Santa Cararina Florianópolis        42      0\n3 Rio Grande do Sul  Porto Alegre        43      0\n\n\nAgora vamos checar se essa coluna é um elemento lógico.\n\nis.logical(sul$parana)\n\n[1] FALSE\n\n\nNote que o output é FALSE, indicando que não se trata de um elemento lógico, o que é esperado dado que se trata de um elemento numérico. Para transformar essa coluna em um elemento lógico, basta usar a função as.logical(), indicando o nome do elemento de interesse no parênteses.\n\nsul$parana = as.logical(sul$parana)\nprint(sul)\n\n            estados       capital codigo_uf parana\n1            Paraná      Curitiba        41   TRUE\n2    Santa Cararina Florianópolis        42  FALSE\n3 Rio Grande do Sul  Porto Alegre        43  FALSE\n\n\nAgora vamos checar novamente se essa coluna é um elemento lógico.\n\nis.logical(sul$parana)\n\n[1] TRUE\n\n\nNote que o output é TRUE, indicando que se trata de um elemento lógico.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "Aula3.html#valores-multicategóricos-fatores-factors",
    "href": "Aula3.html#valores-multicategóricos-fatores-factors",
    "title": "3  Classes de elementos",
    "section": "3.4 Valores multicategóricos: Fatores (factors)",
    "text": "3.4 Valores multicategóricos: Fatores (factors)\nOs factors são elementos usados para representar valores multicategóricos. Por exemplo, imagine uma variável que expressa a situação do empregado no mercado de trabalho. Ele pode estar (1) apenas trabalhando, (2) apenas estudando, (3) trabalhando e estudando, (4) nem trabalhando nem estudando porém procurando emprego, ou (5) nem trabalhando nem estudando nem procurando emprego. Note que são cinco possibilidades que agora não podem ser representadas pelos elementos lógicos.\nPara declarar um elemento multicategórico é necessário usar o comando factor() que tem a seguinte forma de uso: factor(x = elemento, levels = níveis das categorias). Para exemplificar, vamos criar um objeto de nome emprego com as possibilidades indicadas no parágrafo anterior e os seus respectivos valores.\n\nemprego = factor(\n  x = c(\n    \"apenas trabalhando\", \n    \"apenas estudando\", \n    \"trabalhando e estudando\", \n    \"nem trabalhando nem estudando porém procurando emprego\",\n    \"nem trabalhando nem estudando nem procurando emprego\"\n  ),\n  levels = c(\n    \"apenas trabalhando\", \n    \"apenas estudando\", \n    \"trabalhando e estudando\", \n    \"nem trabalhando nem estudando porém procurando emprego\",\n    \"nem trabalhando nem estudando nem procurando emprego\"\n  )\n)\n\nprint(emprego)\n\n[1] apenas trabalhando                                    \n[2] apenas estudando                                      \n[3] trabalhando e estudando                               \n[4] nem trabalhando nem estudando porém procurando emprego\n[5] nem trabalhando nem estudando nem procurando emprego  \n5 Levels: apenas trabalhando apenas estudando ... nem trabalhando nem estudando nem procurando emprego\n\n\nSerá atribuído valor 1 para a primeira categoria indicada no vetor de níveis (levels), 2 para a segunda categoria e assim sucessivamente.\nPara checar se um elemento é multicategórico, devs-se usar a função is.factor(), indicando o nome do elemento no parênteses.\n\nis.factor(emprego)\n\n[1] TRUE",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "Aula3.html#exercício-1",
    "href": "Aula3.html#exercício-1",
    "title": "3  Classes de elementos",
    "section": "3.5 Exercício 1",
    "text": "3.5 Exercício 1\nConsidere o seguinte data frame:\n\nset.seed(10)\ndados = data.frame(\n  pessoa = 1:30,\n  idade = sample(8:85,30, replace = T),\n  sexo = sample(c(\"M\", \"F\"), 30, replace = T),\n  estado_civil = sample(c(\"Solteiro\", \"Casado\", \"Viúvo\", \"Divorciado\"), 30, replace = T),\n  salario = rnorm(30, mean = 1200, sd = 300)\n)\n\n(1) Crie uma variável de nome sexo2 transformando a variável sexo em um elemento lógico atribuindo o valor unitário para as mulheres.\n(2) Crie uma variável de nome fase_vida atribuindo os nomes infância para as pessoas com menos de 12 anos, adolescência para as pessoas com idade entre 12 e 18 anos, adulta para as pessoas com idade entre 18 e 65 anos e velhice para as pessoas com mais de 65 anos.\n(3) Crie uma nova variável de nome fase_vida2 transformando a variável fase_vida em um factor ordenando as categorias de acordo com a fase da vida em ordem crescente.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "Aula3.html#exercício-2",
    "href": "Aula3.html#exercício-2",
    "title": "3  Classes de elementos",
    "section": "3.6 Exercício 2",
    "text": "3.6 Exercício 2\nConsidere a base de dados sobre carros mtcars:\n\ncarros = mtcars\n\n(1) Crie uma coluna de nome automatico transformando a coluna am em um elemento lógico.\n(2) Transforme a coluna cyl em um factor onde o atributo x recebe os valores “4 cilindros”, “6 cilindore” e “8 cilindros” ordenados na forma crescente.\n(3) Crie uma nova coluna de nome carro contendo o nome dos carros indicados nos nomes das linhas do data frame.\n(4) Verifique a casse da coluna criada na questão.\n(5) Verifique se a coluna criada nas questões 1 e 2 são factors.\n(6) Verifique se a coluna mpg é inteiro e caso não seja transforme-a em inteiro.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução à Programação e à Ciência de Dados",
    "section": "",
    "text": "Prefácio\nEsse é um material construído para auxiliar os discentes do curso de Ciências Econômicas da Universidade Regional do Cariri no decorrer da disciplina de Introdução à programação e à ciência de dados, ministrada no terceiro período do curso. O material possui os instrumentos básicos para o acompanhamento do curso, incluindo explicações, comandos e exercícios. O material está organizado na ordem cronológica dos conteúdos repassados na disciplina de tal modo que essa ordem tem o intúito de conduzir o discente no aprendizado da programação computacional aplicada à economia em um cronograma planejado de acordo com as boas práticas do aprendizado da programação, evitando que o discente comece os estudos por conteúdos inadequados para os iniciantes nessa área.\nO foco do material é a linguagem R, a mesma utilizada como objeto central da disciplina. Contudo, os métodos de aprendizado também podem ser expandidos para outras linguagens, desde que as devidas adaptações de vocabulário sejam consideradas. O material também possui um foco na análise de dados, desviando-se da programação computacional “bruta” devido a necessidade do curso e dos economistas em dominar os fundamentos básicos da utilização de dados.",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introdução",
    "section": "",
    "text": "1.1 A lógica de programação\nImagine que o computador é uma empresa que realiza diferentes tarefas e que nessa empresa existem funcionários de várias partes do mundo. Cada funcionário realiza as mesmas tarefas, porém, falando diferentes idiomas. Assim, se você quer que um funcionário americano realize uma tarefa, terá que ordenar que ele a faça em inglês; se você quer que um funcionário italiano realize a mesma tarefa, terá de fazer o pedido para ele falando italiano, e assim sucessivamente. No computador, os funcionários são as linguagens de programação e o idioma é o vocabulário da linguagem (ou a maneira de escrever os comandos em cada linguagem). Resumidamente e exemplificadamente, você pode executar uma tarefa usando R ou pode executar essa mesma tarefa usando Python ou qualquer outra linguagem de programação pois a lógica de comunicação com o computador será a mesma, porém, os comandos para execuar a mesma tarefa podem ser diferentes em cada linguagem. Como consequência, o primeiro passo para dominar as linguagens de programação é desenvolver uma lógica de programação.\nA lógica de programação é um raciocínio sobre como se comunicar com o computador para realizar tarefas. Seguindo o exemplo da empresa citado no parágrafo anterior, se você precisa de um relatório impresso, terá de falar o seguinte “eu preciso que você imprima esse relatório”. Porém, como os funcionários falam diferentes idiomas, você precisa fazer esse pedido em uma linguagem diferente a depender do funcionário responsável pela impressão. A maneira como você faz o pedido (“eu preciso que você imprima esse relatório”) não vai mudar independente do funcionário que receberá a ordem, o que muda é apenas o idioma em que a ordem será feita. No computador, essa maneira como você faz o pedido é a lógica de programação, ela será a mesma para qualquer linguagem de programação, que no caso do exemplo corresponde ao idioma falado.\nO primeiro passo para desenvolver uma lógica de programação é entender as operações fundamentais de uma linguagem de programação. Uma linguagem de programação é nada mais do que uma maneira de se comunicar com o computador para ordenar que ele execute tarefas automáticas. As linguagens são configuradas em sistemas binários (negação e afirmação). Cada linguagem de programação possui o seu vocabulário, porém, todas as linguagens partem dos mesmos princípios e das mesmas lógicas fundamentais. Exemplos: JavaScript, R, Python, Julia, Ruby, Scala…",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#como-usar-a-linguagem-de-programação",
    "href": "intro.html#como-usar-a-linguagem-de-programação",
    "title": "1  Introdução",
    "section": "1.2 Como usar a linguagem de programação",
    "text": "1.2 Como usar a linguagem de programação\nO primeiro paso para se comunicar com o computador por meio de uma linguagem de programação é informar à máquina a sua intenção de usar o vocabulário da linguagem. Em outras palavras, é preciso “instalar” a linguagem em sua máquina. Na analogia da empresa anteriormente mencionada, instalar a linguagem de programação seria como fazer um curso de idiomas e receber um manual de instruções de gramática para falar com os empregados.\nNesse material, utilizaremos a linguagem R. Seguindo o primeiro passo, a instalação da linguagem deve ser feita antes de qualquer outro procedimento. Os métodos de instalação variam de acordo com o sistema operacional do usuário. Nesse material, vamos supor que o aluno dispõe de uma máquina com sistema operacional windows. Nesse caso, o usuário deve baixar os componentes da linguagem nesse endereço Tendo feito isso, o usuário deve executar o arquivo baixado e instalar normalmente como qualquer instalação convencional no sistema windows.\nO segundo passo é adotar um ambiente de execução. Esses ambientes são softwares também conhecidos como ambiente de desenvolvimento integrado (IDE) - Exemplos: Rstudio, Pycharm, Google Colaboratory, StataMP-. De forma geral, o IDE é uma plataforma onde você escreve as ordens que deseja que o computador execute em uma determinada linguagem. Especificando com outras palavras, o ambiente de execução é um software usado para escrever as ordens ao computador por meio do vocabulário da linguagem. Como vamos usar a linguagem R nesse material, temos que adotar um IDE que execute ordens nessa linguagem. É recomendado que o usuário utilize o Rstudio apesar de existirem diversas outras ferramentas com esse mesmo propósito. Para tanto, é preciso baixar o programa nesse endereço e proceder com com os procedimentos padrões de instalação de softwares no sistema windows.\nÉ importante ressaltar que uma linguagem de programação não é um software, por exemplo, é errôneo se referir à linguagem R como “software R”, assim como é equivocado se referir à linguagem stata como “software stata”, e assim sucessivamente. Também é importante destacar que os IDEs não são linguagens de programação, eles apenas transferem para o computador uma ordem para ser executado em uma determinada linguagem. Com isso, é errôneo afirmar que uma dada tarefa foi “executada pelo software Rstudio”.\nAo instalar o Rstudio, o usuário irá se deparar com a tela ilustrada na imagem a seguir. Note que o IDE é formado por quatro painéis, cada um deles com a sua funcionalidade. O painel 1 é conhecido como input ou painel de entrada. Nesse painel o usuário irá abrir e manipular os arquivos de entrada como scripts e códigos de programação em R. Outros arquivos de entrada também são suportados como arquivos html, markdown, dentre outros. Mas essas extensões adicionais não são o foco do curso. Para gerar um arquivo de entrada onde serão escritos os comandos da linguagem R, pressione Ctrl Shift n ou vá na parte superior esquerda, na barra de tarefas do IDE em file, new file, r script.\nO painel 2 é conhecido como console. Nesse painel serão expostos os resultados das tarefas executadas nos comandos escritos no painel 1. O usuário também pode escrever e executar os comandos diretamente no console, com a diferença de que no r script os códigos podem ser salvos para o uso posterior ao contrário do console.\nO painel 3 é conhecido como ambiente de trabalho ou working environment. Ele é dividido em quatro abas que podem ser acessadas separadamente, sendo: o Environment onde são expostos todos os objetos criados, o histórico (history) onde os últimos comandos ficam armazenados numa espécie de breve histórico de comandos, as conecções (Connectione) onde são expostas as ferramentas conectadas a linguagem R e ao Rstudio para executar tarefas, e a aba de tutoriais, onde o usuário pode acessar um breve guia sobre como usar o Rstudio. Versões mais recentes também disponibilizam abas adicionais sobre controle de versionamento no ambiente de trabalho, mas por enquanto esse não é o foco do curso.\nO painel 4 é conhecido como output ou painel de saída. Nele o usuário pode visualizar os produtos gerados com os comandos e navegar pelo diretório de trabalho. O painel é dividido em cinco abas, sendo: a aba de arquivos (files), onde o usuário pode navegar pela pasta que está usando; a aba plots, onde o usuário pode visualizar gráficos e figuras geradas com os comandos escritos no painel 1; a aba de bibliotecas (packages) onde o usuário pode acessar as bibliotecas instaladas na linguagem; a aba de ajuda (Help), onde o usuário pode consultar manuais de instrução sobre diferentes comandos e bibliotecas; e por fim a aba de visualização (View), onde o usuário pode visualizar objetos dinâmicos ou estáticos criados com alguma ferramenta adicional auxiliar à linguagem R como páginas web, arquivos pdf, etc.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#comandos",
    "href": "intro.html#comandos",
    "title": "1  Introdução",
    "section": "1.3 Comandos",
    "text": "1.3 Comandos\nOs ambientes de execução podem operar em ordens diretas (cliques) ou comunicação agrupada (comandos). Os ambientes de execução sugeridos nesta disciplina operam com linhas de comando. Nas linhas de comando, o operador (aluno) escreve uma ordem que o ambiente de execução entende como um comando para executar uma tarefa. Esses comandos são escritos individualmente em cada linha, isto é, cada linha escrita só agrupa um único comando. Ao escrever uma linha de comando no Rstudio, você poderá executar essse comando posicionando o cursor na linha (ou selecionando as linhas de interesse) e em seguida pressionando “Ctrl Enter”.\nAlguns comandos já estão pré-programados no vocabulário das linguagens. Porém outros comandos precisam ser elaborados pelo próprio usuário usando os comandos pré-progamados e as demais ferramentas próprias do vocabulário da linguagem. Por exemplo, se você quer somar dois números quaisquer a e b, você pode fazer isso com uma operação de soma que já é automaticamente reconhecida pela linguagem R. Mas se você quer somar \\(a + b\\) apenas se \\(a &gt; b\\), então você precisa usar a lógica de programação para programar esse comando.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#bibliotecas",
    "href": "intro.html#bibliotecas",
    "title": "1  Introdução",
    "section": "1.4 Bibliotecas",
    "text": "1.4 Bibliotecas\nO usuário pode ordenar que o computador execute uma tarefa por meio de comandos. Além disso, o usuário também pode unir vários comandos em uma função para executar uma tarefa de interesse. Muitas funções já estão disponíveis na própria linguagem nativa, por exemplo, caso o usuário queira gerar um gráfico ele pode usar o comando plot() que é uma função que usa vários comandos nativos da linguagem R para gerar uma figura. Assim como a função plot, muitas outras funções já estão disponíveis e prontas para o acesso no ato da instalação da linguagem. Porém, existem funções que são criadas por terceiros e que precisam ser instaladas para que possam ser usadas. Por exemplo, em vez de elaborar um gráfico com a função plot, o usuário pode usar a função ggplot. No entanto, essa função só pode ser usada caso a biblioteca ggplo2 esteja instalada. O usuário pode verificar se uma determinada biblioteca está instalada navegando pelo painel inferior direito, na aba Packages, digitando o nome da biblioteca na guia de busca. Caso a biblioteca esteja instalada, então a busca retornará um indicativo com o nome da biblioteca, do contrário, o resultado da busca será vazio.\nPara instalar uma biblioteca o usuário deve usar o comando install.packages() posicionando no parêntesis o nome da biblioteca entre aspas. Por exemplo, para instalar a biblioteca ggplot2, o usuário deve executar o comando install.packages(“ggplot2”). Feito isso, a biblioteca estará disponível na lista de bibliotecas instaladas da aba Packages do painel inferior direito. Uma vez instalada, a instalação não precisa ser refeita, exceto em caso de atualização para uma nova versão.\nNo entanto, não basta instalar a biblioteca para usufruir de suas funções. Sempre que o Rstudio for reiniciado ou sempre que uma nova seção for iniciada no Rstudio é necessário liberar a biblioteca para o uso. Isso é feito por meio do comando library() ou require() sempre posicionando entre parêntesis o nome da biblioteca desejada, dessa vez, sem aspas. Por exemplo, para liberar a biblioteca ggplot2 para o uso, proceda conforme a seguir:\n\nlibrary(ggplot2)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#operações-fundamentais-em-r",
    "href": "intro.html#operações-fundamentais-em-r",
    "title": "1  Introdução",
    "section": "1.5 Operações fundamentais em R",
    "text": "1.5 Operações fundamentais em R\n\n1.5.1 Soma\nPara efetuar uma soma, você deve utilizar o operador de adição “+”. Por exemplo, para somar \\(1 + 1\\) proceda como a seguir:\n\n1+1\n\n[1] 2\n\n\n\n\n1.5.2 Subtração\nPara efetuar uma subtração, você deve utilizar o traço simples “-” como operador de subtração. Por exemplo, para subtrair \\(1 - 1\\) proceda como a seguir:\n\n1-1\n\n[1] 0\n\n\n\n\n1.5.3 Multiplicação\nPara efetuar uma multiplicação, você deve utilizar o asterisco “*” como operador de multiplicação. Por exemplo, para somar \\(1\\) x \\(1\\) proceda como a seguir:\n\n1*1\n\n[1] 1\n\n\n\n\n1.5.4 Divisão\nPara efetuar uma divisão, você deve utilizar a barra simples “/” como operador de divisão. Por exemplo, para dividr 4 por 2, proceda como a seguir:\n\n4/2\n\n[1] 2\n\n\n\n\n1.5.5 Potência\nPara efetuar uma potenciação, você deve utilizar o circunflexo “^” ou o duplo asterisco “**” como operador de multiplicação. Por exemplo, para calcular \\(2^3\\) proceda como a seguir:\n\n2^3\n\n[1] 8\n\n\nO que também pode ser feito da seguinte maneira:\n\n2**3\n\n[1] 8\n\n\n\n\n1.5.6 Raíz quadrada\nPara efetuar uma radiciação, você deve utilizar o comando sqrt posisionando o número em prêntesis. Por exemplo, para calcular \\(\\sqrt{16}\\) proceda como a seguir:\n\nsqrt(16)\n\n[1] 4\n\n\n\n\n1.5.7 Logaritmo\nPara calcular o logaritmo de um número, você deve utilizar ocomando log10 posisionando o número em prêntesis. Por exemplo, para calcular \\(log(2)\\) proceda como a seguir:\n\nlog10(2)\n\n[1] 0.30103\n\n\n\n\n1.5.8 Logaritmo natural\nPara calcular o logaritmo natural de um número, você deve utilizar ocomando log posisionando o número em prêntesis. Por exemplo, para calcular \\(ln(2)\\) proceda como a seguir:\n\nlog(2)\n\n[1] 0.6931472\n\n\n\n\n1.5.9 Seno\nPara calcular o seno de um número, você deve utilizar ocomando sin posisionando o número em prêntesis. Por exemplo, para calcular o seno de 90 proceda como a seguir:\n\nsin(90)\n\n[1] 0.8939967\n\n\n\n\n1.5.10 Cosseno\nPara calcular o cosseno de um número, você deve utilizar ocomando cos posisionando o número em prêntesis. Por exemplo, para calcular o cosseno de 90 proceda como a seguir:\n\ncos(90)\n\n[1] -0.4480736\n\n\n\n\n1.5.11 Tangente\nPara calcular a tangente de um número, você deve utilizar ocomando tan posisionando o número em prêntesis. Por exemplo, para calcular a tangente de 90 proceda como a seguir:\n\ntan(90)\n\n[1] -1.9952\n\n\n\n\n1.5.12 Divisão inteira\nAlgumas divisões resultam em números não inteiros, de tal modo que o resultado é composto por um número inteiro aderido de um “resto”. Para calcular a divisão sem o resto você deve usar o operador %/%. Por exemplo, uma divisão inteira de cinco por dois deve resultar em dois e pode ser feita da seguinte maneira:\n\n5 %/% 2\n\n[1] 2\n\n\n\n\n1.5.13 Resto da divisão\nPorém, se o usuário estiver interessado em obter apenas o resto da divisão, pode usar o operador %%. No caso do exemplo anterior, o resto da divisão é um e pode ser obtido da seguinte maneira:\n\n5 %% 2\n\n[1] 1",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#operadores-lógicos",
    "href": "intro.html#operadores-lógicos",
    "title": "1  Introdução",
    "section": "1.6 Operadores lógicos",
    "text": "1.6 Operadores lógicos\nOs operadores lógicos são usados para comparar valores. O principal operador lógico de uma linguagem de programação é o operador de afirmação ou negação. Sempre que houver uma afirmação, a lingaugem retornará um sinal de verdadeiro (TRUE) e sempre que houver uma negação, a lingaugem retornará um sinal de falso (FALSE). Nos comandos, o TRUE pode ser substituído pelo T, enquanto o FALSE pode ser substituído pelo F. A linguagem R atribui o valor zero para as negações e o valor um para as afirmações. Assim, TRUE = 1 e FALSE = 0 sempre ocorrerá.\n\n1.6.1 Igualdade\nPara checar uma condição de igualdade, você deve usar o operador “==”. Por exemplo, para checar se dois é igual a três, você deve proceder como:\n\n2 == 3\n\n[1] FALSE\n\n\n\n\n1.6.2 Desigualdade maior que\nPara checar uma condição de desigualdade na forma de maior que, isto é, para verificar se um valor é maior que outro, você deve usar o operador “&gt;”. Por exemplo, para checar se dois é maior que três, você deve proceder como:\n\n2 &gt; 3\n\n[1] FALSE\n\n\n\n\n1.6.3 Desigualdade menor que\nPara checar uma condição de desigualdade na forma de menor que, isto é, para verificar se um valor é menor que outro, você deve usar o operador “&lt;”. Por exemplo, para checar se dois é menor que três, você deve proceder como:\n\n2 &lt; 3\n\n[1] TRUE\n\n\n\n\n1.6.4 Desigualdade maior ou igual\nPara checar uma condição de desigualdade na forma de maior ou igual a, isto é, para verificar se um valor é maior ou igual outro, você deve usar o operador “&gt;=”. Por exemplo, para checar se dois é maior ou igual a três, você deve proceder como:\n\n2 &gt;= 3\n\n[1] FALSE\n\n\n\n\n1.6.5 Desigualdade menor ou igual\nPara checar uma condição de desigualdade na forma de menor ou igual a, isto é, para verificar se um valor é menor ou igual outro, você deve usar o operador “&lt;=”. Por exemplo, para checar se dois é menor ou igual a três, você deve proceder como:\n\n2 &lt;= 3\n\n[1] TRUE\n\n\n\n\n1.6.6 Diferente de\nPara checar se um valor é diferente de outro, você deve usar o operador “!=”. Por exemplo, para checar se dois é diferente de três, você deve proceder como:\n\n2 != 3\n\n[1] TRUE\n\n\n\n\n1.6.7 Operador “e”\nMuitas vezes precisamos usar duas operações em conjunto ou até mesmo checar se duas ou mais propriedades ocorrem ao mesmo tempo. Nesse caso, o ideal é utilizar o operador “e” que baseia-se no acontecimento de duas operações simultâneas. Assim, dadas duas operações quaisquer, se as duas ocorrem ao mesmo tempo então o output será TRUE, do contrário o output será FALSE. Por exemplo, esse operador poderia ser usado caso quiséssemos verificar se 2 é menor que 3 e ao mesmo tempo diferente de 4. Em R operador “e” é dado pelo “e comercial” &.\n\n2 &lt; 3 & 2 != 4\n\n[1] TRUE\n\n\n\n\n1.6.8 Operador “ou”\nEm uma situação em que se deseja verificar se pelo menos uma operação ocorre dentre várias operações, então o ideal é utilizar o operador “ou”. Por exemplo, se temos duas operações, a operação 1 e a operação 2 e se precisamos verificar se pelo menos uma das duas operações ocorre, podemos perguntar se a operação 1 OU a operação 2 estão ocorrendo. O output será “TRUE” caso uma das operações ocorra e “FALSE” caso nenhuma das operações ocorra. Em R esse operador é dado pela barra vertical “|”. Por exemplo, suponha que queremos verificar se 2 é menor que 3 pu se 2 é maior que 5. Nesse caso, precisamos proceder conforme a seguir:\n\n2 &lt; 3 | 2 &gt; 5\n\n[1] TRUE",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#objetos",
    "href": "intro.html#objetos",
    "title": "1  Introdução",
    "section": "1.7 Objetos",
    "text": "1.7 Objetos\nAs linguagens de programação geralmente são identificadas ao objeto, isto é, é possível criar um objeto que representa algum ítem ou valor. Em R, os objetos devem ser criados om um indicativo de igualdade “=”. Por exemplo, imagine que precisamos criar um objeto com o nome “idade” contendo a idade de uma pessoa em anos. Este procedimento é feito informando o comando “nome do objeto = valor do objeto” conforme demonstrado a seguir:\n\nidade = 18\n\nAo executar esse comando, um novo objeto surgirá na aba Environment do painel 3. Esse objeto tem o nome “idade” e recebe um valor de 18. Para visualizar o valor do objeto, o usuário pode usar a função print que imprimirá no painel 2 (console) o valor referente ao objeto mencionado.\n\nprint(idade)\n\n[1] 18\n\n\nTendo feito isso, e dado que o objeto de nome idade e valor 18 está no Environment, cada vez que esse objeto for mencionado a linguagem R reconhecerá que se trata do número 18. Para exemplificar, suponha que uma pessoa é considerada idosa a partir dos 60 anos e suponha que você precise descobrir quantos anos ainda restam para que essa pessoa com idade = 18 se torne idosa. Nesse caso, você deve proceder como:\n\n60 - idade\n\n[1] 42",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#tipos-de-objetos",
    "href": "intro.html#tipos-de-objetos",
    "title": "1  Introdução",
    "section": "1.8 Tipos de objetos",
    "text": "1.8 Tipos de objetos\nOs objetos são maneiras de armazenar informações em um dado arranjo. Em R, essas informações podem ser arranjadas em funções, vetores, matrizes, listas, arrays ou quadros de dados (data frames). Cada objeto tem a sua função específica e deve ser usado conforme a necessidade. Por exemplo, uma matriz é ideal para armazenar objetos com duas dimensões (linha e coluna) mas não é adequada para agrupar objetos com três dimensões, nesse caso melhor seria usar um array ou uma lista.\n\n1.8.1 Vetores\nOs vetores são objetos que servem para guardar informações unidimensionais, isto é, informações que podem ser escritas em uma única linha ou coluna. Por exemplo, imagine que você trabalhou cinco dias em um emprego e notou em uma planilha o seu salário de cada dia. Suponha que os seus ganhos dia após dia em reais foram 50.00, 52.00, 55.00, 48.00, 60.00. Se você anotou essas informações em uma linha de uma planilha, então você tem um vetor linha. Analogamente, se as informações foram anotadas em uma coluna de uma planilha, tem-se um vetor coluna. Se você chamou essa planilha de “salario”, então isso é o mesmo que:\n\\[\nsalario = [50.00, 52.00, 55.00,48.00,60.00]\n\\]\nPara digitar esse vetor em R deve-se usar o operador de vetores c(), sempre colocando os valores dentro do parêntesis separando cada valor por uma vírgula. Lembre-se que o separador decimal da linguagem R é o ponto e que a vírgula é um separador de valores. Com isso, o vetor anterior deve ser escrito como:\n\nsalario = c(50.00, 52.00, 55.00, 48.00, 60.00)\n\nFeito isso, um objeto de nome salario irá aparecer no ambiente de trabalho. Note que o nome do objeto é sucedido do termo num [1:5], isso indica que se trata de um vetor numérico com cinco elementos. Um detalhe importante a ser mencionado é o fato de que valores não numéricos também podem ser armazenados em vetores, por exemplo:\n\nnomes = c(\"João\", \"Maria\", \"José\")\n\nNote que os valores não numéricos sempre devem estar entre aspas. Para checar se um dado objeto é um vetor, o usuário pode usar a função is.vector() indicando o nome do objeto entre parêntesis. Por exemplo, para checar se o objeto salario é um vetor, proceda conforme a seguir:\n\nis.vector(salario)\n\n[1] TRUE\n\n\nCaso o elemento de fato seja um vetor, o output obtido será TRUE, do contrário o output será FALSE. Para transformar um determinado objeto em um vetor, o usuário pode usar a função as.vector(), indicando o nome do objeto entre parêntesis. Por exemplo, para transformar uma sequência de 1 a 10 em um vetor, proceda conforme a seguir:\n\nsq = as.vector(1:10)\n\n\n\n1.8.2 Matrizes\nAs matrizes são objetos que servem para guardar informações bidimensionais, isto é, informações que podem ser escritas em um múltiplas linhas e múltiplas colunas, desde que o usuário precise realizar operações algébricas com esses valores. Para exemplificar, considere o exemplo anterior do salário. Considere agora que você trabalhou cinco dias da semana não em um mas em dois empregos. Agora você vai atribuir um diasda semana para cada linha e vai anotar os ganhos de cada emprego em colunas diferentes. Suponha agora que os ganhos do emprego 2 foram de 140.00, 160.00, 165.00, 150.00 e 155.00. Isso equivale a:\n\\[\nsalario = \\left[\n\\begin{array}{cc}\nEmprego 1 & Emprego 2\\\\ \\hline\n50.00 & 140.00\\\\\n52.00 & 160.00\\\\\n55.00 & 165.00\\\\\n48.00 & 150.00\\\\\n60.00 & 155.00 \\\\\n\\end{array}\n\\right]\n\\]\nAgora a planilha de ganhos possui dois vetores coluna de cinco elementos cada ou cinco vetores linha de dois elementos cada. Para informar essa planilha como matriz no R, o usuário deve usar a função matrix. Nessa função o usuário deve digitar os elementos da planilha linha por linha em um único vetor e indicar isso com o parâmetro by.row = TRUE. Ou se preferir o usuário pode digitar os elementos da planilha coluna por coluna em um único vetor e indicar isso com o parâmetro by.row = FALSE. O usuário também deve informar o número de linhas da matriz com o parâmetro nrow e o número de colunas com o parâmetro ncol. Para repassar a planilha anterior em R na forma de matriz, proceda conforme a seguir:\n\nsalario = matrix(\n  c(50,140,52,160,55,165,48,150,60,155),\n  byrow = TRUE,\n  ncol = 2,\n  nrow = 5\n)\n\nprint(salario)\n\n     [,1] [,2]\n[1,]   50  140\n[2,]   52  160\n[3,]   55  165\n[4,]   48  150\n[5,]   60  155\n\n\nIsso é o mesmo que fazer:\n\nsalario = matrix(\n  c(50,52,55,48,60,140,160,165,150,155),\n  byrow = FALSE, # agrupamento por coluna\n  ncol = 2,\n  nrow = 5\n)\n\nprint(salario)\n\n     [,1] [,2]\n[1,]   50  140\n[2,]   52  160\n[3,]   55  165\n[4,]   48  150\n[5,]   60  155\n\n\nPara dar nomes às linhas de uma matriz, use a função rownames(), indicando o nome da matriz entre o parêntesis e informando os nomes das linhas em um vetor. Por exemplo:\n\nrownames(salario) = c(\"Seg\", \"Ter\", \"Quar\", \"Qui\", \"Sex\")\nprint(salario)\n\n     [,1] [,2]\nSeg    50  140\nTer    52  160\nQuar   55  165\nQui    48  150\nSex    60  155\n\n\nPara dar nomes às colunas de uma matriz, use a função colnames(), indicando o nome da matriz entre o parêntesis e informando os nomes das colunas em um vetor. Por exemplo:\n\ncolnames(salario) = c(\"Emprego 1\",\"Emprego 2\")\nprint(salario)\n\n     Emprego 1 Emprego 2\nSeg         50       140\nTer         52       160\nQuar        55       165\nQui         48       150\nSex         60       155\n\n\nPara verificar se um determinado objeto é uma matriz, use a função is.matrix(), indicando o nome do objeto entre o parêntesis, por exemplo:\n\nis.matrix(salario)\n\n[1] TRUE\n\n\nCaso o elemento de fato seja uma matriz, o output obtido será TRUE, do contrário o output será FALSE. Para transformar um determinado objeto em uma matriz, o usuário pode usar a função as.matrix(), indicando o nome do objeto entre parêntesis. Por exemplo, para transformar uma sequência de 1 a 10 em uma matriz, proceda conforme a seguir:\n\nsq = as.matrix(1:10)\nprint(sq)\n\n      [,1]\n [1,]    1\n [2,]    2\n [3,]    3\n [4,]    4\n [5,]    5\n [6,]    6\n [7,]    7\n [8,]    8\n [9,]    9\n[10,]   10\n\n\n\n1.8.2.1 Operações com matrizes\n\n1.8.2.1.1 Soma de matrizes\nA soma de matrizes em R não apresenta diferenças das operações convencionais de soma, ou seja, é feita usando o operador de soma “+”. Para exemplificar, considere as dias matrizes a seguir:\n\\[ matriz1 = \\left[ \\begin{array}{cc} 0 & 2 \\\\ 3 & 1 \\end{array} \\right] \\quad \\quad \\quad \\quad matiz2 = \\left[ \\begin{array}{cc} 5 & 3\\\\7 & 0 \\end{array} \\right] \\]\nPara gerar uma nova matriz de nome matriz3 contendo a soma da matriz 1 com a matriz 2, basta proceder conforme a seguir:\n\nmatriz1 = matrix(c(0,2,3,1), nrow = 2, ncol = 2, byrow = TRUE)\nmatriz2 = matrix(c(5,3,7,0), nrow = 2, ncol = 2, byrow = TRUE)\nmatriz3 = matriz1 + matriz2\nprint(matriz3)\n\n     [,1] [,2]\n[1,]    5    5\n[2,]   10    1\n\n\n\n\n1.8.2.1.2 Subtração de matrizes\nDe maneira análoga à operação de soma, a subtração de matrizes é feita usando o operador de subtração “-”. Nesse caso, os elementos de cada posição das matries são subtraídos. Para exemplificar, considere subtrair a matriz 1 da matriz 2, procedendo de acordo com o código a seguir:\n\nmatriz3 = matriz1 - matriz2\nprint(matriz3)\n\n     [,1] [,2]\n[1,]   -5   -1\n[2,]   -4    1\n\n\nÉ importante ressaltar que a soma e a subtração de matrizes só podem ser feitas com matrizes de mesma dimensão.\n\n\n1.8.2.1.3 Multiplicação de matrizes\nNa multiplicação, não é correto utilizar o asterisco como operador de multiplicação dado que multiplicar os termos de mesma posição de duas matrizes não é a maneira correta de efetuar o produto de matrizes. Para essa tarefa, o operador de multiplicação agora é \\(\\%*\\%\\) . Para exemplificar, considere multiplicarr a matriz 1 pela matriz 2.\n\nmatriz3 = matriz1 %*% matriz2\nprint(matriz3)\n\n     [,1] [,2]\n[1,]   14    0\n[2,]   22    9\n\n\n\n\n1.8.2.1.4 Matriz transposta\nA transposta de uma matriz nada mais é do que reorganizar as linhas como colunas e as colunas como linhas. Para obter a transposta de uma matriz em R basta usar a função t(), indicando entre parêntesis o nome da matriz que se deseja transpor. Para exemplificar, considere transpor a matriz 1. Nesse caso, deve-se proceder conforme a seguir:\n\nt(matriz1)\n\n     [,1] [,2]\n[1,]    0    3\n[2,]    2    1\n\n\n\n\n1.8.2.1.5 Matriz inversa\nUma matriz \\(M\\) pode ser invertida em R para obter \\(M^{-1}\\) usando o comando solve() e indicando dentro do parêntesis a matriz que se deseja inverter. Para exemplificar, considere obter a inversa da matriz 1. Nesse caso, deve-se proceder conforme a seguir:\n\nsolve(matriz1)\n\n           [,1]      [,2]\n[1,] -0.1666667 0.3333333\n[2,]  0.5000000 0.0000000\n\n\n\n\n1.8.2.1.6 Exemplo de operações com matrizes: O estimador de mínimos quadrados ordinários\nNa estatística, os coeficientes lineares de uma equação linear com múltiplos argumentos podem ser calculados por meio do método de mínimos quadrados ordinários. Se essa equação é:\n\\[ y = \\beta_0 + \\beta_1x_1 + \\beta_2x_2 + \\dots + \\beta_n x_n \\]\nUm termo de erro \\(\\varepsilon\\) é adicionado e a relação anterior pode ser escrita matricialmente como:\n\\[ \\textbf{y} = \\textbf{x} \\beta + \\varepsilon \\]\nMininiando a soma dos erros quadráticos, o vetor \\(\\beta\\) de parâmetros estimados é:\n\\[ \\beta = (\\textbf{x}^\\prime \\textbf{x})^{-1}\\textbf{x}^\\prime \\textbf{y} \\]\nPara exemplificar, considere usar a base natova sobre automóveis mtcars e suponha que estejamos interessados em saber a relação entre o consumo do automóvel (mpg) e as variáveis peso (wt) e número de cilindros (cyl). Nesse caso, a matriz y são os valores da coluna mpg e a matriz x é composta pelas colunas wt e cyl. O vetor de parâmetros estimados pode ser calculado de acordo com o seguinte processo:\n\ny = matrix(mtcars$mpg, ncol = 1) # matriz y\nx = matrix(c(rep(1,nrow(mtcars)), mtcars$wt, mtcars$cyl), ncol = 3) # matriz x\ntx = t(x) # transposta da matriz x\nbeta = solve(tx%*%x)%*%tx%*%y\nprint(beta)\n\n          [,1]\n[1,] 39.686261\n[2,] -3.190972\n[3,] -1.507795\n\n\nIsso é o mesmo que fazer:\n\nsummary(lm(mtcars$mpg ~ 1 + mtcars$wt + mtcars$cyl))\n\n\nCall:\nlm(formula = mtcars$mpg ~ 1 + mtcars$wt + mtcars$cyl)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.2893 -1.5512 -0.4684  1.5743  6.1004 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  39.6863     1.7150  23.141  &lt; 2e-16 ***\nmtcars$wt    -3.1910     0.7569  -4.216 0.000222 ***\nmtcars$cyl   -1.5078     0.4147  -3.636 0.001064 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.568 on 29 degrees of freedom\nMultiple R-squared:  0.8302,    Adjusted R-squared:  0.8185 \nF-statistic: 70.91 on 2 and 29 DF,  p-value: 6.809e-12\n\n\n\n\n\n\n1.8.3 Arrays\nO conceito de array generaliza a idéia de matrix. Enquanto em uma matrix os elementos são organizados em duas dimensões (linhas e colunas), em um array os elementos podem ser organizados em um número arbitrário de dimensões. Em R um array é definido utilizando a função array(). O usuário deve informar dentro do parêntesis as informações sempre ordenadas coluna a coluna e indicar as dimensões do array com o parâmetro dim. Por exemplo, imagine que queiramos armazenar o consumo de dois bens por duas famílias em três anos, neste caso, teremos que criar um array de dimensão 2 x 2 x 3. Para exemplificar, imagine que esse consumo seja o demonstrado a seguir:\n\\[\n\\begin{array}{ccc}\nAno 1 = \\left[\n\\begin{array}{c|cc}\n& Bem 1 & Bem 2 \\\\ \\hline\nFamilia 1 & 0 & 5\\\\\nFamilia 2 & 2 & 3\\\\\n\\end{array}\n\\right]\n&\nAno 2 = \\left[\n\\begin{array}{c|cc}\n& Bem 1 & Bem 2 \\\\ \\hline\nFamilia 1 & 1 & 4\\\\\nFamilia 2 & 3 & 2\\\\\n\\end{array}\n\\right]\n&\\\\\nAno 3 = \\left[\n\\begin{array}{c|cc}\n& Bem 1 & Bem 2 \\\\ \\hline\nFamilia 1 & 2 & 3\\\\\nFamilia 2 & 2 & 3\\\\\n\\end{array}\n\\right]\n\\end{array}\n\\]\nEm R isso equivale a:\n\nconsumo = array(\n  c(\n    0,2,5,3, # Ano 1\n    1,3,4,2, # Ano 2\n    2,2,3,3 # ano 3\n  ),\n  dim = c(2,2,3)\n)\nprint(consumo)\n\n, , 1\n\n     [,1] [,2]\n[1,]    0    5\n[2,]    2    3\n\n, , 2\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    3    2\n\n, , 3\n\n     [,1] [,2]\n[1,]    2    3\n[2,]    2    3\n\n\nPara checar se um objeto é um array, use a função is.array(). Caso o objeto de fato seja um array, o output obtido será TRUE, do contrário o output será FALSE.\n\nis.array(consumo)\n\n[1] TRUE\n\n\n\n\n1.8.4 Listas\nAs listas são objetos ideais para guardar informações em múltiplas dimensões, isto é, informações que possuam múltiplas linhas, múltiplas colunas e múltiplas planilhas. As listas podem armazenar diversos outros objetos, incluindo outras listas. Por exemplo, uma lista pode conter um vetor e uma matriz ou múltiplos vetores e múltiplas matrizes. Para criar uma lista, o usuário deve usar a função list() indicando dentro do parêntesis os objetos que irão compor a lista. Por exemplo, vamos criar uma lista contendo os as matrizes de consumo do array anterior e vamos chamar essa lista de lista1.\n\nano1 = matrix(\n  c(0,5,2,3), byrow = TRUE, nrow = 2, ncol = 2\n)\nano2 = matrix(\n  c(1,4,3,2), byrow = TRUE, nrow = 2, ncol = 2\n)\nano3 = matrix(\n  c(2,3,2,3), byrow = TRUE, nrow = 2, ncol = 2\n)\n\nlista1 = list(ano1, ano2, ano3)\nprint(lista1)\n\n[[1]]\n     [,1] [,2]\n[1,]    0    5\n[2,]    2    3\n\n[[2]]\n     [,1] [,2]\n[1,]    1    4\n[2,]    3    2\n\n[[3]]\n     [,1] [,2]\n[1,]    2    3\n[2,]    2    3\n\n\nPara checar se um objeto é uma lista, use a função is.list(). Caso o elemento de fato seja uma lista, o output obtido será TRUE, do contrário o output será FALSE.\n\nis.list(lista1)\n\n[1] TRUE\n\n\n\n\n1.8.5 Data frames\nOs data frames - ou quadro de dados - são objetos que possuem utilidade semelhante às matrizes, isto é, são ideais para armazenar informações bidimensionais. No entanto, nos data frames não é possível realizar operações algébricas como nas matrizes. Os data frames são exatamente iguais às planilhas do excel, onde cada coluna é uma variável com valores distribuídos entre as linhas. Essa estrutura de dados é inserida em R usando a função data.frame(), de tal modo que o usuário precisa indicar o nome de cada coluna precedida pelos seus valores em um vetor. Por exemplo, se usarmos o exemplo anterior do salário de dois empregos e quisermos colocar as informações dos ganhos em um data frame de nome salario_diario, devemos proceder conforme a seguir:\n\nsalario_diario = data.frame(\n  emprego1 = c(50,52,55,48,60),\n  emprego2 = c(140,160,165,150,155)\n)\n\nprint(salario_diario)\n\n  emprego1 emprego2\n1       50      140\n2       52      160\n3       55      165\n4       48      150\n5       60      155\n\n\nVocê pode mudar os nomes das colunas dos data frames usando a função colnames(). Por exemplo, se quisermos alterar o nome das colunas para trabalho1 e trabalho2, devemos proceder conforme a seguir:\n\ncolnames(salario_diario) = c(\"trabalho1\", \"trabalho2\")\nprint(salario_diario)\n\n  trabalho1 trabalho2\n1        50       140\n2        52       160\n3        55       165\n4        48       150\n5        60       155\n\n\nJá os nomes das linhas podem ser alterados por meio da função rownames().\n\nrownames(salario_diario) = c(\"Seg\", \"Ter\", \"Quar\", \"Qui\", \"Sex\")\nprint(salario_diario)\n\n     trabalho1 trabalho2\nSeg         50       140\nTer         52       160\nQuar        55       165\nQui         48       150\nSex         60       155\n\n\nPara checar se um objeto é um data frame, o usuário deve usar a função is.data.frame() indicando o nome do objeto dentro do parêntesis. Caso o objeto de fato seja um data frame, o output obtido será TRUE, do contrário o output será FALSE.\n\nis.data.frame(salario_diario)\n\n[1] TRUE\n\n\nAssim como em uma planilha excel, as colunas dos data frames podem conter valores numéricos e não numéricos. Maiores detalhes sobre essas possibilidades de valores serão vistos posteriormente quando abordarmos as classes dos elementos.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#exercício-1",
    "href": "intro.html#exercício-1",
    "title": "1  Introdução",
    "section": "1.9 Exercício 1",
    "text": "1.9 Exercício 1\n(1) Crie um objeto de nome valor1 com a operação \\(\\left(\\frac{5^5}{100}\\right)^{0.5}\\).\n(2) Crie um objeto de nome valor2 com a operação \\(\\left(\\frac{3^8}{100}\\right)^{0.5}\\).\n(3) Cheque se \\(\\left(\\frac{5^5}{100}\\right)^{0.5} \\neq \\sqrt{\\left(\\frac{5^5}{100}\\right)}\\).\n(4) Cheque se \\(\\left(\\frac{3^8}{100}\\right)^{0.5} \\neq \\sqrt{\\left(\\frac{3^8}{100}\\right)}\\).\n(5) Verifique se \\(\\left(\\frac{5^5}{100}\\right)^{0.5}  &gt;= \\left(\\frac{3^8}{100}\\right)^{0.5}\\).\n(6) Divida valor1 por valor2 e verifique se o resultado é maior que 1.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#exercício-2",
    "href": "intro.html#exercício-2",
    "title": "1  Introdução",
    "section": "1.10 Exercício 2",
    "text": "1.10 Exercício 2\nConsidere as seguintes planilhas de dados representando os preços das ações das empresas Petrobras, Vale e Itau em uma semana de negociações na bolsa de valores:\n\\[\npetrobras = \\left[\n\\begin{array}{c|ccc}\nDia & Preco & Maximo & Minimo \\\\ \\hline\nSeg & 34.5 & 34.75 & 33.8\\\\\nTer & 34.7 & 35.05 & 34.2\\\\\nQuar & 34.9 & 35.5 & 34.6\\\\\nQui & 34.55 & 34.9 & 34.3\\\\\nSex & 34 & 34.55 & 33.6\n\\end{array}\n\\right]\n\\]\n\\[\nvale = \\left[\n\\begin{array}{c|ccc}\nDia & Preco & Maximo & Minimo \\\\ \\hline\nSeg & 55.5 & 55.75 & 55.1\\\\\nTer & 56 & 56.6 & 55.5\\\\\nQuar & 56.5 & 56.75 & 56\\\\\nQui & 55.8 & 56 & 55.2\\\\\nSex & 55.2 & 55.8 & 55\n\\end{array}\n\\right]\n\\]\n\\[\nitau = \\left[\n\\begin{array}{c|ccc}\nDia & Preco & Maximo & Minimo \\\\ \\hline\nSeg & 28.5 & 28.75 & 28.3\\\\\nTer & 28.7 & 29.05 & 28.5\\\\\nQuar & 28.9 & 29.2 & 28.7\\\\\nQui & 28.6 & 28.9 & 28.5\\\\\nSex & 28.3 & 28.6 & 28.1\n\\end{array}\n\\right]\n\\]\n\nRepasse essas três planilhas para o R na forma de matrizes, nomeando-as de petrobras, vale e itau, assim como esboçado na representação das planilhas. Dê nomes às linhas e às colunas.\n\n(2) Agora repasse as planilhas para o R na forma de data frames, nomeando-os de df_petrobras, df_vale e df_itau. Dê nomes às linhas e às colunas.\n(3) Transforme as matrizes petrobras, vale e itau em data frames, nomeando-os de df_petrobras_2, df_vale_2 e df_itau_2.\n(4) Transforme os data frames df_petrobras, df_vale e df_itau em matrizes, nomeando-as de m_petrobras, m_vale e m_itau.\n(5) Cheque se os objetos petrobras, vale e itau são matrizes.\n(6) Cheque se os objetos df_petrobras, df_vale e df_itau são data frames.\n(7) Repasse as três planilhas para o R em um array nomeando-o de preco_acoes.\n(8) Cheque se o objeto criado na questão anterior é um array.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "Aula4.html",
    "href": "Aula4.html",
    "title": "4  Condições, funções e loops",
    "section": "",
    "text": "4.1 Condições\nNa programação e na análise de dados, muitas vezes é preciso realizar tarefas repetitivas, isto é, tarefas que devem ser aplicadas várias vezes a diferentes objetos ou elementos. Essas tarefas repetitivas podem ser automatizadas usando funções ou loops. Uma função é uma regra que é aplicada a um dado objeto para obter um resultado baseado na regra. Existe um input (semelhante ao domínio de uma função matemática) pelo qual a regra é aplicada para gerar um output (semelhante à imagem de uma função matemática).\nPor sua vez, um loop nada mais é do que uma maneira de aplicar a mesma função para os elementos do domínio dessa função automaticamente sem precisar fazer isso aplicando a função para cada elemento do domínio um a um.\nTanto nas funções quanto nos loops o usuário pode aplicar condições. Essas condições refletem a lógica binária das linguagens de programação e são baseadas na ideia de “se e caso contrário”. Assim, o usuário pode aplicar uma regra indicando que a linguagem de programação retorne um determinado valor ou regra caso uma condição se verifique ou retorne um outro valor caso contrário.\nNesse capítulo vamos nos debruçar sobre esses temas e entender as principais regras e aplicações das condições, funções e loops.\nComo mencionado na seção introdutória do capítulo, as condições são baseadas numa estrutura de se e caso contrário. As condições facilitam a aplicação de regras binárias ou multicategóricas que ocorrem quando se necessita de aplicar uma regra para gerar um resultado baseado em duas possibilidades. Por exemplo, imagine que seja preciso verificar se um número é par ou ímpar. Nesse caso existem duas possibilidades (ou o número é par ou é ímpar). O input da regra é o número indicado e o output (resultado) é o tipo de número (par ou ímpar). Nesse caso, a condição aplicada seria: “Caso o número seja par, retorne uma afirmativa positiva, do contrário retorne uma negação”.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Condições, funções e loops</span>"
    ]
  },
  {
    "objectID": "Aula4.html#condições",
    "href": "Aula4.html#condições",
    "title": "4  Condições, funções e loops",
    "section": "",
    "text": "4.1.1 Condição if\nA condição if é ideal para ser aplicada quando o usuário está interessado apenas no se e não necessita do caso contrário. Por exemplo, no caso da verificação do tipo de número especificada anteriormente, se o usuário apenas quer saber se o número é par e não precisa de um resultado caso o número seja ímpar, então a condição if é ideal. Essa condição é bastante utilizada em tarefas que envolvem programação bruta como elaboração de jogos e sites dinâmicos. Porém, ela é bastante útil na análise de dados e na construção de modelos econômicos. A aplicação da condição if deve seguir a seguinte forma funcional:\n\n#if(condição){\n# resultado caso a condição seja verdadeira\n#}\n\nPara exemplificar, vamos aplicar esse procedimento para saber se o número 10 é par. Mas como saber a regra para obter o resultado nesse caso? A resposta vem da lógica de aplicação da regra e dos conhecimentos das operações básicas de programação vistas no capítulo 1. Sabe-se que os números pares têm o resto da divisão por 2 igual a zero. Assim, se o resto da divisão de 10 por 2 for zero, então 10 é um número par. Vimos no capítulo 1 que o operador de resto da divisão é %%. Assim, a verificação de que 10 é par pode ser exposta da seguinte maneira:\n\nif(10 %% 2 == 0){\n  print(\"O número é par\")\n}\n\n[1] \"O número é par\"\n\n\n\n\n4.1.2 Condição ifelse\nAo usar a condição if, o usuário busca uma resposta para um problema que envolve apenas uma condição de afirmação, isto é, “caso seja verdadeiro, me retorne essa resposta”. No entanto, na maioria das vezes também é necessário obter uma resposta para a condição de negação. No exemplo anterior, o usuário apenas quer obter uma resposta para o caso em que o resto da divisão por 2 seja nula e não está interessado no caso contrário. Contudo, caso o usuário queira uma resposta para o caso contrário, existem algumas maneiras simples de obtê-la. Uma das maneiras mais simples para especificar tanto a condição de afirmação quanto a condição de negação é usando a condição ifelse.\nCom a condição ifelse o usuário pode especificar qual resposta deve ser retornada caso a condição imposta seja verdadeira ou falsa. Essa condição deve ser expressa da seguinte maneira: ifelse(condição, resposta caso a condição seja verdadeira, resposta caso a condição seja falsa). Para exemplificar, vamos continuar com o exemplo em que queremos saber se o número 10 é par. Agora vamos declarar que caso o resto da divisão por dois não seja zero, a resposta retornada deve indicar que se trata de um número ímpar. Para isso devemos proceder conforme a seguir:\n\nifelse(10 %%2 == 0, \"O número é par\", \"O número é ímpar\")\n\n[1] \"O número é par\"\n\n\nNote que, como o resto da divisão de dez por dois é zero, a resposta obtida foi aquela indicada para o caso em que a condição é verdadeira.\n\n\n4.1.3 Condições if e else\nAs condições if e else são apropriadas para exemplos que contêm apenas uma única condição binária (se e caso contrário). Ao contrário da condição if o uso das condições if e else simultaneamente ocorrem quando o usuário de fato está interessado nos resultados tanto do se quanto do caso contrário. A sua aplicação segue a seguinte forma funcional:\n\n#if(condição){\n#resultado caso a condição seja verdadeira} else{\n#resultado caso a condição seja falsa\n#}\n\nPara exemplificar, agora vamos aplicar esse procedimento para saber se o número 10 é par ou ímpar. Note que agora estamos interessados no caso contrário, ou seja, também queremos um resultado para o caso em que 10 não seja par, indicando que apenas a condição if já não é mais suficiente para atender os padrões da regra. Agora, a aplicação da regra baseia-se na lógica de que se o resto da divisão de 10 por 2 for zero, então 10 é um número par, do contrário, 10 é um número ímpar. Assim, a verificação de que 10 é par ou ímpar pode ser exposta da seguinte maneira:\n\nif(10 %% 2 == 0){\n  print(\"O número é par\")\n}else{\n  print(\"O número é ímpar\")\n}\n\n[1] \"O número é par\"\n\n\n\n\n4.1.4 Condição else if\nExistem casos em que é preciso aplicar não apenas uma única condição de afirmação ou negação, mas sim múltiplas condições. Esses casos são específicos para problemas que envolvem múltiplas categorias. Na existência desse tipo de ocasião, o usuário pode fazer uso das condições if e else intercalando-as com subcondições de afirmação e negação. Essas subcondições são aplicadas com o uso do else if que remete à ideia de “do contrário caso ocorra”. Por exemplo, imagine que você seja um economista encarregado de classificar as pessoas de acordo com o grau de pobreza. Suponha que você pode classificar essas pessoas nas seguintes categorias:\n\nExtremamente pobre: Se possui renda menor que meio salário mínimo.\nPobre: Se possui renda maior ou igual a meio salário mínimo e menor três salários mínimos.\nNão pobre: Se possui renda maior ou igual a três salários mínimos.\n\nA condição if e else não é adequada para esse tipo de classificação pois envolvem mais de uma condição de afirmação e negação. Agora o indivíduo pode ser ou não extremamente pobre, ser ou não ser pobre e ser ou não ser não pobre. Agora é preciso usar múltiplas condições de afirmação e negação que podem ser executadas com o else if. Essa condição possui a seguinte forma funcional:\n\n# if(condição de afirmação 1){\n#   resposta caso a condição 1 seja verdadeira\n# }else if(condição de afirmação 2){\n#   resposta caso a condição 2 seja verdadeira\n# }else if (condição de afirmação 3){\n#   resposta caso a condição 3 seja verdadeira\n# }...\n# ...\n# else{\n#   resposta caso nenhuma das condições expressas seja verdadeira\n# }\n\nPara exemplificar, vamos criar um objeto de nome num_salarios e atribuir um valor qualquer representando o número de salários mensal que essa suposta pessoa ganha para testarmos a condição de pobreza da pessoa que ganha esse valor.\n\nnum_salarios = 2.5\n\nif(num_salarios &lt; 0.5){\n  print(\"Extremamente pobre\")\n}else if(num_salarios &gt;= 0.5 & num_salarios &lt; 3){\n  print(\"Pobre\")\n}else{\n  print(\"Não pobre\")\n}\n\n[1] \"Pobre\"\n\n\nNote que, como o número de salários está entre 0.5 e 3, a resposta obtida é que a pessoa deve ser classificada como pobre.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Condições, funções e loops</span>"
    ]
  },
  {
    "objectID": "Aula4.html#funções",
    "href": "Aula4.html#funções",
    "title": "4  Condições, funções e loops",
    "section": "4.2 Funções",
    "text": "4.2 Funções\nAs funções são maneiras eficientes de programar uma tarefa para obter uma resposta de acordo com uma dada regra. As funções são ideais para aplicar regras para diferentes objetos sem precisar escrever a ordem para cada objeto separadamente. Por exemplo, imagine que você precisa fazer 1000 somas de diferentes números. Você pode somar esses números um a um ou pode automatizar essa tarefa em uma função e aplicar essa função a cada número. Nesse caso, o código só é escrito uma vez em vez de 1000.\nNa programação as funções têm a mesma lógica das funções matemáticas. Existem parâmetros de entrada em que uma regra é aplicada para retornar um produto. Por exemplo, considere o caso de uma função afim na matemática:\n\\[\ny = a + bx\n\\]\nNesse caso, os parâmetros de entrada são a, b e x, ao passo que y é o produto e a regra é a soma de a com o resultado da multiplicação entre b e x. Nessa função, é preciso conhecer os valores dos parâmetros de entrada para saber o resultado da regra aplicada. Por exemplo, se \\(a=b=x=1\\), então pela regra y deve ser igual a 2 e esse valor de y muda conforme os parâmetros mudam.\nA lógica é a mesma na programação. O usuário deve informar os parâmetros de entrada e deve indicar qual a regra para que a linguagem de programação calcule o resultado dessa regra no caso em que os parâmetros de entrada tenham os valores informados.\nEm R, as funções são objetos que devem receber um nome e ficam armazenadas no ambiente de trabalho. As funções devem ser expressas com o indicativo function. Esse indicativo é sucedido de um parênteses onde são indicados os parâmetros de entrada. Após o parênteses, a regra deve ser aplicada entre chaves, mostrando qual deve ser o resultado retornado com o indicativo input, isto é:\n\n# nome da função = function(nome do parâmetro 1, nome do parâmetro 2,...nome do parâmetro n){\n#   return(regra)\n# }\n\nPor exemplo, vamos considerar o caso da função afim indicada anteriormente. Nesse caso, deve-se proceder conforme a seguir:\n\nafim = function(a, b, x){\n  y = a + b*x\n  return(y)\n}\n\nAgora, vamos considerar o caso em que a = 1, b = 1 e x=1.\n\nafim(a = 1, b = 1, x = 1)\n\n[1] 2\n\n\nA regra funcionará para quaisquer valores de \\(a, b\\) e \\(x\\). Como um segundo exemplo, vamos programar uma função para saber se um número é par com as condições propostas anteriormente:\n\npar = function(x){\n  if(x %% 2 == 0){\n    return(\"Esse número é par\")\n  }else{\n    return(\"Esse número é ímpar\")\n  }\n}\n\nAgora podemos aplicar essa função a qualquer número e não apenas ao número 10 como vinhamos fazendo. Por exemplo, vamos checar se 1515 é par ou ímpar:\n\npar(x = 1515)\n\n[1] \"Esse número é ímpar\"\n\n\n\n4.2.0.1 Exemplo: Quanto rende o seu dinheiro?\nSuponha que você queira saber quanto rende o seus investimentos na renda fixa dadas as seguintes condições:\n\nTaxa de juros dada.\nInvestimentos possíveis: CDB, RDB, Tesouro direto, LCI, LCA, CRI, CRA, poupança e debêntures.\nIOF de 30% sobre o lucro para resgate em investimentos com prazo menor que 1 mês.\nIRPF de 22.5% sobre o lucro para resgate em investimentos com prazo de até seis meses.\nIRPF de 20.5% sobre o lucro para resgate em investimentos com prazo entre seis meses e um ano.\nIRPF de 17.5% sobre o lucro para resgate em investimentos com prazo entre um ano e três anos.\nIRPF de 15% sobre o lucro para resgate em investimentos com prazo maior que três.\nIRPF de 0% sobre poupança, LCI, LCA, CRI e CRA.\n\nPara tanto, é preciso calcular o valor futuro do investimento dado o valor inicial investido. Para isso é crucial saber qual o tipo de rendimento para aplicar a regra da função. Se o rendimento é dado com juros compostos, então o valor futuro da aplicação \\((VF)\\) é:\n\\[\nVF = VI(1+i)^t\n\\]\nEm que \\(VI\\) é o valor inicial investido, \\(i\\) é a taxa nominal de juros e \\(t\\) é o tempo para o resgate do investimento. No entanto, se os juros são fixos, o valor futuro da aplicação é:\n\\[\nVF = VI(1+i*t)\n\\]\nAssim, os parâmetros de entrada serão a taxa de juros e o tempo para o resgate enquanto a regra deve estar condicionada ao tipo de rendimento. Essas duas equações mostram o valor futuro bruto sem a dedução do imposto de renda. No caso em que se deseja obter o valor futuro líquido, é preciso multiplicar o valor futuro por \\((1-IRPF)\\) e somar o resultado com o alor inicial do investimento. Uma solução para essa tarefa pode ser feita por meio da seguinte função para aplicação em uma periodicidade anual\n\ninvest = function(vi, i, t, tipo_juro, tipo_investimento){\n  # Inicialmente valos modelar o iof\n  if(t &lt; 1/12){\n    iof = 0.3\n  }else{\n    iof = 0\n  }\n  # Agora vamos modelar o irpf\n  if(tipo_investimento != \"poupança\" | tipo_investimento != \"lci\" | tipo_investimento!= \"lca\" | tipo_investimento!= \"cri\" | tipo_investimento!= \"cra\"){\n    if(t&lt;= 0.5){\n      irpf = 0.225\n    }else if(t &gt; 0.5 & t &lt;= 1){\n      irpf = 0.205\n    }else if(t &gt; 1 & t &lt;=3){\n      irpf = 0.175\n    }else{\n      irpf = 0.15\n    }\n  }else{\n    irpf = 0\n  }\n  \n  # Agora vamos modelar o valor futuro bruto e o valor futuro líquido\n  if(tipo_juro == \"composto\"){\n    vfb = vi*(1+i)^t\n    vfl = vi + (vfb - vi)*(1-irpf)\n  }else {\n    vfb = vi*(1+i*t)\n    vfl = vi + (vfb-vi)*(1-irpf)\n  }\n  \n  resultado = c(\"Valor bruto :\", vfb, \"&lt;-&gt;\", \"Valor líquido :\", vfl)\n  \n  return(resultado)\n  \n}\n\nPara testar, vamos considerar um investimento de R$ 2.500,00 em uma LCI por cinco anos a uma taxa de juros compostos de 14% ao ano:\n\ninvest(vi = 2500, i = 0.14, t = 5, tipo_juro = \"composto\", tipo_investimento = \"lci\")\n\n[1] \"Valor bruto :\"   \"4813.536456\"     \"&lt;-&gt;\"             \"Valor líquido :\"\n[5] \"4466.5059876\"   \n\n\n\n\n4.2.0.2 Exemplo: Qual o valor da parcela do meu empréstimo?\nSuponha que você deseja tomar um empréstimo mas que está em dúvida sobre qual o valor da parcela a depender da quantidade de parcelas que você escolha. Se você toma emprestado um valor \\(F\\) a uma taxa de juros \\(j\\) e deseja pagar em \\(n\\) parcelas utilizando o sistema Price de amortização, então o valor de cada parcela \\((VP)\\) é dado por:\n\\[\nVP = \\frac{F*j}{1-(1+j)^{-n}}\n\\]\nNesse caso, os parâmetros de entrada são o valor principal do empréstimo, a taxa de juros e o número de parcelas. A regra a ser aplicada na função é a relação indicada na equação de \\(VP\\) que retornará o valor de cada parcela. Portanto, vamos criar uma função e nomeá-la de valor_parcela para aplicar essa regra e conhecermos o valor de cada parcela de um financiamento.\n\nvalor_parcela = function(f, j, n){\n  vp = f*j/(1-(1+j)^(-n))\n  return(vp)\n}\n\nPara exemplificar, suponha que você precise de um empréstimo de R$ 10.000,00 e que a taxa de juros vigente seja de 1.2% ao mês. Se você quer pagar em 48 parcelas, então o valor de cada parcela será:\n\nvalor_parcela(f = 10000, j = 0.012, n = 48)\n\n[1] 275.2755",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Condições, funções e loops</span>"
    ]
  },
  {
    "objectID": "Aula4.html#loops",
    "href": "Aula4.html#loops",
    "title": "4  Condições, funções e loops",
    "section": "4.3 Loops",
    "text": "4.3 Loops\nUm loop (ou laço) é uma estrutura de controle que permite executar repetidamente um bloco de código enquanto uma condição for verdadeira ou por um número determinado de vezes. Os Loops são usados para:\n\nRepetir tarefas automaticamente (como imprimir uma lista de nomes)\nProcessar grandes volumes de dados\nEvitar repetição manual de código\n\nExistem várias possibilidades de loops, cada uma delas com as suas propriedades e as suas respectivas aplicações. Cabe ao usuário conhecer as necessidades de cada caso e as propriedades de cada loop.\n\n4.3.1 Loop for\nUm loop for é uma estrutura de repetição que executa um bloco de código um número determinado de vezes. Esse tipo de loop é ideal quando o usuário sabe previamente quantas vezes deseja repetir uma ação. Por exemplo, imagine o caso exemplificado anteriormente do valor da parcela de um financiamento. Suponha que o usuário deseja saber o valor da parcela caso ele opte por pagar desde 24 até 48 parcelas. Em vez de calcular a função para cada valor vez após vez é mais prático usar o loop do tipo for para aplicar a função criada para o conjunto que abrange os números entre 24 e 48. O loop for deve ser usado com a seguinte forma funcional:\n\n for(indexador in conjunto){\n   regra aplicada ao indexador\n }\n\nO indexador é um índice que indexa os valores do conjunto em que a regra será aplicada, de modo que o nome desse indexador deve ser informado pelo usuário. Por exemplo, vamos imprimir cada \\(i\\)-ésimo número do conjunto de números entre 1 e 5:\n\nfor(i in 1:5){\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nAgora vamos aplicar o loop for para o caso em que o usuário queira saber o valor da parcela do financiamento caso ele opte por pagar entre 24 e 48 parcelas:\n\nfor(i in 24:48){\n  print(valor_parcela(f = 10000, j = 0.012, n = i))\n}\n\n[1] 482.0207\n[1] 465.373\n[1] 450.015\n[1] 435.8033\n[1] 422.6153\n[1] 410.3448\n[1] 398.9003\n[1] 388.2017\n[1] 378.1792\n[1] 368.7712\n[1] 359.9235\n[1] 351.5881\n[1] 343.7223\n[1] 336.288\n[1] 329.2511\n[1] 322.5811\n[1] 316.2504\n[1] 310.2343\n[1] 304.5101\n[1] 299.0576\n[1] 293.8583\n[1] 288.8952\n[1] 284.1529\n[1] 279.6173\n[1] 275.2755\n\n\n\n\n4.3.2 Loop while\nO loop while é ideal para ser utilizado quando uma operação deve ser aplicada repetidas vezes até que uma dada condição ocorra. Por exemplo, imagine que você queira calcular \\(y = 2^n\\) em que \\(n\\) são os elementos do conjunto dos números naturais e uponha que você quer fazer isso até que \\(y\\) alcance o valor de 10.000. Nesse caso, enquanto \\(y &lt; 10.000\\) a regra deve ser aplicada, ao passo que quando \\(y\\) atingir o valor de 10.000 a operação é abortada. Nesse caso, o loop while é adequado para tal operação e pode ser usado mais eficientemente do que o loop for.\nA aplicação do loop while deve seguir a seguinte forma funcional:\n\n while (condição) {\n   regra\n }\n\nPor exemplo, no caso da potenciação especificada anteiormente, deve-se proceder conforme a seguir:\n\nn = 0\ny = 2^n\nwhile (y &lt; 10000) {\n  y = 2^n\n  print(n)\n  n = n +1\n}\n\n[1] 0\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n\n\nNote que foi preciso criar um objeto \\(n=0\\) e adicionar 1 ao final de cada verificação. Em alguns casos isso é um procedimento necessário.\nOBS: Um loop while pode ser infinito caso a condição seja TRUE. Nesse caso, para parar o loop é preciso executar a função break.\n\n4.3.2.1 Exemplo: Quantos bilhetes devo jogar para acertar na lotofácil\nA lotofácil é uma loteria da caixa econômica federal que consiste no sorteio de quinze números entre 1 e 25. O apostador pode fazer uma aposta mínima de quinze números ou realizar uma aposta com mais números. No concurso nº 3641, realizado no dia 05/08/2025 as dezenas sorteadas foram 02, 03, 04, 05, 06, 08, 09, 10, 11, 13, 18, 19, 21, 23, 25. Apostando 17 números, quantos sorteios aleatórios devem ser feitos para acertar pontualmente essas dezenas?\nPara responder, podemos pedir que o computador faça sorteios aleatórios até acertar exatamente esses números. Em R, sorteios aleatórios são realizados com a função sample. Assim, podemos criar um loop while e pedir que o computador não pare de fazer sorteios aleatórios até que ele acerte os números sorteados no concuros 3641 da lotofácil:\n\n# Primeiro vamos criar um vetor com as dezenas sorteadas\nsorteio = c(2, 3, 4, 5,6, 8,9, 10,11, 13,18, 19, 21,23,25)\n# Agora vamos criar o indexador do loop para contar quantos sorteios foram feitos\nn = 1\n# Agora vamos criar o loop while\nwhile (TRUE) {\n  # vamos sortear 17 números entre 1 e 25 sem possibilidade de repetição\n  aposta = sample(x = 1:25, size = 17, replace = FALSE)\n  # Agora vamos ordenar a aposta na ordem crescente\n  aposta = sort(aposta)\n  if(FALSE %in% c(sorteio %in% aposta)){\n    n = n +1\n  }else{\n    print(n)\n    break\n  }\n}\n\n[1] 41806",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Condições, funções e loops</span>"
    ]
  },
  {
    "objectID": "Aula4.html#exercício-1",
    "href": "Aula4.html#exercício-1",
    "title": "4  Condições, funções e loops",
    "section": "4.4 Exercício 1",
    "text": "4.4 Exercício 1\n(i) Tempo restante para a aposentadoria: Considere que uma pessoa pode se aposentar pelo sistema público de previdência caso obedeça as seguintes condições:\n\nIdade mínima de 65 anos e no mínimo 35 anos de contribuição caso seja do sexo masculino.\nIdade mínima de 62 anos e no mínimo 30 anos de contribuição caso seja do sexo feminino.\nIdade mínima para começar a trabalhar: 14 anos.\n\nCrie uma função para computar quanto tempo falta para a aposentadoria conforme a idade e o tempo de serviço. Ajuste a função para que a pessoa não possa informar valores irreais para o seu tempo de trabalho e de contribuição para a sua idade atual.\n(ii) Considere que um homem começou a trabalhar com 28 anos e a partir desse ponto nunca esteve desempregado. Use um while for para fazer uma contagem regressiva de quanto tempo falta para ele se aposentar conforme os anos passam. Pare o loop quando a contagem regressiva chegar a zero.\n(iii) Crie uma função para indicar se um número é primo e use um loop for para verificar quais os números inteiros entre 1 e 1000 são primos.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Condições, funções e loops</span>"
    ]
  },
  {
    "objectID": "Aula4.html#exercício-2",
    "href": "Aula4.html#exercício-2",
    "title": "4  Condições, funções e loops",
    "section": "4.5 Exercício 2",
    "text": "4.5 Exercício 2\nO código a seguir traz uma versão bastante rústica de um jogo da forca. Nesse jogo, o sistema sorteia uma dentre quatro palavras pré-definidas. O jogador tem cinco chances para acertar a palavra sorteada e deve indicar uma letra que ele julga que esteja presente na palavra em cada chance. A cada chance, se o jogador não acertar a palavra, um degrau a mais da forca é acionado. Na quinta chance, se o jogador não acertar a palavra oculta ele perde o jogo e é “enforcado”.\n\ndesenho = c(\n  \"   ===============\n    ||              I              \n    ||              \n    ||\n    ||\n    ||\n    ||              O\n    ||             /|\\\n    ||             / \\\n    ||             VIVO\n    ||\n   /  \\\n  /    \\\n  --------------------\n  \",\n  \"   ===============\n    ||              I\n    ||              I\n    ||\n    ||\n    ||\n    ||              O\n    ||             /|\\\n    ||             / \\\n    ||             VIVO\n    ||\n   /  \\\n  /    \\\n  --------------------\n  \",\n  \"   ===============\n    ||              I\n    ||              I\n    ||              I\n    ||\n    ||\n    ||              O\n    ||             /|\\\n    ||             / \\\n    ||             VIVO\n    ||\n   /  \\\n  /    \\\n  --------------------\n  \",\n  \"   ===============\n    ||              I\n    ||              I\n    ||              I\n    ||              I\n    ||\n    ||              O\n    ||             /|\\\n    ||             / \\\n    ||             VIVO\n    ||\n   /  \\\n  /    \\\n  --------------------\n  \",\n  \"   ===============\n    ||              I\n    ||              I\n    ||              I\n    ||              I\n    ||              I\n    ||              O\n    ||             /|\\\n    ||             / \\\n    ||          ENFORCADO\n    ||\n   /  \\\n  /    \\\n  --------------------\n  \n  Você perdeu a partida\n  \"\n)\n\n\npalavras = c(\"caminhonete\", \"esquisofrenia\", \"geladeira\", \"juventude\")\n\nsegredo = sample(palavras, 1)\ntracos = rep(\"__\", nchar(segredo))\nletras = c()\npalavras_chutadas = c()\n\nfor(i in 1:5){\n  print(tracos)\n  chute = readline(\"Indique uma letra: \")\n  while(chute %in% letras){\n    cat(\"Você já escolheu essa letra\")\n    chute = readline(\"Indique uma letra: \")\n  }\n  letras = rbind(letras, chute)\n  for(j in 1:nchar(segredo)){\n    if(chute == substr(segredo, j, j)){\n      tracos[j] = chute\n      print(tracos)\n    }\n  }\n  sabe = readline(\"Conhece a palavra? \")\n  if(sabe == \"sim\"){\n    resposta = readline(\"Indique qual é a palavra: \")\n    while (resposta %in% palavras_chutadas) {\n      cat(\"Você já chutou essa palavra\")\n      resposta = readline(\"Indique qual é a palavra: \")\n    }\n    palavras_chutadas = rbind(palavras_chutadas, resposta)\n    if(resposta == segredo){\n      cat(\"\\n----------------------------------------------------\\n\")\n      cat(\"------------------Resposta correta----------------------\\n\")\n      cat(\"------------------Você ganhou o jogo--------------------\\n\")\n      cat(\"\\n----------------------------------------------------\\n\")\n      break\n    }else{\n      cat(\"Resposta errada\")\n      cat(desenho[i])\n    }\n  }else{\n    cat(desenho[i])\n  }\n}\n\n(i) Analise o código e busque entender o papel dos loops e das condições no jogo. O código tem alguns erros e alguns bugs propositalmente inseridos, corrija-os caso os encontre.\n(ii) Insira mais quatro palavras no jogo e aumente o número de chances para seis.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Condições, funções e loops</span>"
    ]
  },
  {
    "objectID": "Aula5.html",
    "href": "Aula5.html",
    "title": "5  Leitura de dados",
    "section": "",
    "text": "5.1 O problema da memória\nTendo visto os fundamentos básicos da programação em R, o próximo passo é aprender a efetuar a leitura de informações para o uso posterior na linguagem. Os dados são a estrutura básica das mais variadas ferramentas interativas geradas pela programação e também consistem na ferramenta fundamental para as constatações científicas empíricas, seja na economia, seja em qualquer outra ciência.\nOs dados são armazenados em diversos tipos de arquivo, cada um deles com as suas respectivas propriedades e usuabilidade. Cada tipo de arquivo possui características que precisam ser levadas em consideração, seja na hora de elaborar uma base de dados do zero, seja na hora de ler uma base de dados pronta. Cabe ao usuário conhecer cada uma dessas propriedades e estar pronto para lidar com as particularidades dos mais variados tipos de arquivos.\nNesse capítulo, iremos conhecer as propriedades dos principais tipos de arquivos comumente utilizados para armazenar informações. Também aprenderemos sobre os principais tipos de dados e os seus possíveis usos. Por fim, serão expostas as principais técnicas que possibilitam a importação e a leitura de bases de dados previamente prontas para a linguagem R. O objetivo principal desse capítulo é repassar ao estudante o conhecimento necessário para que ele possa dominar a leitura de bases de dados em R por meio do domínio de técnicas de importação dos mais variados tipos de arquivo.\nUm dos principais desafios enfrentados na construção de bases de dados é o tamanho dos arquivos. Processar grandes bases de dados exige um grande poder computacional uma vez que, quanto maior o volume de informações, maior é a requisição de memória computacional para realizar o processamento.\nUma base de dados geralmente é composta por objetos que são formados por linhas e colunas. Cada linha e cada coluna adicionada em um objeto aumenta o seu tamanho e por consequência aumenta também a quantidade de memória computacional necessária para processar essas informações. Em vista desse problema, a engenharia de dados está em uma busca constante por soluções que permitam reduzir o tamanho dos arquivos ou a quantidade de memória necessária para processá-lo. Uma das soluções mais fáceis e rápidas para tal é escolher um tipo de arquivo adequado para armazenar as informações. Por exemplo, bases de dados com poucas linhas e poucas colunas podem facilmente ser armazenadas em um arquivo excel, pois apesar de ser uma extensão que exige mais memória, o baixo volume de informações não impedirá um usuário use essa base de dados mesmo com uma máquina com baixo poder computacional. Em contrapartida, uma máquina comum com baixa capacidade de processamento terá dificuldades para gerenciar uma base de dados com inúmeras linhas e colunas armazenadas em um arquivo desse tipo.\nEm vista desses conceitos, esse material lista a seguir as principais extensões de arquivos utilizados para armazenar informações nas bases de dados, esclarecendo as suas principais propriedades e usuabilidades, além de demosntrar as técnicas necessárias para abrir esses arquivos na linguagem R.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#arquivos-nativos-da-linguagem-r",
    "href": "Aula5.html#arquivos-nativos-da-linguagem-r",
    "title": "5  Leitura de dados",
    "section": "5.2 Arquivos nativos da linguagem R",
    "text": "5.2 Arquivos nativos da linguagem R\nA linguagem R possui duas extensões de arquivos nativas, a extensão .Rdata e a extensão .Rds. Quando o usuário possui múltiplos objetos no seu ambiente de trabalho e deseja salvar todos esses objetos em um único arquivo, então o ideal é usar a extensão .Rdata. Esse procedimento também é conhecido como “salvar objetos como imagem”. Nesse caso, o usuário pode salvar o seu ambiente de trabalho completo ou parte dele em um único arquivo que poderá ser usado posteriormente. Para demonstrar, vamos importar três bases de dados nativas para o ambiente de trabalho:\n\nbase1 = mtcars\nbase2 = CO2\nbase3 = ChickWeight\n\nImagine que seja necessário salvar todo o ambiente de trabalho com as três bases de dados incluídas nele em um único arquivo. Nesse caso, salvar como uma imagem .Rdata pode ser a melhor alternativa. Para tanto, o primeiro passo é informar à linguagem em qual pasta da sua máquina os arquivos devem ser salvos. Isso é feito indicando um diretório de trabalho por meio do comando setwd(), indicando dentro do parênteses a pasta de interesse entre aspas. Nota: no sistema Windows as barras à esquerda devem sempre ser substituídas por barras duplas na fixação do diretório de trabalho.\n\nsetwd(\"Endereço da pasta em que os arquivos serão salvos\")\n\nApós fixar o diretório de trabalho, o próximo passo é salvar o diretório de trabalho como imagem .Rdata. Para tanto, deve-se usar o comando save.image() e indicar o nome pelo qual o arquivo será salvo sucedido do indicativo do formato .Rdata. Por exemplo, imagine que queiramos salvar todo o ambiente de trabalho com o nome bases_de_dados. Nesse caso, deve-se proceder da seguinte maneira:\n\nsave.image(\"bases_de_dados.Rdata\")\n\nUma vez que o arquivo está salvo no seu diretório de trabalho com a extensão .Rdata, para importá-lo para a linguagem R basta usar o comando load() indicando no parênteses e entre aspas o nome do arquivo que será importado.\n\nload(\"bases_de_dados.Rdata\")\n\nJá a extensão .rds é aplicada quando o usuário quer salvar um único arquivo do ambiente de trabalho no diretório da sua máquina. Diferente da extensão .Rdata, na extensão .rds o salvamento dos arquivos ocorre com o comando saveRDS(), onde dentro do parênteses deve ser indicado o nome do objeto que está no ambiente de trabalho e que será salvo, sucedido do nome pelo qual o usuário deseja salvar o arquivo. Por exemplo, imagine que queiramos salvar o objeto de nome base1 com o nome base1.rds. Nesse caso, devemos proceder conforme indicado a seguir:\n\nsaveRDS(base1, file = \"base1.rds\")\n\nUma vez que o objeto está salvo com a extensão .rds na sua máquina, para importá-lo para a linguagem R basta usar o comando readRDS(), indicando no parênteses e entre aspas o nome do arquivo de interesse. Por exemplo, para ler o arquivo salvo com o nome base1.rds deve-se proceder conforme indicado a seguir:\n\nreadRDS(\"base1.rds\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#arquivos-em-formato-.csv",
    "href": "Aula5.html#arquivos-em-formato-.csv",
    "title": "5  Leitura de dados",
    "section": "5.3 Arquivos em formato .csv",
    "text": "5.3 Arquivos em formato .csv\nOs arquivos .csv geralmente são utilizados para guardar informações textuais, ou seja, são ideais para armazenar textos. Assim, um arquivo nessa extensão sempre terá uma única coluna, podendo conter, entretanto, múltiplas linhas. No entanto, esse tipo de arquivo pode ser utilizado para armazenar informações em múltiplas colunas desde que essas colunas estejam dispersas em uma única coluna comum sendo separadas por um separador. Por exemplo, considere a tabela a seguir:\n\n\n\nNome\nIdade\nSexo\n\n\n\n\nJoão\n28\nM\n\n\nMaria\n26\nF\n\n\nAna\n21\nF\n\n\n\nEm uma estrutura de texto, todas essas informações estariam unidas na mesma coluna, isto é:\n\n\n\nNomeIdadeSexo\n\n\n\n\nJoão28M\n\n\nMaria26F\n\n\nAna21F\n\n\n\nEm uma estrutura do tipo .csv todas as informações também estarão na mesma coluna, porém, o final de cada coluna pode ser identificado por um separador de colunas. Para exemplificar, suponha que no caso do exemplo anterior esse separador seja a vírgula. Nesse caso, a tabela anterior passa a ser escrita como:\n\n\n\nNome,Idade,Sexo\n\n\n\n\nJoão,28,M\n\n\nMaria,26,F\n\n\nAna,21,F\n\n\n\nComo esse separador de colunas éconhecido, então fica fácil reconhecer as informações armazenadas nesse arquivo de texto.\nEm R, a leitura de arquivos no formato .csv pode ser feita de diferentes maneiras. Uma das formas mais comuns de executar essa tarefa é por meio do uso da função read.csv que é uma função nativa e não necessita de instalação. O uso da função deve obedecer a seguinte forma funcional:\n\nread.csv(\n  \"Endereço/nome do arquivo.csv\",\n  header = TRUE, # TRUE se a primeira linha indica o nome das colunas e FALSE caso contrário\n  sep = \",\" # aqui o separador de colunas deve ser indicado entre aspas\n)\n\n\n5.3.1 Exemplo: Importando dados via link url\nPara exemplificar, considere a planilha de registros fictícios de clientes disponível no endereço https://drive.google.com/uc?id=1zO8ekHWx9U7mrbx_0Hoxxu6od7uxJqWw&export=download. A planilha possui 100 linhas, cada uma delas correspondendo às informações de um cliente específico. Caso o usuário baixe esse arquivo em sua máquina e abra esse arquivo em um editor de texto, notará que as colunas estão delimitadas por uma vírgula. Vamos importar esse arquivo no formato de um data frame nomeando-o de “clientes”.\n\nclientes = read.csv(\n  file = \"https://drive.google.com/uc?id=1zO8ekHWx9U7mrbx_0Hoxxu6od7uxJqWw&export=download\",\n  header = TRUE, # indicando que a primeira linha contém o nome das colunas\n  sep = \",\", # indicando que as colunas estão separadas por vírgula\n  dec = \".\" #indicando que o separador decimal é o ponto\n)\n\nhead(clientes) # mostra as primeiras linhas da planilha\n\nCaso esse arquivo esteja em uma pasta do seu computador em vez de um link url, etão no parâmetro file você deverá proceder como file = Endereço da pasta que contém o arquivo/nome do arquivo.csv”.\nAgora considere essa mesma planilha disponível no endereço https://drive.google.com/uc?id=1vPCLNpy6LEhHDvQlHtFBu5L2QzB5bTnv&export=download. Note que se replicarmos o script anterior alterando o endereço para esse link um erro será reportado. Isso ocorre porque nesse caso há um cabeçalho na planilha, isto é, existem linhas na parte superior da planilha que não possuem as mesmas especificações textuais do restante do csv e devem ser desconsideradas no ato da importação. Em outras palavras, as linhas do cabeçalho precisam ser “puladas”. Isso é feito por meio do parâmetro skip dentro da função read.csv. Esse parâmetro recebe a quantidade de linhas que precisam ser puladas. Como o cabeçalho desse exemplo possui duas linhas, então deve-se adicionar skip = 2 no comando, ou seja:\n\nclientes = read.csv(\n  file = \"https://drive.google.com/uc?id=1vPCLNpy6LEhHDvQlHtFBu5L2QzB5bTnv&export=download\",\n  header = TRUE, # indicando que a primeira linha contém o nome das colunas\n  sep = \",\", # indicando que as colunas estão separadas por vírgula\n  dec = \".\", #indicando que o separador decimal é o ponto\n  skip = 2 # Pula as duas primeiras linhas da planilha\n)\n\nhead(clientes) # mostra as primeiras linhas da planilha\n\nO usuário pode testar que quando skip &lt; 2, o erro será reportado mesmo assim, ao passo que quando skip &gt; 2, a importação funciona, porém, ajustes precisam ser feitos para que o nome das colunas apareça de maneira correta no data frame.\nÉ importante ressaltar que a função read.csv possui vários outros parâmetros além desses aqui especificados. O usuário pode checar as demais possibilidades de uso de parâmetros da função executando o comando ?read.csv.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#arquivos-excel-.xlsx",
    "href": "Aula5.html#arquivos-excel-.xlsx",
    "title": "5  Leitura de dados",
    "section": "5.4 Arquivos excel (.xlsx)",
    "text": "5.4 Arquivos excel (.xlsx)\nOs arquivos gerados no excel têm linhas e colunas bem definidas e por isso costumam ser maiores do que os arquivos em formato .csv. Ao contrário dos arquivos .csv que são usados para armazenar texto, os arquivos do excel podem guardar informações de diversos formatos com grande utilidade. Esses arquivos remetem à ideia central de um data frame (quadro de dados), onde as linhas representam os indivíduos observados e as colunas mostram as características desses indivíduos.\nExistem várias maneiras de importar arquivos .xlsx para a linguagem R, porém, esse material recomenda o uso da biblioteca openxlsx. Essa biblioteca foi criada especialmente para abrir arquivos com esse formato em R e as suas especificações de uso podem ser acessadas em https://cran.r-project.org/web/packages/openxlsx/openxlsx.pdf.\nComo vamos utilizar uma biblioteca não nativa, o primeiro passo para possibilitar o uso é fazer a instalação da biblioteca. O usuário pode consultar se a biblioteca já está instalada na sua máquina acessando no Rstudio a aba Packages e procurando pelo nome da biblioteca na guia de busca. Ou pode checar se a biblioteca está instalada usando o seguinte comando:\n\n\"openxlsx\" %in% installed.packages()\n\nSe o output for FALSE, significa que a biblioteca precisa ser instalada. Nesse caso, deve-se usar a função install.packages(), indicando dentro do parênteses e entre aspas o nome da biblioteca que se deseja instalar. Nesse caso, deve-se proceder conforme a seguir:\n\ninstall.packages(\"openxlsx\")\n\nTendo instalado a biblioteca, o próximo passo é liberá-la para o uso. Isso é feito por meio da função library(), indicando dentro do parênteses e entre aspas o nome da biblioteca que se deseja liberar para o uso. Nesse caso, deve-se proceder conforme a seguir:\n\nlibrary(openxlsx)\n\nPara abrir um arquivo com extensão .xlsx com a biblioteca openxlsx, deve-se usar a função read.xlsx. O usuário pode consultar as instruções de uso dessa função executando o comando ?openxlsx. Basicamente, essa função tem a seguinte estrutura de uso:\n\nread.xlsx(\n  xlsxFile = \"endereço do arquivo/nome do arquivo.xlsx\",\n  startRow = \"Número da linha em que começa a planilha\",\n  sheet = \"Número ou nome da planilha contida no arquivo\",\n  colNames = \"TRUE se a primeira linha mostra os nomes das colunas e FALSE caso contrário\"\n)\n\nPara demonstrar, considere que precisamos importar uma planilha com os valores nominais do PIB dos estados do Brasil desde 2002 até 2021 e que essa tabela está disponível no endereço https://drive.google.com/uc?id=1d9dyf5gh4GIdP2YX77b-Q0paAzar0O6b&export=download. As primeiras três linhas da planilha compõem o cabeçalho e devem ser desconsideradas, isto é, a planilha só inicia de fato na linha 4. Assim, a importação deve ser feita conforme a seguir:\n\npib = read.xlsx(\n  xlsxFile = \"https://drive.google.com/uc?id=1d9dyf5gh4GIdP2YX77b-Q0paAzar0O6b&export=download\",\n  startRow = 4,\n  colNames = TRUE,\n  sheet = 1\n)\nhead(pib)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#arquivos-excel-.xls",
    "href": "Aula5.html#arquivos-excel-.xls",
    "title": "5  Leitura de dados",
    "section": "5.5 Arquivos excel (.xls)",
    "text": "5.5 Arquivos excel (.xls)\nOs arquivos com extensão .xls são visivelmente semelhantes aos arquivos com extensão .xlsx, inclusive, com as mesmas funcionalidades. A principal diferença entre essas extensões está na estrutura computacional pela qual as duas extensões são formadas. Enquanto os arquivos .xls são criados em uma estrutura binária simples, os arquivos .xlsx. possuem uma ideia de estruturação mais sofisticada e segura baseado em XML. Em termos práticos, a extensão .xls era usada em versões antigas do pacote office, em versões iguais ou anteriores ao Excel 2003. Já a extensão .xlsx passou a ser implementada no excel a partir do office 2007.\nAssim como no caso dos arquivos .xlsx, recomenda-se o uso de uma biblioteca para a importação dos arquivos .xls para a linguagem R. Nesse caso, recomenda-se a biblioteca readxl, a qual possui suas suas especificações de uso detalhadas em https://cran.r-project.org/web/packages/readxl/readxl.pdf e instruções exemplificadas de uso em https://readxl.tidyverse.org/.\nOs passos são os mesmos indicados na biblioteca utilizada para abrir arquivos .xlsx, ou seja, deve-se verificar se a biblioteca está previamente instalada e proceder com a instalação caso não esteja. Tendo feito a instalação, deve-se liberar a biblioteca para o uso conforme especificado a seguir:\n\ninstall.packages(\"readxl\")\n\n\nlibrary(readxl)\n\nPara importar aquivos na extensão .xls, recomenda-se o uso da função read_xls(). Um detalhe importante a ser esclarecido é que no caso da biblioteca readxl, não é possível importar arquivos diretamente da url, nesse caso, é preciso baixar o arquivo na sua máquina e em seguida usar o endereço da pasta em que o arquivo foi baixado em vez da url. Outra saída é baixar o arquivo em uma pasta temporária criada pelo R e em seguida realizar a importação a partir dessa pasta, que é o que será feito aqui.\nBasicamente, a função read_xls() possui a seguinte especificação de uso:\n\nread_xls(\n  path = \"endereço/nome do arquivo.xls\",\n  sheet = \"número da planilha\",\n  col_names = \"TRUE se a primeira linha mostra os nomes das colunas e FALSE caso contrário\",\n  skip = \"número de linhas que devem ser puladas\"\n)\n\nPara exemplificar, considere a mesma planilha do PIB dos estados especificada no exemplo anterior, porém, no formato .xls, disponível no link https://drive.google.com/uc?id=141Tws9jifN8Lk4OpuyHpc9dATED9eZKC&export=download. Inicialmente, vamos criar uma pasta temporária e baixar essa planilha nessa pasta. Porém, o usuário pode baixar o arquivo em uma pasta do seu computador sem a necessidade de realização desse passo:\n\nurl &lt;- \"https://drive.google.com/uc?id=141Tws9jifN8Lk4OpuyHpc9dATED9eZKC&export=download\"\ndestfile &lt;- tempfile(fileext = \".xls\") # criando a pasta e nomeando-a de destfile\ndownload.file(url, destfile, mode = \"wb\") # baixando o xls na pasta criada\n\nTendo criado a basta e baixado o arquivo nela, o próximo passo é ler esse arquivo. Para tanto, deve-se proceder conforme a seguir:\n\npib = read_xls(\n  path = destfile,\n  skip = 3,\n  col_names = TRUE,\n  sheet = 1\n)\n\nhead(pib)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#dados-em-coluna-fixa",
    "href": "Aula5.html#dados-em-coluna-fixa",
    "title": "5  Leitura de dados",
    "section": "5.6 Dados em coluna fixa",
    "text": "5.6 Dados em coluna fixa\nO armazenamento de dados em coluna fixa geralmente é feito em um padrão textual, com uma estrutura semelhante aos arquivos .csv, porém, com o detelhe de que as colunas não estão separadas e não possuem um separador. No caso dos dados em coluna fixa, cada coluna possui um tamanho que corresponde ao número máximo de caracteres que a coluna pode agrupar. Por exemplo, supõe-se que nenhum humano pode chegar a uma idade de quatro dígitos, mas que é possível atingir uma idade de três dígitos. Assim, uma coluna contendo a idade das pessoas deverá ter um tamanho 3 que é o número máximo de caracteres possíveis de se agrupar nessa coluna.\nCada coluna também tem uma posição inicial e uma posição final que corresponde ao número de caracteres da linha onde a coluna começa e termina. Para exemplificar, considere a tabela a seguir contendo a idade e o sexo de cinco pessoas identificadas por um id:\n\n\n\nID\nIdade\nSexo\n\n\n\n\n1\n25\nM\n\n\n2\n28\nM\n\n\n3\n65\nF\n\n\n4\n75\nM\n\n\n5\n101\nF\n\n\n\nCaso esses dados sejam agrupados na estrutura de coluna fixa, eles passam a ter apenas uma coluna disposta da seguinte maneira:\n\n\n\n1025M\n\n\n2028M\n\n\n3065F\n\n\n4075M\n\n\n5101F\n\n\n\nA primeira coluna só possui um caracter, começa na posição inicial 1, termina na posição final 1 e tem tamanho 1. A segunda coluna possui 3 caracteres, começa na posição inicial 2, termina na posição final 4 e tem tamanho 3. A terceira coluna possui apenas um caracter começa na posição inicial 5, termina na posição final 5 e tem tamanho 1. Geralmente os arquivos de dados em coluna fixa dispõem de um dicionário indicando qual a posição inicial, a posição final e o tamanho das colunas.\nEsse tipo de estrutura é comumente utilizada pelo IBGE em suas pesquisas pela capacidade de armazenar mais informações em menos espaço no computador. Como exemplo, a Pesquisa Nacional Por Amostra de Domicílios Contínua (PNAD-Contínua) utiliza essa estrutura de armazenamento de dados.\nPara importar esse tipo de arquivo na forma de um data frame no R também é recomendado utilizar uma biblioteca externa. O presente material recomenda o uso da biblioteca readr. Os passos são os mesmos indicados nas bibliotecas anteriores, ou seja, deve-se verificar se a biblioteca está previamente instalada e proceder com a instalação caso não esteja. Tendo feito a instalação, deve-se liberar a biblioteca para o uso conforme especificado a seguir:\n\ninstall.packages(\"readr\")\n\n\nlibrary(readr)\n\nPara ler os arquivos em coluna fixa, recomenda-se o uso da função read_fwf(), a qual possui a seguinte esttrutura de uso:\n\nread_fwf(\n  file = \"Endereço/nome do arquivo.extensão do arquivo\",\n  fwf_cols(\n    nome da coluna = c(posição inicial, posição final)\n  )\n)\n\nPara exemplificar, vamos usar os dados da PNAD-Contínua trimestral referente ao segundo trimestre de 2024. Para tanto, defina um diretório no computador e crie uma pasta com um dado nome. Aqui, vamos nomeá-la de pnad2024. Em seguida, fixe o diretório de trabalho nessa pasta com a função setwd() conforme especificado a seguir:\n\nsetwd(\"D:/pnad2024\")\n\nEm seguida, acesse o endereço https://www.ibge.gov.br/estatisticas/downloads-estatisticas.html?caminho=Trabalho_e_Rendimento/Pesquisa_Nacional_por_Amostra_de_Domicilios_continua/Trimestral/Microdados/2024 e baixe o arquivo nomeado PNADC_022024.zip na pasta criada anteriormente. Clique com o botão direito no arquivo baixado e escolha a opçao “extrair aqui” (Obs: é preciso ter um programa de gerenciamento de arquivos compactados instalado na sua máquina).\nPara ter acesso ao dicionário indicando os detalhes sobre a posição e o tamanho das colunas, acesse o endereço https://www.ibge.gov.br/estatisticas/downloads-estatisticas.html?caminho=Trabalho_e_Rendimento/Pesquisa_Nacional_por_Amostra_de_Domicilios_continua/Trimestral/Microdados/Documentacao e baixe o arquivo de nome Dicionario_e_input_20221031.zip. Em seguida, clique com o botão direito sobre esse arquivo e escolha a opção “extrair aqui”. O dicionário é o arquivo de nome dicionario_PNADC_microdados_trimestral.xls.\nAo abrir o dicionário, o usuário irá se deparar com os detalhes técnicos da pesquisa, incluindo o nome das colunas, a descrição da coluna e o significado dos valores. A primeira coluna do dicionário a posição inicial de cada coluna enquanto a segunda coluna do dicionário mostra o tamanho. Para saber a posição inicial, basta fazer posição inicial + tamanho - 1. Por exemplo, a posição final da coluna trimestre de referência é 5 + 1 - 1 = 5.\nPara demonstrar o processo de importação, vamos importar as quatro primeiras colunas da pesquisa: Ano, Trimestre, UF e Capital. Os procedimentos estão demonstrados a seguir:\n\npnad2024 = read_fwf(\n  file = \"PNADC_022024.txt\",\n  fwf_cols(\n    Ano = c(1,4),\n    Trimestre = c(5, 5),\n    UF = c(6,7)\n  )\n)\n\n\nhead(pnad2024)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#dados-geográficos",
    "href": "Aula5.html#dados-geográficos",
    "title": "5  Leitura de dados",
    "section": "5.7 Dados geográficos",
    "text": "5.7 Dados geográficos\nDados geográficos - ou em outra notação, dados georreferenciados - são uma categoria de informações em que uma das dimensões observadas está associada a uma dada localização geográfica. Essas informações podem ser dispostas de várias maneiras, por exemplo, cada indivíduo pode estar associado a um ponto de coordenadas geográficas em um plano cartesiano, da mesma forma que em vez de um ponto específico, os indivíduos podem estar associados a um polígono ou a uma área delimitada dentro do plano cartesiano.\nOs dados georreferenciados podem ser disponibilizadas em várias extensões de arquivos a depender do tipo de informação que esses arquivos carregam. Por exemplo, dados climáticos como a temperatuda da atmosfera no decorrer do dia geralmente são armazenados em um arquivo de imagem georreferenciada com extensão .tif. No entanto, nesse material vamos direcionar os nossos esforços para dominar a importação de um tipo de arquivo, os shapefiles.\nShapefiles são tabelas de dados em que cada linha da tabela carrega uma informação correspondente a um ponto ou polígono no espaço. Por exemplo, imagine um mapa que mostra o PIB dos municípios brasileiros. Esse mapa provém de um shapefile onde cada linha representa um município que é uma polígono definido no espaço. Um shapefile geralmente depende da construção de quatro arquivos, sendo os dois principais com extensão .dbf e .shp. O arquivo com extensão .dbf carrega a planilha com as informações associadas aos indivíduos referenciados no espaço, os quais estão “desenhados” no arquivo com extensão .shp. Os demais arquivos do shapefile interligam essas duas extensões para que cada linha do .dbf seja corretamente associada a um indivíduo no arquivo .shp.\nApesas de existirem maneiras bastante simples de construir um shapefile, os economistas geralmente usam arquivos prontos que são elaborados por institutos de pesquisa ou órgãos competentes com a devida confiança. Como exemplo, o IBGE disponibiliza uma série de shapefiles em seu sistema de malhas cartográficas disponíveis aqui. O IPEA também disponibiliza um sistema semelhante que pode ser acessado clicando aqui.\n\n5.7.1 Abrindo shapefiles via sf\nUma das maneiras mais eficientes de importar shapefiles para a linguagem R é usando a biblioteca sf. Essa biblioteca disponibiliza uma série de funções bastante úteis na manipulação e no gerenciamento de dados georreferenciados. A título de recomendação, caso o usuário desse material queira se especializar em gerenciamento de dados espaciais, recomenda-se o guia elaborado por Pebesma e Bivand (2025) disponibilizado gratuitamente aqui.\nO primeiro passo para a utilização da biblioteca sf é a instalação (caso a biblioteca não esteja previamente instalada). Para tanto, deve-se proceder conforme a seguir:\n\ninstall.packages(\"sf\")\n\nTendo instalado a biblioteca, o usuário deve liberá-la para o uso, procedendo conforme a seguir:\n\nlibrary(sf)\n\nWarning: package 'sf' was built under R version 4.1.3\n\n\nLinking to GEOS 3.10.2, GDAL 3.4.1, PROJ 7.2.1; sf_use_s2() is TRUE\n\n\nEm seguida, escolha uma pasta do seu computador para baixar os arquivos shapefiles e fixe o diretório de uso para essa pasta específica usando a função setwd().\n\nsetwd(\"endereço da pasta escolhida\")\n\nPara exemplificar, vamos importar o shapefile de estados do Brasil, disponibilizado pelo IBGE e que pode ser baixado clicando aqui. Baixe o arquivo na pasta selecionada e em seguida extraia os arquivos da pasta .zip usando um gerenciador de arquivos compactados. Tendo baixado e descompactado os arquivos, busque pelo pelo arquivo com extensão .shp. Note que o arquivo é nomeado de BR_UF_2024.shp.\nPara abrir o shapefile em R usando a biblioteca sf, vamos usar a função read-sf(), indicando dentro do parênteses e entre aspas o nome do arquivo com a extensão .shp. Para tanto, vamos criar um objeto de nome estados que armazenará o shapefile importado.\n\nestados = read_sf(\"BR_UF_2024.shp\")\nhead(estados)\n\n\n\nSimple feature collection with 6 features and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -73.98681 ymin: -25.358 xmax: -28.84764 ymax: 2.632361\nGeodetic CRS:  SIRGAS 2000\n# A tibble: 6 x 8\n  CD_UF NM_UF          SIGLA_UF CD_REGIA NM_REGIA SIGLA_RG AREA_KM2\n  &lt;chr&gt; &lt;chr&gt;          &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;\n1 35    São Paulo      SP       3        Sudeste  SE        248219.\n2 15    Pará           PA       1        Norte    N        1245829.\n3 32    Espírito Santo ES       3        Sudeste  SE         46074.\n4 12    Acre           AC       1        Norte    N         164083.\n5 13    Amazonas       AM       1        Norte    N        1558706.\n6 33    Rio de Janeiro RJ       3        Sudeste  SE         43750.\n# i 1 more variable: geometry &lt;MULTIPOLYGON [°]&gt;\n\n\nEsse procedimento vai gerar um arquivo com as seguintes especificações:\n\n\n\n\n\n\n\n\n\nEstudaremos como gerar mapas a partir desses arquivos nos próximos capítulos.\n\n\n5.7.2 geobr, uma ferramenta para importar shapefiles brasileiros\ngeobr é uma biblioteca em R desenvolvida para permitir acesso rápido e fácil a um variado conjunto de shapefiles e dados espaciais brasileiros. A biblioteca possui uma série de funções que facilita a importação de shapefiles disponibilizados por fontes confiáveis. O guia de utilização da biblioteca pode ser acessado clicando aqui. Assim como a biblioteca sf, o usuário precisa efetuar a instalação (caso ainda não a tenha feito) e a liberação para o uso antes de executar qualquer uma das funções da biblioteca.\n\ninstall.packages(\"geobr\")\n\n\nlibrary(geobr)\n\nAs principais funções da biblioteca geobr que podem ser bastante úteis para um economista que trabalha com dados espaciais são:\n\nread_municipality: Importa o shapefile de municípios brasileiros.\nread_micro_region: Importa o shapefile de microrregiões do Brasil.\nread_meso_region: Importa o shapefile de mesorregiões do Brasil.\nread_state: Importa o shapefile de estados do Brasil.\nread_region: Importa o shapefile de regiões do Brasil:\nread_country: Importa o shapefile do Brasil como um todo.\n\nPara exemplificar, vamos criar um objeto de nome meso que armazenará o shapefile de mesorregiões brasileiras usando a função read_meso_region. Esse procedimento pode ser feito conforme delimitado a seguir:\n\nmeso = read_meso_region()\nhead(meso)\n\nEsse procedimento vai gerar um arquivo com as seguintes especificações:\n\n\nUsing year/date 2010",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#dados-de-outras-linguagens",
    "href": "Aula5.html#dados-de-outras-linguagens",
    "title": "5  Leitura de dados",
    "section": "5.8 Dados de outras linguagens",
    "text": "5.8 Dados de outras linguagens\nA escolha de uma linguagem de programação para uso no cotidiano é bastante particular na vida profissional do economista e envolve critérios que vão desde a identificação com os princípios da linguagem até a familiaridade com esses princípios. Por esse motivo, os economistas usam linguagens distintas que atendem as suas demandas de acordo com o seu domínio, otimizando o seu tempo de trabalho. Como consequência, alguns arquivos de dados são salvos em formatos que são particulares de uma linguagem específica. Por exemplo, economistas que usam a linguagem stata salvam seus dados em arquivos com extensão .dta, enquanto os economistas que usam matlab salvam seus dados em arquivos com extensão .mat.\nVez ou outra, um economista que usa uma linguagem de programação precisa usar arquivos salvos com extensões nativas de outras linguagens de programação. Por exemplo, é comum que os usuários da linguagem R precisem abrir arquivos gerados na linguagem stata. Como proceder nesse caso? A solução indicada nesse material é que o economista use a biblioteca foreign. Essa biblioteca possui uma série de funções que possibilitam importar para a lingagem R uma série de arquivos provenientes de outras linguagens.\nAssim como nos casos anteriores onde o uso de uma biblioteca externa foi necessário, neste caso é preciso que o usuário instale a biblioteca (caso ainda não tenha instalado) e libere-a para o uso.\n\ninstall.packages(\"foreign\")\n\n\nlibrary(foreign)\n\n\n5.8.1 Arquivos Stata (.dta)\nPara abrir arquivos com a extensão .dta é necessário usar a função read.dta(), indicando dentro do parêntesis e entre aspas o nome do arquivo que se deseja abrir. Para exemplificar, considere importar o arquivo stata disponível no link drive.google.com/uc?id=176sePIlFsqMH9mrtueX9RtHJZmZtWd-0&export=download. Nesse caso, deve-se proceder conforme a seguir:\n\ndt = read.dta(\"https://drive.google.com/uc?id=176sePIlFsqMH9mrtueX9RtHJZmZtWd-0&export=download\")\nhead(dt)\n\nCaso o arquivo estivesse presente na sua máquina em vez de um endereço url, bastaria proceder de acordo com a seguinte especificação:\n\ndt = read.dta(\"Endereço da pasta onde o arquivo está armazenado/nome do arquivo.dta\")\n\nAbaixo segue uma lista de funções com o mesmo layout de uso para importar arquivos de outras linguagens.\n\nread.dbf: Ideal para importar arquivos do libre office calc salvos na extensão .dbf.\nread.octave: Ideal para importar arquivos do Matlab e Octave salvos na extensão .mat.\nread.spss: Ideal para importar arquivos do SPSS salvos na extensão .sav.\nread.ssd: Ideal para importar arquivos do SAS salvos na extensão .sas7bdat.\n\nAlém de importar os arquivos, também é possível salvar os arquivos presentes no ambiente de trabalho em uma extensão Stata. Por exemplo, para salvar o data frame mtcars na extensão .dta, use a função write.dta, procedendo conforme a seguir:\n\nwrite.dta(mtcars, file = \"mtcars.dta\")\n\nO arquivo mtcars.dta será salvo na pasta em que o diretório de trabalho está fixado. No geral, a funçãos write.dta segue as seguintes especificações de uso:\n\nwrite.dta(nome do data frame no diretório de trabalho, file = \"Endereço da pasta/nome do arquivo salvo.dta\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#exercício",
    "href": "Aula5.html#exercício",
    "title": "5  Leitura de dados",
    "section": "5.9 Exercício",
    "text": "5.9 Exercício\n(i) O IBGE calcula anualmente as estimativas de população para cada município brasileiro. Para o ano de 2024, essas informações podem ser acessadas no formato .csv no seguinte endereço https://sidra.ibge.gov.br/geratabela?format=br.csv&name=tabela6579.csv&terr=NC&rank=-&query=t/6579/n6/all/v/all/p/2024/l/v,p,t. Leia corretamente essa tabela com a linguagem R usando a função read.csv().\n(ii) A mesma tabela da questão anterior está disponível no formato .xlsx no endereço https://sidra.ibge.gov.br/geratabela?format=xlsx&name=tabela6579.xlsx&terr=NC&rank=-&query=t/6579/n6/all/v/all/p/2024/l/v,p,t. Leia corretamente essa tabela com a linguagem R usando a função read.xlsx() da biblioteca openxlsx.\n(iii) Usando a biblioteca geobr, importe para a linguagem R.\n\nO shapefile de municípios brasileiros.\nO shapefile de estados brasileiros.\nO shapefile de microrregiões do Brasil.\nO shapefile de mesorregiões do Brasil.\n\n(iv) Leia atentamente o material desse capítulo e use a biblioteca readr para importar todas as colunas da PNAD-Contínua do segundo trimestre de 2024.\n(v) Desafio: Acesse o repositório de dados eleitorais do TSE e busque pelo conjunto de dados de resultados das eleições. Busque pelos resultados das eleições de 2020 e navegue até o endereço https://dadosabertos.tse.jus.br/dataset/resultados-2020. Nesse endereço estão dispostos as votações nominais por município e zona eleitoral de cada estado brasileiro referente ao ano de 2020. As informações estão dispostas por estado de modo que cada estado está em uma pasta zip. Dentro dessa pasta há um arquivo na extensão .csv contendo os dados desejados. Siga os seguintes passos para ler os arquivos:\n\nCrie uma pasta temporária com a função tempfile.\nElabore um loop for para automatizar as importações de dados pelo endereço url dos arquivos .zip.\nDentro do loop, baixe as pastas zip com a função download.file.\nUse a função unz para descompartar o csv e a função read.csv para ler os arquivos de cada estado.\nEmpilhe tudo em um único data frame.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  }
]