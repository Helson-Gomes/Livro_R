[
  {
    "objectID": "aula2.html",
    "href": "aula2.html",
    "title": "2  Indexação e operações indexadas",
    "section": "",
    "text": "2.1 Indexação de objetos\nNesse módulo estão expressos os detalhes básicos acerca de operações fundamentais com diferentes tipos de objetos. O módulo ainda apresenta os conceitos e as normas básicas sobre posições de elementos em um objeto (indexação) e também mostra as operações que usam essa indexação e que podem ser úteis na análise de dados.\nOs objetos são compostos por elementos e esses elementos ocupam uma posição dentro do objeto. Por exemplo, imagine um vetor \\(x = [Maria, Paulo, Pedro, Ana]\\). Esse vetor é composto por quatro elementos, maria na posição 1, Paulo na posição 2, Pedro na posição 3 e Ana na posição 4. Agora considere que essas mesmas informações estejam dispostas em uma matriz.\n\\[\\left[\\begin{array}{cc}\nMaria & Paulo\\\\ Pedro & Ana \\end{array}\n\\right]\n\\]\nAgora a posição deve ser visualizada como “linha por coluna”. Maria está na linha 1 e coluna 1 (posição [1, 1]), Paulo está na linha 1 e coluna 2 (posição [1, 2]), Pedro está na linha 2 e coluna 1 (posição [2, 1]) e Ana está na linha 2 e coluna 2 (posição [2, 2]). A essa posição dá-se o nome de indexação. A indexação nada mais é do que a posição de um elemento em um conjunto, que nesse caso são os objetos no ambiente de trabalho.\nPara verificar qual elemento está em uma determinada posição do objeto, deve-se informar o nome do objeto precedido da posição entre colchetes, isto é, nome do objeto[posição na linha, posição na coluna]. Por exemplo, na matriz anterior, caso queiramos consultar quem está na linha 1 da coluna 1, devemos proceder conforme a seguir:\nnomes = matrix(c(\"Maria\", \"Paulo\", \"Pedro\", \"Ana\"), byrow = TRUE, nrow = 2, ncol = 2)\nnomes[1,1]\n\n[1] \"Maria\"\nA lógica é a mesma em um data frame,\ndf = data.frame(\n  coluna1 = c(\"Maria\", \"Pedro\"),\n  coluna2 = c(\"Paulo\", \"Ana\")\n)\ndf[1,1]\n\n[1] \"Maria\"\nSe quisermos nos referir apenas às linhas, então a posição da coluna deve ficar vazia, isto é, nome do objeto[posição na linha,]. Seguindo o exemplo anterior, caso queiramos checar quem está na linha 1 da matriz, devemos proceder conforme a seguir:\nnomes[1,]\n\n[1] \"Maria\" \"Paulo\"\nA mesma lógica se aplica aos data frames.\ndf[1,]\n\n  coluna1 coluna2\n1   Maria   Paulo\nSe quisermos nos referir apenas às colunas, então a posição da linha deve ficar vazia, isto é, nome do objeto[, posição na coluna]. Seguindo o exemplo anterior, caso queiramos checar quem está na coluna 1 da matriz, devemos proceder conforme a seguir:\nnomes[,1]\n\n[1] \"Maria\" \"Pedro\"\nA mesma lógica se aplica aos data frames.\ndf[,1]\n\n[1] \"Maria\" \"Pedro\"\nA posição das linhas e colunas também pode ser referenciada de acordo com os nomes. Nesse caso, o procedimento é nome do objeto[“nome da linha”, “nome da coluna”]. Para exemplificar, vamos dar nomes às linhas e as colunas da matriz e do data frame usados nos exemplos anteriores.\nrownames(nomes) = c(\"linha 1\", \"linha 2\")\ncolnames(nomes) = c(\"coluna 1\", \"coluna 2\")\nprint(nomes)\n\n        coluna 1 coluna 2\nlinha 1 \"Maria\"  \"Paulo\" \nlinha 2 \"Pedro\"  \"Ana\"\nrownames(df) = c(\"linha 1\", \"linha 2\")\nprint(nomes)\n\n        coluna 1 coluna 2\nlinha 1 \"Maria\"  \"Paulo\" \nlinha 2 \"Pedro\"  \"Ana\"\nPara checar quem está na linha 1, proceda conforme a seguir:\nnomes[\"linha 1\",]\n\ncoluna 1 coluna 2 \n \"Maria\"  \"Paulo\"\nE no data frame:\ndf[\"linha 1\", ]\n\n        coluna1 coluna2\nlinha 1   Maria   Paulo\nPara checar quem está na coluna 1, proceda conforme a seguir:\nnomes[, \"coluna 1\"]\n\nlinha 1 linha 2 \n\"Maria\" \"Pedro\"\nE no data frame:\ndf[, \"coluna1\"]\n\n[1] \"Maria\" \"Pedro\"\nNos data frames, a indexação das colunas pode ser mais simplificada devido a possibilidade de referenciar as colunas plo nome usando o cifrão “$”. Nesse caso, o procedimento a se fazer é nome do objeto$nome da coluna. Por exemplo, para se referir a coluna 1 do data frame anterior, deve-se proceder conforme a seguir:\ndf$coluna1\n\n[1] \"Maria\" \"Pedro\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#adicionando-linhas-a-um-data-frame",
    "href": "aula2.html#adicionando-linhas-a-um-data-frame",
    "title": "2  Indexação e operações indexadas",
    "section": "2.2 Adicionando linhas a um data frame",
    "text": "2.2 Adicionando linhas a um data frame\nTendo comopreendido como funciona a indexação, o próximo passo é aprender como essa indexação pode ser usada para adicionar, excluir ou alterar elementos de um objeto. Caso a intenção seja adicionar uma linha em um data frame, então o procedimento a se fazer é nome do objeto[número de linhas do objeto + 1,]. Para exemplificar, vamos incluir uma linha na data frame de nomes contendo os valores [João, Clara]. Esse procedimento deve ser feito conforme especificado a seguir:\n\ndf[3,] = c(\"João\", \"Clara\")\nprint(df)\n\n        coluna1 coluna2\nlinha 1   Maria   Paulo\nlinha 2   Pedro     Ana\n3          João   Clara",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#adicionando-linhas-em-uma-matriz",
    "href": "aula2.html#adicionando-linhas-em-uma-matriz",
    "title": "2  Indexação e operações indexadas",
    "section": "2.3 Adicionando linhas em uma matriz",
    "text": "2.3 Adicionando linhas em uma matriz\nPara adicionar linhas em uma matriz é preciso usar a função rbind(). Essa função também funciona perfeitamente para data frames. Nesse caso, o procedimento a se fazer é rbind(nome do objeto, vetor com os valores da linha adicionada). Por exemplo, para adicionar uma linha com os valores [João, Clara] no data frame de nomes, deve-se proceder conforme a seguir:\n\nnomes = rbind(nomes, c(\"João\", \"Clara\"))\nprint(nomes)\n\n        coluna 1 coluna 2\nlinha 1 \"Maria\"  \"Paulo\" \nlinha 2 \"Pedro\"  \"Ana\"   \n        \"João\"   \"Clara\" \n\n\nA mesma lógica se aplica aos data frames:\n\nrbind(df, c(\"João\", \"Clara\"))\n\n        coluna1 coluna2\nlinha 1   Maria   Paulo\nlinha 2   Pedro     Ana\n3          João   Clara\n4          João   Clara",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#removendo-linhas-de-um-objeto",
    "href": "aula2.html#removendo-linhas-de-um-objeto",
    "title": "2  Indexação e operações indexadas",
    "section": "2.4 Removendo linhas de um objeto",
    "text": "2.4 Removendo linhas de um objeto\nA remoção de linhas de um objeto é feita adicionando um sinal de menos antes do número da linha indicado em colchetes. Por exemplo, caso queiramos remover a linha 3 da matriz de nomes, devemos proceder conforme a seguir:\n\nnomes[-3,]\n\n        coluna 1 coluna 2\nlinha 1 \"Maria\"  \"Paulo\" \nlinha 2 \"Pedro\"  \"Ana\"   \n\n\nA mesma lógica se aplica aos data frames:\n\ndf[-3,]\n\n        coluna1 coluna2\nlinha 1   Maria   Paulo\nlinha 2   Pedro     Ana\n\n\nCaso a intenção seja remover múltiplas linhas, então o número das linhas que serão removidas deve ser indicado em um vetor precedido do sinal de menos dentro do colchetes. Por exemplo, caso queiramos remover as linhas 2 e 3 da matriz de nomes, devemos proceder conforme a seguir:\n\nnomes[-c(2,3),]\n\ncoluna 1 coluna 2 \n \"Maria\"  \"Paulo\" \n\n\nA mesma lógica se aplica aos data frames:\n\ndf[-c(2,3),]\n\n        coluna1 coluna2\nlinha 1   Maria   Paulo",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#adicionando-colunas-em-um-data-frame",
    "href": "aula2.html#adicionando-colunas-em-um-data-frame",
    "title": "2  Indexação e operações indexadas",
    "section": "2.5 Adicionando colunas em um data frame",
    "text": "2.5 Adicionando colunas em um data frame\nExistem várias maneiras de adicionar colunas em um data frame. O usuário pode indicar a posição da coluna entre colchetes e em seguida indicar os valores, pode indicar o nome da coluna em colchetes e em seguida indicar os valores, pode usar o sifrão para indicar o nome da coluna criada, …\nPara exemplificar, suponha que queiramos adicionar uma coluna com os valores *[pessoa 1, pessoa 2, pessoa 3] no dtaframe df. Essa tarefa pode ser feita das seguintes maneiras:\n\nIndicando a posição em colchetes\n\n\ndf[,3] = c(\"pessoa 1\", \"pessoa 2\", \"pessoa 3\")\nprint(df)\n\n        coluna1 coluna2       V3\nlinha 1   Maria   Paulo pessoa 1\nlinha 2   Pedro     Ana pessoa 2\n3          João   Clara pessoa 3\n\n\n\nIndicando o nome da coluna no colchetes.\n\n\ndf[, \"coluna3\"] = c(\"pessoa 1\", \"pessoa 2\", \"pessoa 3\")\nprint(df)\n\n        coluna1 coluna2  coluna3\nlinha 1   Maria   Paulo pessoa 1\nlinha 2   Pedro     Ana pessoa 2\n3          João   Clara pessoa 3\n\n\n\ndf=df[,-3]\n\n\nUsando o cifrão.\n\n\ndf$coluna3 = c(\"pessoa 1\", \"pessoa 2\", \"pessoa 3\")\nprint(df)\n\n        coluna1 coluna2  coluna3\nlinha 1   Maria   Paulo pessoa 1\nlinha 2   Pedro     Ana pessoa 2\n3          João   Clara pessoa 3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#adicionando-colunas-em-uma-matriz",
    "href": "aula2.html#adicionando-colunas-em-uma-matriz",
    "title": "2  Indexação e operações indexadas",
    "section": "2.6 Adicionando colunas em uma matriz",
    "text": "2.6 Adicionando colunas em uma matriz\nPara adicionar colunas em uma matriz é preciso usar a função cbind(). Essa função tem a mesma lógica de uso da função rbind() apresentada anteriormente, com a diferença de que a função cbind() posiciona os novos elementos em uma coluna em vez de uma linha. Para exemplificar, vamos adicionar a mesma coluna incluída no data frame df na matriz de nomes.\n\nnomes = cbind(nomes, c(\"pessoa 1\", \"pessoa 2\", \"pessoa 3\"))\nprint(nomes)\n\n        coluna 1 coluna 2           \nlinha 1 \"Maria\"  \"Paulo\"  \"pessoa 1\"\nlinha 2 \"Pedro\"  \"Ana\"    \"pessoa 2\"\n        \"João\"   \"Clara\"  \"pessoa 3\"\n\n\nA mesma lógica pode ser aplicada aos data frames fazendo df = cbind(df, c(“pessoa 1”, “pessoa 2”, “pessoa 3”)).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#renomeando-colunas-e-linhas-específicas",
    "href": "aula2.html#renomeando-colunas-e-linhas-específicas",
    "title": "2  Indexação e operações indexadas",
    "section": "2.7 Renomeando colunas e linhas específicas",
    "text": "2.7 Renomeando colunas e linhas específicas\nComo visto no capítulo anterior, a função colnames() pode ser usada para renomear colunas de uma matriz ou data frame. Porém, caso o objetivo seja renomear uma única coluna específica é possível usar a indexação para realizar essa tarefa. Por exemplo, considere renomear apenas a coluna 3 do data frame de nomes atribuindo a essa coluna o nome “coluna3”.\n\ncolnames(nomes)[3] = \"Coluna3\"\nprint(nomes)\n\n        coluna 1 coluna 2 Coluna3   \nlinha 1 \"Maria\"  \"Paulo\"  \"pessoa 1\"\nlinha 2 \"Pedro\"  \"Ana\"    \"pessoa 2\"\n        \"João\"   \"Clara\"  \"pessoa 3\"\n\n\nO mesmo pode ser feito para as linhas. Por exemplo, caso queiramos renomear apenas a linha 3 do data frame de nomes, podemos proceder conforme a seguir:\n\nrownames(nomes)[3] = \"linha 3\"\nprint(nomes)\n\n        coluna 1 coluna 2 Coluna3   \nlinha 1 \"Maria\"  \"Paulo\"  \"pessoa 1\"\nlinha 2 \"Pedro\"  \"Ana\"    \"pessoa 2\"\nlinha 3 \"João\"   \"Clara\"  \"pessoa 3\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#operações-com-colunas",
    "href": "aula2.html#operações-com-colunas",
    "title": "2  Indexação e operações indexadas",
    "section": "2.8 Operações com colunas",
    "text": "2.8 Operações com colunas\nEm um data frame novas colunas podem ser geradas por meio de operações com colunas existentes. Para exemplificar, considere um dataframe com informações sobre medidas de alunos de uma academia.\n\nalunos = data.frame(\nnome = c(\"Aluno 1\", \"Aluno 2\", \"Aluno 3\"),\npeso = c(65, 70, 90),\naltura = c(1.60, 1.70, 1.78)\n)\nprint(alunos)\n\n     nome peso altura\n1 Aluno 1   65   1.60\n2 Aluno 2   70   1.70\n3 Aluno 3   90   1.78\n\n\nImagine que seja necessário adicionar nesse data frame uma nova coluna com o índice de massa corporal dos alunos (IMC). Sabe-se que:\n\\[\nIMC = \\frac{Peso}{Altura^2}\n\\]\nA nova coluna pode ser adicionada indexando a sua posição:\n\nalunos[,4] = alunos[,2]/(alunos[,3]^2)\nprint(alunos)\n\n     nome peso altura       V4\n1 Aluno 1   65   1.60 25.39062\n2 Aluno 2   70   1.70 24.22145\n3 Aluno 3   90   1.78 28.40550\n\n\nIndexando o nome da coluna:\n\nalunos[\"imc\"] = alunos[\"peso\"]/(alunos[\"altura\"]^2)\nprint(alunos)\n\n     nome peso altura      imc\n1 Aluno 1   65   1.60 25.39062\n2 Aluno 2   70   1.70 24.22145\n3 Aluno 3   90   1.78 28.40550\n\n\nOu utilizando o cifrão:\n\nalunos$imc = alunos$peso/(alunos$altura^2)\nprint(alunos)\n\n     nome peso altura      imc\n1 Aluno 1   65   1.60 25.39062\n2 Aluno 2   70   1.70 24.22145\n3 Aluno 3   90   1.78 28.40550\n\n\n\n2.8.1 Criando uma nova coluna como recorte de uma coluna existente\nImagine o caso em que seja preciso criar uma coluna como um recorte de valores de uma coluna existente em um data frame. Falando com outras palavras, imagine que seja preciso adicionar uma coluna contendo uma parte dos valores contidos em outra coluna. Por exemplo, no data frame de alunos da academia, imagine que seja preciso mostrar apenas o número do aluno em uma nova coluna, isto é, em vez de mostrar o termo “Aluno 1” suponha que seja preciso mostrar apenas o número “1”.\nEsse procedimento pode ser feito usando a função substr. Essa função é nativa da linguagem R e serve para desmembrar valores de acordo com a posição dos caracteres desses valores. Exemplificando, o termo “Aluno 1” tem sete caracteres que correspondem a seis letras, um espaço e um número. O número ocupa a sétima posição no termo. Na função substr temos que indicar a posição inicial e a posição final do conjunto de caracteres que queremos desmembrar do valor objetivo. A maneira correta de usar essa função é fazendo substr(nome do elemento, posição inicial, posição final). Por exemplo, se fizermos substr(“Aluno 1”, 1, 2) o resultado será “Al” que corresponde aos dois primeiros caracteres do termo utilizado.\nNo nosso exemplo como o número do aluno inicia e termina na sétima posição, então o correto a se fazer é:\n\nalunos$num_aluno = substr(alunos$nome, 7, 7)\nprint(alunos)\n\n     nome peso altura      imc num_aluno\n1 Aluno 1   65   1.60 25.39062         1\n2 Aluno 2   70   1.70 24.22145         2\n3 Aluno 3   90   1.78 28.40550         3\n\n\n\n\n2.8.2 Mesclando colunas\nEm vez de separar valores de uma coluna, imagine o caso em que seja preciso juntar valores. Em R isso pode ser facilmente feito usando a função paste(). Essa função junta múltiplos valores separando-os com um searador indicado pelo usuário. Para usar a função, basta indicar entre parênteses os valores que serão unificados e indicar o separador com o parâmetro “sep”. Por exemplo:\n\nnome = \"João\"\nsobrenome = \"Silva\"\nnome_completo = paste(nome, sobrenome, sep = \" \")\nprint(nome_completo)\n\n[1] \"João Silva\"\n\n\nEssa função pode ser usada para unir colunas. Para exemploficar, considere o novo data frame com as características dos alunos de uma academia indicado a seguir:\n\nalunos2 = alunos\nalunos2$nome = c(\"João\", \"Maria\", \"João\")\n\nE imagine que seja preciso criar um código do aluno, unindo o nome e o número do aluno separando o nome e um número por um traço. Esse procedimento pode ser feito conforme indicado a seguir:\n\nalunos2$cod_aluno = paste(alunos2$nome, alunos2$num_aluno, sep = \"-\")\nprint(alunos2)\n\n   nome peso altura      imc num_aluno cod_aluno\n1  João   65   1.60 25.39062         1    João-1\n2 Maria   70   1.70 24.22145         2   Maria-2\n3  João   90   1.78 28.40550         3    João-3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#reposicionando-linhas-e-colunas",
    "href": "aula2.html#reposicionando-linhas-e-colunas",
    "title": "2  Indexação e operações indexadas",
    "section": "2.9 Reposicionando linhas e colunas",
    "text": "2.9 Reposicionando linhas e colunas\nConhecendo a posição de cada linha e cada coluna, é possível reordená-las de acordo com as necessidades ou preferências do usuário usando operações indexadas. Por exemplo, suponha que seja preciso reordenar as linhas do data frame de alunos para posicionar o aluno 3 na primeira linha, o aluno 2 na segunda linha e o aluno 1 na terceira linha. Esse procedimento pode ser feito conforme a seguir:\n\nalunos = alunos[c(3,2,1),]\nprint(alunos)\n\n     nome peso altura      imc num_aluno\n3 Aluno 3   90   1.78 28.40550         3\n2 Aluno 2   70   1.70 24.22145         2\n1 Aluno 1   65   1.60 25.39062         1\n\n\nAgora suponha que seja necessário posicionar o nome do aluno na primeira coluna, a altura na segunda coluna, o peso na terceira coluna e o imc na última coluna, isto é, suponha que seja preciso inverter a posição do peso e da altura no data frame. Esse procedimento pode ser feito conforme indicado a seguir:\n\nalunos = alunos[, c(1,3,2,4)]\nprint(alunos)\n\n     nome altura peso      imc\n3 Aluno 3   1.78   90 28.40550\n2 Aluno 2   1.70   70 24.22145\n1 Aluno 1   1.60   65 25.39062",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#operações-básicas",
    "href": "aula2.html#operações-básicas",
    "title": "2  Indexação e operações indexadas",
    "section": "2.10 Operações básicas",
    "text": "2.10 Operações básicas\nNovas linhas e colunas podem ser adicionadas em um data frame usando operações básicas como soma, produto, ou estatísticas básicas. Para demonstrar, considere um data frame contendo a idade de cinco pessoas conforme a seguir:\n\ndf = data.frame(\n  pessoa = c(\"pessoa1\", \"pessoa2\", \"pessoa3\", \"pessoa4\", \"pessoa\"),\n  idade = c(25, 50, 68,45,NA)\n)\nprint(df)\n\n   pessoa idade\n1 pessoa1    25\n2 pessoa2    50\n3 pessoa3    68\n4 pessoa4    45\n5  pessoa    NA\n\n\nNote que há um valor faltante, indicado pelo termo NA que representa a sigla do “não disponível” (do inglês not available). Qualquer operação contendo essa coluna deve indicar que esse valor ausente deve ser ignorado. Isso pode ser feito adicionando a opção na.rm = TRUE.\n\n2.10.1 Soma total\nSuponha que queiramos encontrar o somatório da idade de todas as pessoas contidas no data frame. Isso pode ser facilmente executado usando a função sum(), conforme indicado a seguir:\n\nsum(df$idade, na.rm = TRUE)\n\n[1] 188\n\n\n\n\n2.10.2 Produto total\nCaso o objetivo seja encontrar o produto de todos os valores de uma dada coluna, então o ideal é usar a função prod(), conforme demonstrado a seguir:\n\nprod(df$idade, na.rm = TRUE)\n\n[1] 3825000\n\n\n\n\n2.10.3 Média\nJá a média pode ser obtida com a função mean(), conforme demonstrado a seguir:\n\nmean(df$idade, na.rm = TRUE)\n\n[1] 47\n\n\n\n\n2.10.4 Mínimo\nO valor mínimo de um dado objeto pode ser computado por meio da função min(), conforme demonstrado a seguir:\n\nmin(df$idade, na.rm = TRUE)\n\n[1] 25\n\n\n\n\n2.10.5 Máximo\nO valor máximo de um dado objeto pode ser computado por meio da função max(), conforme demonstrado a seguir:\n\nmax(df$idade, na.rm = TRUE)\n\n[1] 68\n\n\n\n\n2.10.6 Desvio padrão\nO desvio padrão de um dado objeto pode ser computado por meio da função sd(), conforme demonstrado a seguir:\n\nsd(df$idade, na.rm = TRUE)\n\n[1] 17.68238\n\n\n\n\n2.10.7 Número de observações\nO número de observações - ou comprimento - de um dado objeto pode ser verificado com o uso da função length(), conforme demonstrado a seguir:\n\nlength(df$idade)\n\n[1] 5\n\n\nNote que nesse caso é preciso despresar a omissão dos valores NA.\n\n\n2.10.8 Exemplo: Criando uma tabela de estatísticas descritivas\nUma tabela de estatísticas descritivas mostra o perfil básico de um banco de dados e geralmente expressa o número de observações, o valor médio, o desvio padrão, o valor máximo e o valor mínimo de cada variável. Para representar, considere usar o banco de dados nativo do R sobre características das flores (iris). Esse banco de dados possui cinco colunas (Sepal.Length, Sepal.Width, Petal.Length, Petal.Width, Species) que mostram o comprimento e a largura da pétala e da sépala de cada espécie de flor. Elaborar uma tabela de estatísticas descritivas dessa base de dados seria o mesmo que preencher a seguinte tabela:\n\n\n\n\n\n\n\n\n\n\n\n\nObservações\nMédia\nDesvio Padrão\nMínimo\nMáximo\n\n\n\n\nSepal.Length\n\n\n\n\n\n\n\nSepal.Width\n\n\n\n\n\n\n\nPetal.Length\n\n\n\n\n\n\n\nPetal.Width\n\n\n\n\n\n\n\n\nPara esse propósito, vamos usar a indexação aos nomes das linhas e colunas e vamos usar as estatísticas básicas mostradas anteriormente. O primeiro passo para tal é criar um data frame vazio com os mesmos padrões da tabela anterior:\n\nest_desc = data.frame(\n  Observacoes = c(rep(NA, 4)),\n  Media = c(rep(NA, 4)),\n  Desvio_Padrao = c(rep(NA, 4)),\n  Minimo = c(rep(NA, 4)),\n  Maximo  = c(rep(NA, 4))\n)\nrownames(est_desc) = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", 'Petal.Width')\nprint(est_desc)\n\n             Observacoes Media Desvio_Padrao Minimo Maximo\nSepal.Length          NA    NA            NA     NA     NA\nSepal.Width           NA    NA            NA     NA     NA\nPetal.Length          NA    NA            NA     NA     NA\nPetal.Width           NA    NA            NA     NA     NA\n\n\nO próximo passo é preencher cada célula do data frame com as estatísticas correspondentes. Inicialmente, vamos preencher a coluna referente ao número de observações:\n\nest_desc[\"Sepal.Length\", \"Observacoes\"] = length(iris$Sepal.Length)\nest_desc[\"Sepal.Width\", \"Observacoes\"] = length(iris$Sepal.Width)\nest_desc[\"Petal.Length\", \"Observacoes\"] = length(iris$Petal.Length)\nest_desc[\"Petal.Width\", \"Observacoes\"] = length(iris$Petal.Width)\n\nAgora vamos preencher a coluna da média:\n\nest_desc[\"Sepal.Length\", \"Media\"] = mean(iris$Sepal.Length)\nest_desc[\"Sepal.Width\", \"Media\"] = mean(iris$Sepal.Width)\nest_desc[\"Petal.Length\", \"Media\"] = mean(iris$Petal.Length)\nest_desc[\"Petal.Width\", \"Media\"] = mean(iris$Petal.Width)\n\nAgora vamos preencher a coluna do desvio padrão:\n\nest_desc[\"Sepal.Length\", \"Desvio_Padrao\"] = sd(iris$Sepal.Length)\nest_desc[\"Sepal.Width\", \"Desvio_Padrao\"] = sd(iris$Sepal.Width)\nest_desc[\"Petal.Length\", \"Desvio_Padrao\"] = sd(iris$Petal.Length)\nest_desc[\"Petal.Width\", \"Desvio_Padrao\"] = sd(iris$Petal.Width)\n\nAgora vamos fazer o mesmo para a coluna do valor mínimo:\n\nest_desc[\"Sepal.Length\", \"Minimo\"] = min(iris$Sepal.Length)\nest_desc[\"Sepal.Width\", \"Minimo\"] = min(iris$Sepal.Width)\nest_desc[\"Petal.Length\", \"Minimo\"] = min(iris$Petal.Length)\nest_desc[\"Petal.Width\", \"Minimo\"] = min(iris$Petal.Width)\n\nPor fim, vamos preencher a coluna do valor máximo:\n\nest_desc[\"Sepal.Length\", \"Maximo\"] = max(iris$Sepal.Length)\nest_desc[\"Sepal.Width\", \"Maximo\"] = max(iris$Sepal.Width)\nest_desc[\"Petal.Length\", \"Maximo\"] = max(iris$Petal.Length)\nest_desc[\"Petal.Width\", \"Maximo\"] = max(iris$Petal.Width)\n\nO resultado desse procedimento é o data frame a seguir:\n\nprint(est_desc, digits = 4)\n\n             Observacoes Media Desvio_Padrao Minimo Maximo\nSepal.Length         150 5.843        0.8281    4.3    7.9\nSepal.Width          150 3.057        0.4359    2.0    4.4\nPetal.Length         150 3.758        1.7653    1.0    6.9\nPetal.Width          150 1.199        0.7622    0.1    2.5\n\n\nExistem maneiras mais rápidas e mais eficientes de preparar uma tabela de estatísticas descritivas, porém, isso exige artifícios que só serão vistos em capítulos posteriores.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula2.html#exercício",
    "href": "aula2.html#exercício",
    "title": "2  Indexação e operações indexadas",
    "section": "2.11 Exercício",
    "text": "2.11 Exercício\nConsidere usar a base de dados nativa sobre carros mtcars.\n\ndf = mtcars\n\n(1) Remova o carro Fiat X1-9.\n(2) Usando o nome das linhas e das colunas, encontre o consumo (mpg) do Toyota Corolla.\n(3) Crie uma nova coluna de nome difCorolla mostrando a diferença entre o consumo médio de cada carro e o consumo médio do Toyota Corolla.\n(4) Crie uma nova coluna de nome consumo_peso mostrando o consumo (mpg) dos carros para cada tonelada de peso (wt).\n(5) Apague os carros de câmbio manual (carros com am = 0).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Indexação e operações indexadas</span>"
    ]
  },
  {
    "objectID": "aula3.html",
    "href": "aula3.html",
    "title": "3  Classes de elementos",
    "section": "",
    "text": "3.1 Elementos textuais: (strings)\nOs elementos textuais sempre devem ser declarados entre aspas, sejam aspas simples ou duplas, do contrário, a linguagem R não reconhecerá esse elemento como texto. A linguagem R não suporta operações matemáticas com elementos textuais, ao contrário de outras linguagens como Python onde operações matemáticas básicas podem ser aplicadas a esses elementos.\nImagine que seja necessário criar um data frame com o nome dos estados e os nomes das capitais da região Sul do Brasil. Nesse caso, os elemento são textuais e cada nome de estado e capital deve ser informado entre aspas conforme demonstrado a seguir:\nsul = data.frame(\n  estados = c(\"Paraná\", \"Santa Cararina\", \"Rio Grande do Sul\"),\n  capital = c(\"Curitiba\", \"Florianópolis\", \"Porto Alegre\")\n)\nprint(\"Sul\")\n\n[1] \"Sul\"\nCaso os elementos não sejam declarados entre aspas, a execução do comando retornará um erro.\nÉ possível checar qual a classe de um dado elemento ou de um dado objeto por meio do comando class(), informando o nome do objeto entre parêntesis. Por exemplo, é possível checar se o objeto criado anteriormente com o nome sul é um data frame, um vetor, um array, etc.\nclass(sul)\n\n[1] \"data.frame\"\nO comando class() também pode ser usado para verificar se um objeto possui ou não uma classe textual. Caso se trate de um objeto textual, então o comando class() retornará o output “character”, indicando que se trata de um caracter. Por exemplo, vamos verificar a classe da coluna de nome estados do objeto de nome sul:\nclass(sul$estados)\n\n[1] \"character\"\nElementos númericos ou outros tipos de elementos muitas vezes podem ser reconhecidos, declarados ou transformados em caracteres. Nesse caso, cabe ao usuário saber identificar a classe dos elementos e transformá-lo na classe desejada. Para exemplificar, considere incluir no data frame anterior o código de unidade federativa do ibge:\nsul$codigo_uf = c(41, 42, 43)\nprint(sul)\n\n            estados       capital codigo_uf\n1            Paraná      Curitiba        41\n2    Santa Cararina Florianópolis        42\n3 Rio Grande do Sul  Porto Alegre        43\nNote que os números não estão em aspas, indicando que não são caracteres. Abrindo o data frame, o usuário verá facilmente que as duas primeiras colunas estão com os valores alinhados à esquerda, enquanto a última coluna está alinhada à direita. Nesse caso, apenas visualizando esse alinhamento é possível afirmar que as duas primeiras colunas têm elementos textuais. No entanto, o usuário pode checar se as colunas são de fato strings usando o comando is.character(), indicando o nome do objeto ou elemento no parênteses. Por exemplo, para checar se o código do estado é um elemento textual, proceda conforme a seguir:\nis.character(sul$codigo_uf)\n\n[1] FALSE\nNote que o output foi FALSE, indicando que não se trata de um elemento textual. Caso o usuário precise dessa coluna como um elemento de texto, então ele pode usar o comando as.character(), indicando o nome do objeto ou elemento no parênteses. Nesse caso, o objeto ou elemento indicado será transformado forçadamente em um elemento textual. Para exemplificar, vamos transformar o código do estado em um caracter:\nsul$codigo_uf = as.character(sul$codigo_uf)\nChecando agora a classe da coluna, nota-se que se trata de um elemento textual:\nclass(sul$codigo_uf)\n\n[1] \"character\"\nExistem operações no âmbito da análise de dados que são usadas com esse tipo de elemento. Por exemplo, as análises de sentimento baseiam-se fundamentalmente em coletas de dados de texto. Um exemplo factível é a mensuração da sensibilidade do mercado financeiro em relação a intensidade do texto da ata do banco central. Esse procedimento é feito pela contagem de palavras pré-definidas na ata. Para esse tipo de operação existem bibliotecas que auxiliam o usuário e que serão vistas posteriormente quando estivermos abordando operações com strings.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "aula3.html#elementos-numéricos",
    "href": "aula3.html#elementos-numéricos",
    "title": "3  Classes de elementos",
    "section": "3.2 Elementos numéricos",
    "text": "3.2 Elementos numéricos\nOs elementos numéricos são todos os elementos representados na forma de números, sejam eles de quaisquer um dos conjuntos numéricos. Por exemplo, 2 é um elemento numérico do conjunto dos naturais inteiros, ao passo que 2.5 é um elemento numérico do conjunto dos números racionais. É possível checar se um elemento é numérico usando o comando class(), no entanto, é mais adequado usar o is.numeric(), indicando o nome do elemento em parênteses. Para exemplificar, vamos checar se a coluna codigo_uf do data frame de nome sul é numérico.\n\nis.numeric(sul$codigo_uf)\n\n[1] FALSE\n\n\nNote que o resultado é FALSE, indicando que não se trata de um elemento numérico. Caso o usuário precise transformar essa coluna em um elemento numérico, então ele pode usar o comando as.numeric(), indicando o nome do elemento em parêntesis:\n\nsul$codigo_uf = as.numeric(sul$codigo_uf)\n\nAgora podemos verificar novamente se a coluna é ou não numérica.\n\nis.numeric(sul$codigo_uf)\n\n[1] TRUE\n\n\nEm um data frame, as colunas numéricas sempre estarão alinhadas à direita e o usuário pode checar a classe dessa coluna posicionando o cursor sobre o seu nome no data frame.\nExiste, contudo, um problema associado ao uso do comando as.numeric(), dado que a transformação de um elemento não numérico para um elemento numérico só funciona perfeitamente caso o objeto não numérico seja composto por números declarados como caracteres, como é o caso da coluna codigo_uf. Do contrário, o resultado pode ser composto por NAs. Para exemplificar, vamos tentar transformar o nome dos estados em um objeto numérico:\n\nas.numeric(sul$estados)\n\nWarning: NAs introduzidos por coerção\n\n\n[1] NA NA NA\n\n\nPor esse motivo, antes de efetuar qualquer operação com um elemento numérico, é fundamental checar a sua classe para garantir que o resultado esteja de acordo com o esperado. Por exemplo, imagine o caso em que seja preciso calcular o pib per capita de um estado, sendo que o pib seja numérico e a população seja um caracter. Nesse caso, se o usuário não conhece a classe da população e não a transforma em um elemento numérico, o cálculo do pib per capita será feito dividindo um número por uma palavra, o que é algo inviável, resultando em um elemento do tipo NA.\n\n3.2.1 Subclasses dos numéricos: inteiros (integer)\nComo mencionado anteriormente, os elementos numéricos podem estar contidos em quaisquer um dos conjuntos numéricos. Uma subclasse bastante comum na economia são é a subclasse dos inteiros. Essa subclasse abriga os números inteiros positivos ou negativos e se caracteriza por abrigar um L após o número. Por exemplo, 10 é um elemento da classe numérica, mas 10L é um elemento da subclasse dos inteiros pertencente à classe dos numéricos.\nPara checar se um elemento é inteiro, use o comando is.integer(), indicando o elemento no parêntesis. Por exemplo, vamos checar se 10 é inteiro:\n\nis.integer(10)\n\n[1] FALSE\n\n\nNote que o resultado é FALSE, indicando que 10 não é inteiro. Isso ocore porque os números inteiros devem obrigatoriamente ser sucedidos da letra L. Informando corretamente tem-se:\n\nis.integer(10L)\n\n[1] TRUE\n\n\nPara transformar um elemento numérico na subclasse dos inteiros, basta usar a função as.integer(), informando o elemento no parênteses. Por exemplo, vamos transformar o código do estado no data frame de nome sul em inteiro.\n\nsul$codigo_uf = as.integer(sul$codigo_uf)\nprint(sul)\n\n            estados       capital codigo_uf\n1            Paraná      Curitiba        41\n2    Santa Cararina Florianópolis        42\n3 Rio Grande do Sul  Porto Alegre        43\n\n\nNote que visivelmente não há mudanças nas propriedades da coluna modificada, porém agora quando consultarmos se essa coluna pertence ao conjunto dos inteiros, o output é verdadeiro:\n\nis.integer(sul$codigo_uf)\n\n[1] TRUE\n\n\n\n\n3.2.2 Subclasses dos numéricos: racionais (doubles)\nOs números racionais são declarados como doubles na linguagem R. Esse conjunto abriga também os inteiros e os naturais, isto é, um inteiro sempre será um double, assim como um natural sempre será um double. Para checar se um número pertence a essa categoria, use a função is.double(), indicando o elemento de interesse no parênteses.\n\nis.double(10.5555)\n\n[1] TRUE\n\n\nDe maneira análoga, um elemento numérico declarado como texto pode ser trannsformado em racional usando a função as.double(), indicando o elemento de interesse no parênteses.\n\nas.double(\"10.5\")\n\n[1] 10.5\n\n\nEm alguns casos, os números racionais possuem múltiplas casas decimais e é preciso reduzir essas casas decimais arredondando a última casa. Isso pode ser facilmente resolvido usando a função round(), que possui o seguinte modo de uso: round(nome do objeto ou elemento, número de casas decimais). Por exemeplo, imagine que queiramos reduzir o número 5.56413 para apenas uma casa decimal. Nesse caso, devemos proceder conforme a seguir:\n\nround(5.564132, 1)\n\n[1] 5.6",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "aula3.html#elementos-lógicos-true-e-false",
    "href": "aula3.html#elementos-lógicos-true-e-false",
    "title": "3  Classes de elementos",
    "section": "3.3 Elementos lógicos: (TRUE e FALSE)",
    "text": "3.3 Elementos lógicos: (TRUE e FALSE)\nOs elementos lógicos podem assumir dois valores, verdadeiro (TRUE) ou falso (FALSE). Sempre que o elemento lógico for verdadeiro, o R atribui valor 1 a este elemento, ao passo que sempre que o elemento lógico for falso, o R atribui valor 0 a este elemento. Assim, é possível aplicar operações matemáticas aos elementos pertencentes a essa classe. Isso advém da premissa de que as linguagens de programação são baseados em sistemas binários de afirmação e negação comentada no capítulo 1.\nEssa classe de elementos é bastante utilizada na economia para representar variáveis binárias onde a categoria de interesse recebe o valor unitário. Por exemplo, imagine uma pesquisa com foco no diferencial de salário por sexo. Nesse tipo de pesquisa é ideal saber se o indivíduo é homem ou mulher. Se a categoria de interesse for o sexo masculino, então os homens recebem valor TRUE e as mulheres recebem vaor FALSE. Isso equivale a atribuir 1 para os homens e 0 para as mulheres.\nPara verificar se um elemento pertence a essa categoria, use a função is.logical(), indicando o nome do elemento entre o parênteses. Para exemplificar, vamos criar uma nova coluna no data frame de estados da regiao sul com o nome parana que identifica se o estado em questão é ou não o estado do Paraná.\n\nsul$parana = c(1,0,0)\nprint(sul)\n\n            estados       capital codigo_uf parana\n1            Paraná      Curitiba        41      1\n2    Santa Cararina Florianópolis        42      0\n3 Rio Grande do Sul  Porto Alegre        43      0\n\n\nAgora vamos checar se essa coluna é um elemento lógico.\n\nis.logical(sul$parana)\n\n[1] FALSE\n\n\nNote que o output é FALSE, indicando que não se trata de um elemento lógico, o que é esperado dado que se trata de um elemento numérico. Para transformar essa coluna em um elemento lógico, basta usar a função as.logical(), indicando o nome do elemento de interesse no parênteses.\n\nsul$parana = as.logical(sul$parana)\nprint(sul)\n\n            estados       capital codigo_uf parana\n1            Paraná      Curitiba        41   TRUE\n2    Santa Cararina Florianópolis        42  FALSE\n3 Rio Grande do Sul  Porto Alegre        43  FALSE\n\n\nAgora vamos checar novamente se essa coluna é um elemento lógico.\n\nis.logical(sul$parana)\n\n[1] TRUE\n\n\nNote que o output é TRUE, indicando que se trata de um elemento lógico.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "aula3.html#valores-multicategóricos-fatores-factors",
    "href": "aula3.html#valores-multicategóricos-fatores-factors",
    "title": "3  Classes de elementos",
    "section": "3.4 Valores multicategóricos: Fatores (factors)",
    "text": "3.4 Valores multicategóricos: Fatores (factors)\nOs factors são elementos usados para representar valores multicategóricos. Por exemplo, imagine uma variável que expressa a situação do empregado no mercado de trabalho. Ele pode estar (1) apenas trabalhando, (2) apenas estudando, (3) trabalhando e estudando, (4) nem trabalhando nem estudando porém procurando emprego, ou (5) nem trabalhando nem estudando nem procurando emprego. Note que são cinco possibilidades que agora não podem ser representadas pelos elementos lógicos.\nPara declarar um elemento multicategórico é necessário usar o comando factor() que tem a seguinte forma de uso: factor(x = elemento, levels = níveis das categorias). Para exemplificar, vamos criar um objeto de nome emprego com as possibilidades indicadas no parágrafo anterior e os seus respectivos valores.\n\nemprego = factor(\n  x = c(\n    \"apenas trabalhando\", \n    \"apenas estudando\", \n    \"trabalhando e estudando\", \n    \"nem trabalhando nem estudando porém procurando emprego\",\n    \"nem trabalhando nem estudando nem procurando emprego\"\n  ),\n  levels = c(\n    \"apenas trabalhando\", \n    \"apenas estudando\", \n    \"trabalhando e estudando\", \n    \"nem trabalhando nem estudando porém procurando emprego\",\n    \"nem trabalhando nem estudando nem procurando emprego\"\n  )\n)\n\nprint(emprego)\n\n[1] apenas trabalhando                                    \n[2] apenas estudando                                      \n[3] trabalhando e estudando                               \n[4] nem trabalhando nem estudando porém procurando emprego\n[5] nem trabalhando nem estudando nem procurando emprego  \n5 Levels: apenas trabalhando apenas estudando ... nem trabalhando nem estudando nem procurando emprego\n\n\nSerá atribuído valor 1 para a primeira categoria indicada no vetor de níveis (levels), 2 para a segunda categoria e assim sucessivamente.\nPara checar se um elemento é multicategórico, devs-se usar a função is.factor(), indicando o nome do elemento no parênteses.\n\nis.factor(emprego)\n\n[1] TRUE",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "aula3.html#exercício-1",
    "href": "aula3.html#exercício-1",
    "title": "3  Classes de elementos",
    "section": "3.5 Exercício 1",
    "text": "3.5 Exercício 1\nConsidere o seguinte data frame:\n\nset.seed(10)\ndados = data.frame(\n  pessoa = 1:30,\n  idade = sample(8:85,30, replace = T),\n  sexo = sample(c(\"M\", \"F\"), 30, replace = T),\n  estado_civil = sample(c(\"Solteiro\", \"Casado\", \"Viúvo\", \"Divorciado\"), 30, replace = T),\n  salario = rnorm(30, mean = 1200, sd = 300)\n)\n\n(1) Crie uma variável de nome sexo2 transformando a variável sexo em um elemento lógico atribuindo o valor unitário para as mulheres.\n(2) Crie uma variável de nome fase_vida atribuindo os nomes infância para as pessoas com menos de 12 anos, adolescência para as pessoas com idade entre 12 e 18 anos, adulta para as pessoas com idade entre 18 e 65 anos e velhice para as pessoas com mais de 65 anos.\n(3) Crie uma nova variável de nome fase_vida2 transformando a variável fase_vida em um factor ordenando as categorias de acordo com a fase da vida em ordem crescente.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "aula3.html#exercício-2",
    "href": "aula3.html#exercício-2",
    "title": "3  Classes de elementos",
    "section": "3.6 Exercício 2",
    "text": "3.6 Exercício 2\nConsidere a base de dados sobre carros mtcars:\n\ncarros = mtcars\n\n(1) Crie uma coluna de nome automatico transformando a coluna am em um elemento lógico.\n(2) Transforme a coluna cyl em um factor onde o atributo x recebe os valores “4 cilindros”, “6 cilindore” e “8 cilindros” ordenados na forma crescente.\n(3) Crie uma nova coluna de nome carro contendo o nome dos carros indicados nos nomes das linhas do data frame.\n(4) Verifique a casse da coluna criada na questão.\n(5) Verifique se a coluna criada nas questões 1 e 2 são factors.\n(6) Verifique se a coluna mpg é inteiro e caso não seja transforme-a em inteiro.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "Aula3.html",
    "href": "Aula3.html",
    "title": "3  Classes de elementos",
    "section": "",
    "text": "3.1 Elementos textuais: (strings)\nOs dados podem assumir diversos formatos, por exemplo, números, textos, imagens, etc. A depender da ocasião, o usuário precisará lidar com um tipo de dado específico. Por exemplo, um economista prevendo preços no mercado de ações utilizará objetos numéricos para representar o preço dos ativos. Um técnico em radiologia coleta informações em imagem de um paciente. Um especialista em análise de sentimento em redes sociais coleta os textos das postagens para extrair delas informações úteis. Cada tipo de informação tem uma utilidade e um propósito e cada tipo de informação possui propriedades que o analista de dados precisa conhecer.\nUm objeto criado possui múltiplos elementos e esses elementos podem ser de diferentes tipos. Esses “tipos” de elementos recebem o nome de classe. Existem operações que são aplicadas adequadamente a uma classe de elementos específica, por exemplo, é possível somar dois elementos numéricos mas é estranho pensar em somar duas palavras. Nesse capítulo vamos conhecer as principais classes de dados, suas características e as principais operações que podem ser realizadas com cada classe.\nOs elementos textuais sempre devem ser declarados entre aspas, sejam aspas simples ou duplas, do contrário, a linguagem R não reconhecerá esse elemento como texto. A linguagem R não suporta operações matemáticas com elementos textuais, ao contrário de outras linguagens como Python onde operações matemáticas básicas podem ser aplicadas a esses elementos.\nImagine que seja necessário criar um data frame com o nome dos estados e os nomes das capitais da região Sul do Brasil. Nesse caso, os elemento são textuais e cada nome de estado e capital deve ser informado entre aspas conforme demonstrado a seguir:\nsul = data.frame(\n  estados = c(\"Paraná\", \"Santa Cararina\", \"Rio Grande do Sul\"),\n  capital = c(\"Curitiba\", \"Florianópolis\", \"Porto Alegre\")\n)\nprint(\"Sul\")\n\n[1] \"Sul\"\nCaso os elementos não sejam declarados entre aspas, a execução do comando retornará um erro.\nÉ possível checar qual a classe de um dado elemento ou de um dado objeto por meio do comando class(), informando o nome do objeto entre parêntesis. Por exemplo, é possível checar se o objeto criado anteriormente com o nome sul é um data frame, um vetor, um array, etc.\nclass(sul)\n\n[1] \"data.frame\"\nO comando class() também pode ser usado para verificar se um objeto possui ou não uma classe textual. Caso se trate de um objeto textual, então o comando class() retornará o output “character”, indicando que se trata de um caracter. Por exemplo, vamos verificar a classe da coluna de nome estados do objeto de nome sul:\nclass(sul$estados)\n\n[1] \"character\"\nElementos númericos ou outros tipos de elementos muitas vezes podem ser reconhecidos, declarados ou transformados em caracteres. Nesse caso, cabe ao usuário saber identificar a classe dos elementos e transformá-lo na classe desejada. Para exemplificar, considere incluir no data frame anterior o código de unidade federativa do ibge:\nsul$codigo_uf = c(41, 42, 43)\nprint(sul)\n\n            estados       capital codigo_uf\n1            Paraná      Curitiba        41\n2    Santa Cararina Florianópolis        42\n3 Rio Grande do Sul  Porto Alegre        43\nNote que os números não estão em aspas, indicando que não são caracteres. Abrindo o data frame, o usuário verá facilmente que as duas primeiras colunas estão com os valores alinhados à esquerda, enquanto a última coluna está alinhada à direita. Nesse caso, apenas visualizando esse alinhamento é possível afirmar que as duas primeiras colunas têm elementos textuais. No entanto, o usuário pode checar se as colunas são de fato strings usando o comando is.character(), indicando o nome do objeto ou elemento no parênteses. Por exemplo, para checar se o código do estado é um elemento textual, proceda conforme a seguir:\nis.character(sul$codigo_uf)\n\n[1] FALSE\nNote que o output foi FALSE, indicando que não se trata de um elemento textual. Caso o usuário precise dessa coluna como um elemento de texto, então ele pode usar o comando as.character(), indicando o nome do objeto ou elemento no parênteses. Nesse caso, o objeto ou elemento indicado será transformado forçadamente em um elemento textual. Para exemplificar, vamos transformar o código do estado em um caracter:\nsul$codigo_uf = as.character(sul$codigo_uf)\nChecando agora a classe da coluna, nota-se que se trata de um elemento textual:\nclass(sul$codigo_uf)\n\n[1] \"character\"\nExistem operações no âmbito da análise de dados que são usadas com esse tipo de elemento. Por exemplo, as análises de sentimento baseiam-se fundamentalmente em coletas de dados de texto. Um exemplo factível é a mensuração da sensibilidade do mercado financeiro em relação a intensidade do texto da ata do banco central. Esse procedimento é feito pela contagem de palavras pré-definidas na ata. Para esse tipo de operação existem bibliotecas que auxiliam o usuário e que serão vistas posteriormente quando estivermos abordando operações com strings.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "Aula3.html#elementos-numéricos",
    "href": "Aula3.html#elementos-numéricos",
    "title": "3  Classes de elementos",
    "section": "3.2 Elementos numéricos",
    "text": "3.2 Elementos numéricos\nOs elementos numéricos são todos os elementos representados na forma de números, sejam eles de quaisquer um dos conjuntos numéricos. Por exemplo, 2 é um elemento numérico do conjunto dos naturais inteiros, ao passo que 2.5 é um elemento numérico do conjunto dos números racionais. É possível checar se um elemento é numérico usando o comando class(), no entanto, é mais adequado usar o is.numeric(), indicando o nome do elemento em parênteses. Para exemplificar, vamos checar se a coluna codigo_uf do data frame de nome sul é numérico.\n\nis.numeric(sul$codigo_uf)\n\n[1] FALSE\n\n\nNote que o resultado é FALSE, indicando que não se trata de um elemento numérico. Caso o usuário precise transformar essa coluna em um elemento numérico, então ele pode usar o comando as.numeric(), indicando o nome do elemento em parêntesis:\n\nsul$codigo_uf = as.numeric(sul$codigo_uf)\n\nAgora podemos verificar novamente se a coluna é ou não numérica.\n\nis.numeric(sul$codigo_uf)\n\n[1] TRUE\n\n\nEm um data frame, as colunas numéricas sempre estarão alinhadas à direita e o usuário pode checar a classe dessa coluna posicionando o cursor sobre o seu nome no data frame.\nExiste, contudo, um problema associado ao uso do comando as.numeric(), dado que a transformação de um elemento não numérico para um elemento numérico só funciona perfeitamente caso o objeto não numérico seja composto por números declarados como caracteres, como é o caso da coluna codigo_uf. Do contrário, o resultado pode ser composto por NAs. Para exemplificar, vamos tentar transformar o nome dos estados em um objeto numérico:\n\nas.numeric(sul$estados)\n\nWarning: NAs introduzidos por coerção\n\n\n[1] NA NA NA\n\n\nPor esse motivo, antes de efetuar qualquer operação com um elemento numérico, é fundamental checar a sua classe para garantir que o resultado esteja de acordo com o esperado. Por exemplo, imagine o caso em que seja preciso calcular o pib per capita de um estado, sendo que o pib seja numérico e a população seja um caracter. Nesse caso, se o usuário não conhece a classe da população e não a transforma em um elemento numérico, o cálculo do pib per capita será feito dividindo um número por uma palavra, o que é algo inviável, resultando em um elemento do tipo NA.\n\n3.2.1 Subclasses dos numéricos: inteiros (integer)\nComo mencionado anteriormente, os elementos numéricos podem estar contidos em quaisquer um dos conjuntos numéricos. Uma subclasse bastante comum na economia são é a subclasse dos inteiros. Essa subclasse abriga os números inteiros positivos ou negativos e se caracteriza por abrigar um L após o número. Por exemplo, 10 é um elemento da classe numérica, mas 10L é um elemento da subclasse dos inteiros pertencente à classe dos numéricos.\nPara checar se um elemento é inteiro, use o comando is.integer(), indicando o elemento no parêntesis. Por exemplo, vamos checar se 10 é inteiro:\n\nis.integer(10)\n\n[1] FALSE\n\n\nNote que o resultado é FALSE, indicando que 10 não é inteiro. Isso ocore porque os números inteiros devem obrigatoriamente ser sucedidos da letra L. Informando corretamente tem-se:\n\nis.integer(10L)\n\n[1] TRUE\n\n\nPara transformar um elemento numérico na subclasse dos inteiros, basta usar a função as.integer(), informando o elemento no parênteses. Por exemplo, vamos transformar o código do estado no data frame de nome sul em inteiro.\n\nsul$codigo_uf = as.integer(sul$codigo_uf)\nprint(sul)\n\n            estados       capital codigo_uf\n1            Paraná      Curitiba        41\n2    Santa Cararina Florianópolis        42\n3 Rio Grande do Sul  Porto Alegre        43\n\n\nNote que visivelmente não há mudanças nas propriedades da coluna modificada, porém agora quando consultarmos se essa coluna pertence ao conjunto dos inteiros, o output é verdadeiro:\n\nis.integer(sul$codigo_uf)\n\n[1] TRUE\n\n\n\n\n3.2.2 Subclasses dos numéricos: racionais (doubles)\nOs números racionais são declarados como doubles na linguagem R. Esse conjunto abriga também os inteiros e os naturais, isto é, um inteiro sempre será um double, assim como um natural sempre será um double. Para checar se um número pertence a essa categoria, use a função is.double(), indicando o elemento de interesse no parênteses.\n\nis.double(10.5555)\n\n[1] TRUE\n\n\nDe maneira análoga, um elemento numérico declarado como texto pode ser trannsformado em racional usando a função as.double(), indicando o elemento de interesse no parênteses.\n\nas.double(\"10.5\")\n\n[1] 10.5\n\n\nEm alguns casos, os números racionais possuem múltiplas casas decimais e é preciso reduzir essas casas decimais arredondando a última casa. Isso pode ser facilmente resolvido usando a função round(), que possui o seguinte modo de uso: round(nome do objeto ou elemento, número de casas decimais). Por exemeplo, imagine que queiramos reduzir o número 5.56413 para apenas uma casa decimal. Nesse caso, devemos proceder conforme a seguir:\n\nround(5.564132, 1)\n\n[1] 5.6",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "Aula3.html#elementos-lógicos-true-e-false",
    "href": "Aula3.html#elementos-lógicos-true-e-false",
    "title": "3  Classes de elementos",
    "section": "3.3 Elementos lógicos: (TRUE e FALSE)",
    "text": "3.3 Elementos lógicos: (TRUE e FALSE)\nOs elementos lógicos podem assumir dois valores, verdadeiro (TRUE) ou falso (FALSE). Sempre que o elemento lógico for verdadeiro, o R atribui valor 1 a este elemento, ao passo que sempre que o elemento lógico for falso, o R atribui valor 0 a este elemento. Assim, é possível aplicar operações matemáticas aos elementos pertencentes a essa classe. Isso advém da premissa de que as linguagens de programação são baseados em sistemas binários de afirmação e negação comentada no capítulo 1.\nEssa classe de elementos é bastante utilizada na economia para representar variáveis binárias onde a categoria de interesse recebe o valor unitário. Por exemplo, imagine uma pesquisa com foco no diferencial de salário por sexo. Nesse tipo de pesquisa é ideal saber se o indivíduo é homem ou mulher. Se a categoria de interesse for o sexo masculino, então os homens recebem valor TRUE e as mulheres recebem vaor FALSE. Isso equivale a atribuir 1 para os homens e 0 para as mulheres.\nPara verificar se um elemento pertence a essa categoria, use a função is.logical(), indicando o nome do elemento entre o parênteses. Para exemplificar, vamos criar uma nova coluna no data frame de estados da regiao sul com o nome parana que identifica se o estado em questão é ou não o estado do Paraná.\n\nsul$parana = c(1,0,0)\nprint(sul)\n\n            estados       capital codigo_uf parana\n1            Paraná      Curitiba        41      1\n2    Santa Cararina Florianópolis        42      0\n3 Rio Grande do Sul  Porto Alegre        43      0\n\n\nAgora vamos checar se essa coluna é um elemento lógico.\n\nis.logical(sul$parana)\n\n[1] FALSE\n\n\nNote que o output é FALSE, indicando que não se trata de um elemento lógico, o que é esperado dado que se trata de um elemento numérico. Para transformar essa coluna em um elemento lógico, basta usar a função as.logical(), indicando o nome do elemento de interesse no parênteses.\n\nsul$parana = as.logical(sul$parana)\nprint(sul)\n\n            estados       capital codigo_uf parana\n1            Paraná      Curitiba        41   TRUE\n2    Santa Cararina Florianópolis        42  FALSE\n3 Rio Grande do Sul  Porto Alegre        43  FALSE\n\n\nAgora vamos checar novamente se essa coluna é um elemento lógico.\n\nis.logical(sul$parana)\n\n[1] TRUE\n\n\nNote que o output é TRUE, indicando que se trata de um elemento lógico.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "Aula3.html#valores-multicategóricos-fatores-factors",
    "href": "Aula3.html#valores-multicategóricos-fatores-factors",
    "title": "3  Classes de elementos",
    "section": "3.4 Valores multicategóricos: Fatores (factors)",
    "text": "3.4 Valores multicategóricos: Fatores (factors)\nOs factors são elementos usados para representar valores multicategóricos. Por exemplo, imagine uma variável que expressa a situação do empregado no mercado de trabalho. Ele pode estar (1) apenas trabalhando, (2) apenas estudando, (3) trabalhando e estudando, (4) nem trabalhando nem estudando porém procurando emprego, ou (5) nem trabalhando nem estudando nem procurando emprego. Note que são cinco possibilidades que agora não podem ser representadas pelos elementos lógicos.\nPara declarar um elemento multicategórico é necessário usar o comando factor() que tem a seguinte forma de uso: factor(x = elemento, levels = níveis das categorias). Para exemplificar, vamos criar um objeto de nome emprego com as possibilidades indicadas no parágrafo anterior e os seus respectivos valores.\n\nemprego = factor(\n  x = c(\n    \"apenas trabalhando\", \n    \"apenas estudando\", \n    \"trabalhando e estudando\", \n    \"nem trabalhando nem estudando porém procurando emprego\",\n    \"nem trabalhando nem estudando nem procurando emprego\"\n  ),\n  levels = c(\n    \"apenas trabalhando\", \n    \"apenas estudando\", \n    \"trabalhando e estudando\", \n    \"nem trabalhando nem estudando porém procurando emprego\",\n    \"nem trabalhando nem estudando nem procurando emprego\"\n  )\n)\n\nprint(emprego)\n\n[1] apenas trabalhando                                    \n[2] apenas estudando                                      \n[3] trabalhando e estudando                               \n[4] nem trabalhando nem estudando porém procurando emprego\n[5] nem trabalhando nem estudando nem procurando emprego  \n5 Levels: apenas trabalhando apenas estudando ... nem trabalhando nem estudando nem procurando emprego\n\n\nSerá atribuído valor 1 para a primeira categoria indicada no vetor de níveis (levels), 2 para a segunda categoria e assim sucessivamente.\nPara checar se um elemento é multicategórico, devs-se usar a função is.factor(), indicando o nome do elemento no parênteses.\n\nis.factor(emprego)\n\n[1] TRUE",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "Aula3.html#exercício-1",
    "href": "Aula3.html#exercício-1",
    "title": "3  Classes de elementos",
    "section": "3.5 Exercício 1",
    "text": "3.5 Exercício 1\nConsidere o seguinte data frame:\n\nset.seed(10)\ndados = data.frame(\n  pessoa = 1:30,\n  idade = sample(8:85,30, replace = T),\n  sexo = sample(c(\"M\", \"F\"), 30, replace = T),\n  estado_civil = sample(c(\"Solteiro\", \"Casado\", \"Viúvo\", \"Divorciado\"), 30, replace = T),\n  salario = rnorm(30, mean = 1200, sd = 300)\n)\n\n(1) Crie uma variável de nome sexo2 transformando a variável sexo em um elemento lógico atribuindo o valor unitário para as mulheres.\n(2) Crie uma variável de nome fase_vida atribuindo os nomes infância para as pessoas com menos de 12 anos, adolescência para as pessoas com idade entre 12 e 18 anos, adulta para as pessoas com idade entre 18 e 65 anos e velhice para as pessoas com mais de 65 anos.\n(3) Crie uma nova variável de nome fase_vida2 transformando a variável fase_vida em um factor ordenando as categorias de acordo com a fase da vida em ordem crescente.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "Aula3.html#exercício-2",
    "href": "Aula3.html#exercício-2",
    "title": "3  Classes de elementos",
    "section": "3.6 Exercício 2",
    "text": "3.6 Exercício 2\nConsidere a base de dados sobre carros mtcars:\n\ncarros = mtcars\n\n(1) Crie uma coluna de nome automatico transformando a coluna am em um elemento lógico.\n(2) Transforme a coluna cyl em um factor onde o atributo x recebe os valores “4 cilindros”, “6 cilindore” e “8 cilindros” ordenados na forma crescente.\n(3) Crie uma nova coluna de nome carro contendo o nome dos carros indicados nos nomes das linhas do data frame.\n(4) Verifique a casse da coluna criada na questão.\n(5) Verifique se a coluna criada nas questões 1 e 2 são factors.\n(6) Verifique se a coluna mpg é inteiro e caso não seja transforme-a em inteiro.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Classes de elementos</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução à Programação e à Ciência de Dados",
    "section": "",
    "text": "Prefácio\nEsse é um material construído para auxiliar os discentes do curso de Ciências Econômicas da Universidade Regional do Cariri no decorrer da disciplina de Introdução à programação e à ciência de dados, ministrada no terceiro período do curso. O material possui os instrumentos básicos para o acompanhamento do curso, incluindo explicações, comandos e exercícios. O material está organizado na ordem cronológica dos conteúdos repassados na disciplina de tal modo que essa ordem tem o intúito de conduzir o discente no aprendizado da programação computacional aplicada à economia em um cronograma planejado de acordo com as boas práticas do aprendizado da programação, evitando que o discente comece os estudos por conteúdos inadequados para os iniciantes nessa área.\nO foco do material é a linguagem R, a mesma utilizada como objeto central da disciplina. Contudo, os métodos de aprendizado também podem ser expandidos para outras linguagens, desde que as devidas adaptações de vocabulário sejam consideradas. O material também possui um foco na análise de dados, desviando-se da programação computacional “bruta” devido a necessidade do curso e dos economistas em dominar os fundamentos básicos da utilização de dados.",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introdução",
    "section": "",
    "text": "1.1 A lógica de programação\nImagine que o computador é uma empresa que realiza diferentes tarefas e que nessa empresa existem funcionários de várias partes do mundo. Cada funcionário realiza as mesmas tarefas, porém, falando diferentes idiomas. Assim, se você quer que um funcionário americano realize uma tarefa, terá que ordenar que ele a faça em inglês; se você quer que um funcionário italiano realize a mesma tarefa, terá de fazer o pedido para ele falando italiano, e assim sucessivamente. No computador, os funcionários são as linguagens de programação e o idioma é o vocabulário da linguagem (ou a maneira de escrever os comandos em cada linguagem). Resumidamente e exemplificadamente, você pode executar uma tarefa usando R ou pode executar essa mesma tarefa usando Python ou qualquer outra linguagem de programação pois a lógica de comunicação com o computador será a mesma, porém, os comandos para execuar a mesma tarefa podem ser diferentes em cada linguagem. Como consequência, o primeiro passo para dominar as linguagens de programação é desenvolver uma lógica de programação.\nA lógica de programação é um raciocínio sobre como se comunicar com o computador para realizar tarefas. Seguindo o exemplo da empresa citado no parágrafo anterior, se você precisa de um relatório impresso, terá de falar o seguinte “eu preciso que você imprima esse relatório”. Porém, como os funcionários falam diferentes idiomas, você precisa fazer esse pedido em uma linguagem diferente a depender do funcionário responsável pela impressão. A maneira como você faz o pedido (“eu preciso que você imprima esse relatório”) não vai mudar independente do funcionário que receberá a ordem, o que muda é apenas o idioma em que a ordem será feita. No computador, essa maneira como você faz o pedido é a lógica de programação, ela será a mesma para qualquer linguagem de programação, que no caso do exemplo corresponde ao idioma falado.\nO primeiro passo para desenvolver uma lógica de programação é entender as operações fundamentais de uma linguagem de programação. Uma linguagem de programação é nada mais do que uma maneira de se comunicar com o computador para ordenar que ele execute tarefas automáticas. As linguagens são configuradas em sistemas binários (negação e afirmação). Cada linguagem de programação possui o seu vocabulário, porém, todas as linguagens partem dos mesmos princípios e das mesmas lógicas fundamentais. Exemplos: JavaScript, R, Python, Julia, Ruby, Scala…",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#como-usar-a-linguagem-de-programação",
    "href": "intro.html#como-usar-a-linguagem-de-programação",
    "title": "1  Introdução",
    "section": "1.2 Como usar a linguagem de programação",
    "text": "1.2 Como usar a linguagem de programação\nO primeiro paso para se comunicar com o computador por meio de uma linguagem de programação é informar à máquina a sua intenção de usar o vocabulário da linguagem. Em outras palavras, é preciso “instalar” a linguagem em sua máquina. Na analogia da empresa anteriormente mencionada, instalar a linguagem de programação seria como fazer um curso de idiomas e receber um manual de instruções de gramática para falar com os empregados.\nNesse material, utilizaremos a linguagem R. Seguindo o primeiro passo, a instalação da linguagem deve ser feita antes de qualquer outro procedimento. Os métodos de instalação variam de acordo com o sistema operacional do usuário. Nesse material, vamos supor que o aluno dispõe de uma máquina com sistema operacional windows. Nesse caso, o usuário deve baixar os componentes da linguagem nesse endereço Tendo feito isso, o usuário deve executar o arquivo baixado e instalar normalmente como qualquer instalação convencional no sistema windows.\nO segundo passo é adotar um ambiente de execução. Esses ambientes são softwares também conhecidos como ambiente de desenvolvimento integrado (IDE) - Exemplos: Rstudio, Pycharm, Google Colaboratory, StataMP-. De forma geral, o IDE é uma plataforma onde você escreve as ordens que deseja que o computador execute em uma determinada linguagem. Especificando com outras palavras, o ambiente de execução é um software usado para escrever as ordens ao computador por meio do vocabulário da linguagem. Como vamos usar a linguagem R nesse material, temos que adotar um IDE que execute ordens nessa linguagem. É recomendado que o usuário utilize o Rstudio apesar de existirem diversas outras ferramentas com esse mesmo propósito. Para tanto, é preciso baixar o programa nesse endereço e proceder com com os procedimentos padrões de instalação de softwares no sistema windows.\nÉ importante ressaltar que uma linguagem de programação não é um software, por exemplo, é errôneo se referir à linguagem R como “software R”, assim como é equivocado se referir à linguagem stata como “software stata”, e assim sucessivamente. Também é importante destacar que os IDEs não são linguagens de programação, eles apenas transferem para o computador uma ordem para ser executado em uma determinada linguagem. Com isso, é errôneo afirmar que uma dada tarefa foi “executada pelo software Rstudio”.\nAo instalar o Rstudio, o usuário irá se deparar com a tela ilustrada na imagem a seguir. Note que o IDE é formado por quatro painéis, cada um deles com a sua funcionalidade. O painel 1 é conhecido como input ou painel de entrada. Nesse painel o usuário irá abrir e manipular os arquivos de entrada como scripts e códigos de programação em R. Outros arquivos de entrada também são suportados como arquivos html, markdown, dentre outros. Mas essas extensões adicionais não são o foco do curso. Para gerar um arquivo de entrada onde serão escritos os comandos da linguagem R, pressione Ctrl Shift n ou vá na parte superior esquerda, na barra de tarefas do IDE em file, new file, r script.\nO painel 2 é conhecido como console. Nesse painel serão expostos os resultados das tarefas executadas nos comandos escritos no painel 1. O usuário também pode escrever e executar os comandos diretamente no console, com a diferença de que no r script os códigos podem ser salvos para o uso posterior ao contrário do console.\nO painel 3 é conhecido como ambiente de trabalho ou working environment. Ele é dividido em quatro abas que podem ser acessadas separadamente, sendo: o Environment onde são expostos todos os objetos criados, o histórico (history) onde os últimos comandos ficam armazenados numa espécie de breve histórico de comandos, as conecções (Connectione) onde são expostas as ferramentas conectadas a linguagem R e ao Rstudio para executar tarefas, e a aba de tutoriais, onde o usuário pode acessar um breve guia sobre como usar o Rstudio. Versões mais recentes também disponibilizam abas adicionais sobre controle de versionamento no ambiente de trabalho, mas por enquanto esse não é o foco do curso.\nO painel 4 é conhecido como output ou painel de saída. Nele o usuário pode visualizar os produtos gerados com os comandos e navegar pelo diretório de trabalho. O painel é dividido em cinco abas, sendo: a aba de arquivos (files), onde o usuário pode navegar pela pasta que está usando; a aba plots, onde o usuário pode visualizar gráficos e figuras geradas com os comandos escritos no painel 1; a aba de bibliotecas (packages) onde o usuário pode acessar as bibliotecas instaladas na linguagem; a aba de ajuda (Help), onde o usuário pode consultar manuais de instrução sobre diferentes comandos e bibliotecas; e por fim a aba de visualização (View), onde o usuário pode visualizar objetos dinâmicos ou estáticos criados com alguma ferramenta adicional auxiliar à linguagem R como páginas web, arquivos pdf, etc.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#comandos",
    "href": "intro.html#comandos",
    "title": "1  Introdução",
    "section": "1.3 Comandos",
    "text": "1.3 Comandos\nOs ambientes de execução podem operar em ordens diretas (cliques) ou comunicação agrupada (comandos). Os ambientes de execução sugeridos nesta disciplina operam com linhas de comando. Nas linhas de comando, o operador (aluno) escreve uma ordem que o ambiente de execução entende como um comando para executar uma tarefa. Esses comandos são escritos individualmente em cada linha, isto é, cada linha escrita só agrupa um único comando. Ao escrever uma linha de comando no Rstudio, você poderá executar essse comando posicionando o cursor na linha (ou selecionando as linhas de interesse) e em seguida pressionando “Ctrl Enter”.\nAlguns comandos já estão pré-programados no vocabulário das linguagens. Porém outros comandos precisam ser elaborados pelo próprio usuário usando os comandos pré-progamados e as demais ferramentas próprias do vocabulário da linguagem. Por exemplo, se você quer somar dois números quaisquer a e b, você pode fazer isso com uma operação de soma que já é automaticamente reconhecida pela linguagem R. Mas se você quer somar \\(a + b\\) apenas se \\(a &gt; b\\), então você precisa usar a lógica de programação para programar esse comando.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#bibliotecas",
    "href": "intro.html#bibliotecas",
    "title": "1  Introdução",
    "section": "1.4 Bibliotecas",
    "text": "1.4 Bibliotecas\nO usuário pode ordenar que o computador execute uma tarefa por meio de comandos. Além disso, o usuário também pode unir vários comandos em uma função para executar uma tarefa de interesse. Muitas funções já estão disponíveis na própria linguagem nativa, por exemplo, caso o usuário queira gerar um gráfico ele pode usar o comando plot() que é uma função que usa vários comandos nativos da linguagem R para gerar uma figura. Assim como a função plot, muitas outras funções já estão disponíveis e prontas para o acesso no ato da instalação da linguagem. Porém, existem funções que são criadas por terceiros e que precisam ser instaladas para que possam ser usadas. Por exemplo, em vez de elaborar um gráfico com a função plot, o usuário pode usar a função ggplot. No entanto, essa função só pode ser usada caso a biblioteca ggplo2 esteja instalada. O usuário pode verificar se uma determinada biblioteca está instalada navegando pelo painel inferior direito, na aba Packages, digitando o nome da biblioteca na guia de busca. Caso a biblioteca esteja instalada, então a busca retornará um indicativo com o nome da biblioteca, do contrário, o resultado da busca será vazio.\nPara instalar uma biblioteca o usuário deve usar o comando install.packages() posicionando no parêntesis o nome da biblioteca entre aspas. Por exemplo, para instalar a biblioteca ggplot2, o usuário deve executar o comando install.packages(“ggplot2”). Feito isso, a biblioteca estará disponível na lista de bibliotecas instaladas da aba Packages do painel inferior direito. Uma vez instalada, a instalação não precisa ser refeita, exceto em caso de atualização para uma nova versão.\nNo entanto, não basta instalar a biblioteca para usufruir de suas funções. Sempre que o Rstudio for reiniciado ou sempre que uma nova seção for iniciada no Rstudio é necessário liberar a biblioteca para o uso. Isso é feito por meio do comando library() ou require() sempre posicionando entre parêntesis o nome da biblioteca desejada, dessa vez, sem aspas. Por exemplo, para liberar a biblioteca ggplot2 para o uso, proceda conforme a seguir:\n\nlibrary(ggplot2)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#operações-fundamentais-em-r",
    "href": "intro.html#operações-fundamentais-em-r",
    "title": "1  Introdução",
    "section": "1.5 Operações fundamentais em R",
    "text": "1.5 Operações fundamentais em R\n\n1.5.1 Soma\nPara efetuar uma soma, você deve utilizar o operador de adição “+”. Por exemplo, para somar \\(1 + 1\\) proceda como a seguir:\n\n1+1\n\n[1] 2\n\n\n\n\n1.5.2 Subtração\nPara efetuar uma subtração, você deve utilizar o traço simples “-” como operador de subtração. Por exemplo, para subtrair \\(1 - 1\\) proceda como a seguir:\n\n1-1\n\n[1] 0\n\n\n\n\n1.5.3 Multiplicação\nPara efetuar uma multiplicação, você deve utilizar o asterisco “*” como operador de multiplicação. Por exemplo, para somar \\(1\\) x \\(1\\) proceda como a seguir:\n\n1*1\n\n[1] 1\n\n\n\n\n1.5.4 Divisão\nPara efetuar uma divisão, você deve utilizar a barra simples “/” como operador de divisão. Por exemplo, para dividr 4 por 2, proceda como a seguir:\n\n4/2\n\n[1] 2\n\n\n\n\n1.5.5 Potência\nPara efetuar uma potenciação, você deve utilizar o circunflexo “^” ou o duplo asterisco “**” como operador de multiplicação. Por exemplo, para calcular \\(2^3\\) proceda como a seguir:\n\n2^3\n\n[1] 8\n\n\nO que também pode ser feito da seguinte maneira:\n\n2**3\n\n[1] 8\n\n\n\n\n1.5.6 Raíz quadrada\nPara efetuar uma radiciação, você deve utilizar o comando sqrt posisionando o número em prêntesis. Por exemplo, para calcular \\(\\sqrt{16}\\) proceda como a seguir:\n\nsqrt(16)\n\n[1] 4\n\n\n\n\n1.5.7 Logaritmo\nPara calcular o logaritmo de um número, você deve utilizar ocomando log10 posisionando o número em prêntesis. Por exemplo, para calcular \\(log(2)\\) proceda como a seguir:\n\nlog10(2)\n\n[1] 0.30103\n\n\n\n\n1.5.8 Logaritmo natural\nPara calcular o logaritmo natural de um número, você deve utilizar ocomando log posisionando o número em prêntesis. Por exemplo, para calcular \\(ln(2)\\) proceda como a seguir:\n\nlog(2)\n\n[1] 0.6931472\n\n\n\n\n1.5.9 Seno\nPara calcular o seno de um número, você deve utilizar ocomando sin posisionando o número em prêntesis. Por exemplo, para calcular o seno de 90 proceda como a seguir:\n\nsin(90)\n\n[1] 0.8939967\n\n\n\n\n1.5.10 Cosseno\nPara calcular o cosseno de um número, você deve utilizar ocomando cos posisionando o número em prêntesis. Por exemplo, para calcular o cosseno de 90 proceda como a seguir:\n\ncos(90)\n\n[1] -0.4480736\n\n\n\n\n1.5.11 Tangente\nPara calcular a tangente de um número, você deve utilizar ocomando tan posisionando o número em prêntesis. Por exemplo, para calcular a tangente de 90 proceda como a seguir:\n\ntan(90)\n\n[1] -1.9952\n\n\n\n\n1.5.12 Divisão inteira\nAlgumas divisões resultam em números não inteiros, de tal modo que o resultado é composto por um número inteiro aderido de um “resto”. Para calcular a divisão sem o resto você deve usar o operador %/%. Por exemplo, uma divisão inteira de cinco por dois deve resultar em dois e pode ser feita da seguinte maneira:\n\n5 %/% 2\n\n[1] 2\n\n\n\n\n1.5.13 Resto da divisão\nPorém, se o usuário estiver interessado em obter apenas o resto da divisão, pode usar o operador %%. No caso do exemplo anterior, o resto da divisão é um e pode ser obtido da seguinte maneira:\n\n5 %% 2\n\n[1] 1",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#operadores-lógicos",
    "href": "intro.html#operadores-lógicos",
    "title": "1  Introdução",
    "section": "1.6 Operadores lógicos",
    "text": "1.6 Operadores lógicos\nOs operadores lógicos são usados para comparar valores. O principal operador lógico de uma linguagem de programação é o operador de afirmação ou negação. Sempre que houver uma afirmação, a lingaugem retornará um sinal de verdadeiro (TRUE) e sempre que houver uma negação, a lingaugem retornará um sinal de falso (FALSE). Nos comandos, o TRUE pode ser substituído pelo T, enquanto o FALSE pode ser substituído pelo F. A linguagem R atribui o valor zero para as negações e o valor um para as afirmações. Assim, TRUE = 1 e FALSE = 0 sempre ocorrerá.\n\n1.6.1 Igualdade\nPara checar uma condição de igualdade, você deve usar o operador “==”. Por exemplo, para checar se dois é igual a três, você deve proceder como:\n\n2 == 3\n\n[1] FALSE\n\n\n\n\n1.6.2 Desigualdade maior que\nPara checar uma condição de desigualdade na forma de maior que, isto é, para verificar se um valor é maior que outro, você deve usar o operador “&gt;”. Por exemplo, para checar se dois é maior que três, você deve proceder como:\n\n2 &gt; 3\n\n[1] FALSE\n\n\n\n\n1.6.3 Desigualdade menor que\nPara checar uma condição de desigualdade na forma de menor que, isto é, para verificar se um valor é menor que outro, você deve usar o operador “&lt;”. Por exemplo, para checar se dois é menor que três, você deve proceder como:\n\n2 &lt; 3\n\n[1] TRUE\n\n\n\n\n1.6.4 Desigualdade maior ou igual\nPara checar uma condição de desigualdade na forma de maior ou igual a, isto é, para verificar se um valor é maior ou igual outro, você deve usar o operador “&gt;=”. Por exemplo, para checar se dois é maior ou igual a três, você deve proceder como:\n\n2 &gt;= 3\n\n[1] FALSE\n\n\n\n\n1.6.5 Desigualdade menor ou igual\nPara checar uma condição de desigualdade na forma de menor ou igual a, isto é, para verificar se um valor é menor ou igual outro, você deve usar o operador “&lt;=”. Por exemplo, para checar se dois é menor ou igual a três, você deve proceder como:\n\n2 &lt;= 3\n\n[1] TRUE\n\n\n\n\n1.6.6 Diferente de\nPara checar se um valor é diferente de outro, você deve usar o operador “!=”. Por exemplo, para checar se dois é diferente de três, você deve proceder como:\n\n2 != 3\n\n[1] TRUE\n\n\n\n\n1.6.7 Operador “e”\nMuitas vezes precisamos usar duas operações em conjunto ou até mesmo checar se duas ou mais propriedades ocorrem ao mesmo tempo. Nesse caso, o ideal é utilizar o operador “e” que baseia-se no acontecimento de duas operações simultâneas. Assim, dadas duas operações quaisquer, se as duas ocorrem ao mesmo tempo então o output será TRUE, do contrário o output será FALSE. Por exemplo, esse operador poderia ser usado caso quiséssemos verificar se 2 é menor que 3 e ao mesmo tempo diferente de 4. Em R operador “e” é dado pelo “e comercial” &.\n\n2 &lt; 3 & 2 != 4\n\n[1] TRUE\n\n\n\n\n1.6.8 Operador “ou”\nEm uma situação em que se deseja verificar se pelo menos uma operação ocorre dentre várias operações, então o ideal é utilizar o operador “ou”. Por exemplo, se temos duas operações, a operação 1 e a operação 2 e se precisamos verificar se pelo menos uma das duas operações ocorre, podemos perguntar se a operação 1 OU a operação 2 estão ocorrendo. O output será “TRUE” caso uma das operações ocorra e “FALSE” caso nenhuma das operações ocorra. Em R esse operador é dado pela barra vertical “|”. Por exemplo, suponha que queremos verificar se 2 é menor que 3 pu se 2 é maior que 5. Nesse caso, precisamos proceder conforme a seguir:\n\n2 &lt; 3 | 2 &gt; 5\n\n[1] TRUE",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#objetos",
    "href": "intro.html#objetos",
    "title": "1  Introdução",
    "section": "1.7 Objetos",
    "text": "1.7 Objetos\nAs linguagens de programação geralmente são identificadas ao objeto, isto é, é possível criar um objeto que representa algum ítem ou valor. Em R, os objetos devem ser criados om um indicativo de igualdade “=”. Por exemplo, imagine que precisamos criar um objeto com o nome “idade” contendo a idade de uma pessoa em anos. Este procedimento é feito informando o comando “nome do objeto = valor do objeto” conforme demonstrado a seguir:\n\nidade = 18\n\nAo executar esse comando, um novo objeto surgirá na aba Environment do painel 3. Esse objeto tem o nome “idade” e recebe um valor de 18. Para visualizar o valor do objeto, o usuário pode usar a função print que imprimirá no painel 2 (console) o valor referente ao objeto mencionado.\n\nprint(idade)\n\n[1] 18\n\n\nTendo feito isso, e dado que o objeto de nome idade e valor 18 está no Environment, cada vez que esse objeto for mencionado a linguagem R reconhecerá que se trata do número 18. Para exemplificar, suponha que uma pessoa é considerada idosa a partir dos 60 anos e suponha que você precise descobrir quantos anos ainda restam para que essa pessoa com idade = 18 se torne idosa. Nesse caso, você deve proceder como:\n\n60 - idade\n\n[1] 42",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#tipos-de-objetos",
    "href": "intro.html#tipos-de-objetos",
    "title": "1  Introdução",
    "section": "1.8 Tipos de objetos",
    "text": "1.8 Tipos de objetos\nOs objetos são maneiras de armazenar informações em um dado arranjo. Em R, essas informações podem ser arranjadas em funções, vetores, matrizes, listas, arrays ou quadros de dados (data frames). Cada objeto tem a sua função específica e deve ser usado conforme a necessidade. Por exemplo, uma matriz é ideal para armazenar objetos com duas dimensões (linha e coluna) mas não é adequada para agrupar objetos com três dimensões, nesse caso melhor seria usar um array ou uma lista.\n\n1.8.1 Vetores\nOs vetores são objetos que servem para guardar informações unidimensionais, isto é, informações que podem ser escritas em uma única linha ou coluna. Por exemplo, imagine que você trabalhou cinco dias em um emprego e notou em uma planilha o seu salário de cada dia. Suponha que os seus ganhos dia após dia em reais foram 50.00, 52.00, 55.00, 48.00, 60.00. Se você anotou essas informações em uma linha de uma planilha, então você tem um vetor linha. Analogamente, se as informações foram anotadas em uma coluna de uma planilha, tem-se um vetor coluna. Se você chamou essa planilha de “salario”, então isso é o mesmo que:\n\\[\nsalario = [50.00, 52.00, 55.00,48.00,60.00]\n\\]\nPara digitar esse vetor em R deve-se usar o operador de vetores c(), sempre colocando os valores dentro do parêntesis separando cada valor por uma vírgula. Lembre-se que o separador decimal da linguagem R é o ponto e que a vírgula é um separador de valores. Com isso, o vetor anterior deve ser escrito como:\n\nsalario = c(50.00, 52.00, 55.00, 48.00, 60.00)\n\nFeito isso, um objeto de nome salario irá aparecer no ambiente de trabalho. Note que o nome do objeto é sucedido do termo num [1:5], isso indica que se trata de um vetor numérico com cinco elementos. Um detalhe importante a ser mencionado é o fato de que valores não numéricos também podem ser armazenados em vetores, por exemplo:\n\nnomes = c(\"João\", \"Maria\", \"José\")\n\nNote que os valores não numéricos sempre devem estar entre aspas. Para checar se um dado objeto é um vetor, o usuário pode usar a função is.vector() indicando o nome do objeto entre parêntesis. Por exemplo, para checar se o objeto salario é um vetor, proceda conforme a seguir:\n\nis.vector(salario)\n\n[1] TRUE\n\n\nCaso o elemento de fato seja um vetor, o output obtido será TRUE, do contrário o output será FALSE. Para transformar um determinado objeto em um vetor, o usuário pode usar a função as.vector(), indicando o nome do objeto entre parêntesis. Por exemplo, para transformar uma sequência de 1 a 10 em um vetor, proceda conforme a seguir:\n\nsq = as.vector(1:10)\n\n\n\n1.8.2 Matrizes\nAs matrizes são objetos que servem para guardar informações bidimensionais, isto é, informações que podem ser escritas em um múltiplas linhas e múltiplas colunas, desde que o usuário precise realizar operações algébricas com esses valores. Para exemplificar, considere o exemplo anterior do salário. Considere agora que você trabalhou cinco dias da semana não em um mas em dois empregos. Agora você vai atribuir um diasda semana para cada linha e vai anotar os ganhos de cada emprego em colunas diferentes. Suponha agora que os ganhos do emprego 2 foram de 140.00, 160.00, 165.00, 150.00 e 155.00. Isso equivale a:\n\\[\nsalario = \\left[\n\\begin{array}{cc}\nEmprego 1 & Emprego 2\\\\ \\hline\n50.00 & 140.00\\\\\n52.00 & 160.00\\\\\n55.00 & 165.00\\\\\n48.00 & 150.00\\\\\n60.00 & 155.00 \\\\\n\\end{array}\n\\right]\n\\]\nAgora a planilha de ganhos possui dois vetores coluna de cinco elementos cada ou cinco vetores linha de dois elementos cada. Para informar essa planilha como matriz no R, o usuário deve usar a função matrix. Nessa função o usuário deve digitar os elementos da planilha linha por linha em um único vetor e indicar isso com o parâmetro by.row = TRUE. Ou se preferir o usuário pode digitar os elementos da planilha coluna por coluna em um único vetor e indicar isso com o parâmetro by.row = FALSE. O usuário também deve informar o número de linhas da matriz com o parâmetro nrow e o número de colunas com o parâmetro ncol. Para repassar a planilha anterior em R na forma de matriz, proceda conforme a seguir:\n\nsalario = matrix(\n  c(50,140,52,160,55,165,48,150,60,155),\n  byrow = TRUE,\n  ncol = 2,\n  nrow = 5\n)\n\nprint(salario)\n\n     [,1] [,2]\n[1,]   50  140\n[2,]   52  160\n[3,]   55  165\n[4,]   48  150\n[5,]   60  155\n\n\nIsso é o mesmo que fazer:\n\nsalario = matrix(\n  c(50,52,55,48,60,140,160,165,150,155),\n  byrow = FALSE, # agrupamento por coluna\n  ncol = 2,\n  nrow = 5\n)\n\nprint(salario)\n\n     [,1] [,2]\n[1,]   50  140\n[2,]   52  160\n[3,]   55  165\n[4,]   48  150\n[5,]   60  155\n\n\nPara dar nomes às linhas de uma matriz, use a função rownames(), indicando o nome da matriz entre o parêntesis e informando os nomes das linhas em um vetor. Por exemplo:\n\nrownames(salario) = c(\"Seg\", \"Ter\", \"Quar\", \"Qui\", \"Sex\")\nprint(salario)\n\n     [,1] [,2]\nSeg    50  140\nTer    52  160\nQuar   55  165\nQui    48  150\nSex    60  155\n\n\nPara dar nomes às colunas de uma matriz, use a função colnames(), indicando o nome da matriz entre o parêntesis e informando os nomes das colunas em um vetor. Por exemplo:\n\ncolnames(salario) = c(\"Emprego 1\",\"Emprego 2\")\nprint(salario)\n\n     Emprego 1 Emprego 2\nSeg         50       140\nTer         52       160\nQuar        55       165\nQui         48       150\nSex         60       155\n\n\nPara verificar se um determinado objeto é uma matriz, use a função is.matrix(), indicando o nome do objeto entre o parêntesis, por exemplo:\n\nis.matrix(salario)\n\n[1] TRUE\n\n\nCaso o elemento de fato seja uma matriz, o output obtido será TRUE, do contrário o output será FALSE. Para transformar um determinado objeto em uma matriz, o usuário pode usar a função as.matrix(), indicando o nome do objeto entre parêntesis. Por exemplo, para transformar uma sequência de 1 a 10 em uma matriz, proceda conforme a seguir:\n\nsq = as.matrix(1:10)\nprint(sq)\n\n      [,1]\n [1,]    1\n [2,]    2\n [3,]    3\n [4,]    4\n [5,]    5\n [6,]    6\n [7,]    7\n [8,]    8\n [9,]    9\n[10,]   10\n\n\n\n1.8.2.1 Operações com matrizes\n\n1.8.2.1.1 Soma de matrizes\nA soma de matrizes em R não apresenta diferenças das operações convencionais de soma, ou seja, é feita usando o operador de soma “+”. Para exemplificar, considere as dias matrizes a seguir:\n\\[ matriz1 = \\left[ \\begin{array}{cc} 0 & 2 \\\\ 3 & 1 \\end{array} \\right] \\quad \\quad \\quad \\quad matiz2 = \\left[ \\begin{array}{cc} 5 & 3\\\\7 & 0 \\end{array} \\right] \\]\nPara gerar uma nova matriz de nome matriz3 contendo a soma da matriz 1 com a matriz 2, basta proceder conforme a seguir:\n\nmatriz1 = matrix(c(0,2,3,1), nrow = 2, ncol = 2, byrow = TRUE)\nmatriz2 = matrix(c(5,3,7,0), nrow = 2, ncol = 2, byrow = TRUE)\nmatriz3 = matriz1 + matriz2\nprint(matriz3)\n\n     [,1] [,2]\n[1,]    5    5\n[2,]   10    1\n\n\n\n\n1.8.2.1.2 Subtração de matrizes\nDe maneira análoga à operação de soma, a subtração de matrizes é feita usando o operador de subtração “-”. Nesse caso, os elementos de cada posição das matries são subtraídos. Para exemplificar, considere subtrair a matriz 1 da matriz 2, procedendo de acordo com o código a seguir:\n\nmatriz3 = matriz1 - matriz2\nprint(matriz3)\n\n     [,1] [,2]\n[1,]   -5   -1\n[2,]   -4    1\n\n\nÉ importante ressaltar que a soma e a subtração de matrizes só podem ser feitas com matrizes de mesma dimensão.\n\n\n1.8.2.1.3 Multiplicação de matrizes\nNa multiplicação, não é correto utilizar o asterisco como operador de multiplicação dado que multiplicar os termos de mesma posição de duas matrizes não é a maneira correta de efetuar o produto de matrizes. Para essa tarefa, o operador de multiplicação agora é \\(\\%*\\%\\) . Para exemplificar, considere multiplicarr a matriz 1 pela matriz 2.\n\nmatriz3 = matriz1 %*% matriz2\nprint(matriz3)\n\n     [,1] [,2]\n[1,]   14    0\n[2,]   22    9\n\n\n\n\n1.8.2.1.4 Matriz transposta\nA transposta de uma matriz nada mais é do que reorganizar as linhas como colunas e as colunas como linhas. Para obter a transposta de uma matriz em R basta usar a função t(), indicando entre parêntesis o nome da matriz que se deseja transpor. Para exemplificar, considere transpor a matriz 1. Nesse caso, deve-se proceder conforme a seguir:\n\nt(matriz1)\n\n     [,1] [,2]\n[1,]    0    3\n[2,]    2    1\n\n\n\n\n1.8.2.1.5 Matriz inversa\nUma matriz \\(M\\) pode ser invertida em R para obter \\(M^{-1}\\) usando o comando solve() e indicando dentro do parêntesis a matriz que se deseja inverter. Para exemplificar, considere obter a inversa da matriz 1. Nesse caso, deve-se proceder conforme a seguir:\n\nsolve(matriz1)\n\n           [,1]      [,2]\n[1,] -0.1666667 0.3333333\n[2,]  0.5000000 0.0000000\n\n\n\n\n1.8.2.1.6 Exemplo de operações com matrizes: O estimador de mínimos quadrados ordinários\nNa estatística, os coeficientes lineares de uma equação linear com múltiplos argumentos podem ser calculados por meio do método de mínimos quadrados ordinários. Se essa equação é:\n\\[ y = \\beta_0 + \\beta_1x_1 + \\beta_2x_2 + \\dots + \\beta_n x_n \\]\nUm termo de erro \\(\\varepsilon\\) é adicionado e a relação anterior pode ser escrita matricialmente como:\n\\[ \\textbf{y} = \\textbf{x} \\beta + \\varepsilon \\]\nMininiando a soma dos erros quadráticos, o vetor \\(\\beta\\) de parâmetros estimados é:\n\\[ \\beta = (\\textbf{x}^\\prime \\textbf{x})^{-1}\\textbf{x}^\\prime \\textbf{y} \\]\nPara exemplificar, considere usar a base natova sobre automóveis mtcars e suponha que estejamos interessados em saber a relação entre o consumo do automóvel (mpg) e as variáveis peso (wt) e número de cilindros (cyl). Nesse caso, a matriz y são os valores da coluna mpg e a matriz x é composta pelas colunas wt e cyl. O vetor de parâmetros estimados pode ser calculado de acordo com o seguinte processo:\n\ny = matrix(mtcars$mpg, ncol = 1) # matriz y\nx = matrix(c(rep(1,nrow(mtcars)), mtcars$wt, mtcars$cyl), ncol = 3) # matriz x\ntx = t(x) # transposta da matriz x\nbeta = solve(tx%*%x)%*%tx%*%y\nprint(beta)\n\n          [,1]\n[1,] 39.686261\n[2,] -3.190972\n[3,] -1.507795\n\n\nIsso é o mesmo que fazer:\n\nsummary(lm(mtcars$mpg ~ 1 + mtcars$wt + mtcars$cyl))\n\n\nCall:\nlm(formula = mtcars$mpg ~ 1 + mtcars$wt + mtcars$cyl)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.2893 -1.5512 -0.4684  1.5743  6.1004 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  39.6863     1.7150  23.141  &lt; 2e-16 ***\nmtcars$wt    -3.1910     0.7569  -4.216 0.000222 ***\nmtcars$cyl   -1.5078     0.4147  -3.636 0.001064 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.568 on 29 degrees of freedom\nMultiple R-squared:  0.8302,    Adjusted R-squared:  0.8185 \nF-statistic: 70.91 on 2 and 29 DF,  p-value: 6.809e-12\n\n\n\n\n\n\n1.8.3 Arrays\nO conceito de array generaliza a idéia de matrix. Enquanto em uma matrix os elementos são organizados em duas dimensões (linhas e colunas), em um array os elementos podem ser organizados em um número arbitrário de dimensões. Em R um array é definido utilizando a função array(). O usuário deve informar dentro do parêntesis as informações sempre ordenadas coluna a coluna e indicar as dimensões do array com o parâmetro dim. Por exemplo, imagine que queiramos armazenar o consumo de dois bens por duas famílias em três anos, neste caso, teremos que criar um array de dimensão 2 x 2 x 3. Para exemplificar, imagine que esse consumo seja o demonstrado a seguir:\n\\[\n\\begin{array}{ccc}\nAno 1 = \\left[\n\\begin{array}{c|cc}\n& Bem 1 & Bem 2 \\\\ \\hline\nFamilia 1 & 0 & 5\\\\\nFamilia 2 & 2 & 3\\\\\n\\end{array}\n\\right]\n&\nAno 2 = \\left[\n\\begin{array}{c|cc}\n& Bem 1 & Bem 2 \\\\ \\hline\nFamilia 1 & 1 & 4\\\\\nFamilia 2 & 3 & 2\\\\\n\\end{array}\n\\right]\n&\\\\\nAno 3 = \\left[\n\\begin{array}{c|cc}\n& Bem 1 & Bem 2 \\\\ \\hline\nFamilia 1 & 2 & 3\\\\\nFamilia 2 & 2 & 3\\\\\n\\end{array}\n\\right]\n\\end{array}\n\\]\nEm R isso equivale a:\n\nconsumo = array(\n  c(\n    0,2,5,3, # Ano 1\n    1,3,4,2, # Ano 2\n    2,2,3,3 # ano 3\n  ),\n  dim = c(2,2,3)\n)\nprint(consumo)\n\n, , 1\n\n     [,1] [,2]\n[1,]    0    5\n[2,]    2    3\n\n, , 2\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    3    2\n\n, , 3\n\n     [,1] [,2]\n[1,]    2    3\n[2,]    2    3\n\n\nPara checar se um objeto é um array, use a função is.array(). Caso o objeto de fato seja um array, o output obtido será TRUE, do contrário o output será FALSE.\n\nis.array(consumo)\n\n[1] TRUE\n\n\n\n\n1.8.4 Listas\nAs listas são objetos ideais para guardar informações em múltiplas dimensões, isto é, informações que possuam múltiplas linhas, múltiplas colunas e múltiplas planilhas. As listas podem armazenar diversos outros objetos, incluindo outras listas. Por exemplo, uma lista pode conter um vetor e uma matriz ou múltiplos vetores e múltiplas matrizes. Para criar uma lista, o usuário deve usar a função list() indicando dentro do parêntesis os objetos que irão compor a lista. Por exemplo, vamos criar uma lista contendo os as matrizes de consumo do array anterior e vamos chamar essa lista de lista1.\n\nano1 = matrix(\n  c(0,5,2,3), byrow = TRUE, nrow = 2, ncol = 2\n)\nano2 = matrix(\n  c(1,4,3,2), byrow = TRUE, nrow = 2, ncol = 2\n)\nano3 = matrix(\n  c(2,3,2,3), byrow = TRUE, nrow = 2, ncol = 2\n)\n\nlista1 = list(ano1, ano2, ano3)\nprint(lista1)\n\n[[1]]\n     [,1] [,2]\n[1,]    0    5\n[2,]    2    3\n\n[[2]]\n     [,1] [,2]\n[1,]    1    4\n[2,]    3    2\n\n[[3]]\n     [,1] [,2]\n[1,]    2    3\n[2,]    2    3\n\n\nPara checar se um objeto é uma lista, use a função is.list(). Caso o elemento de fato seja uma lista, o output obtido será TRUE, do contrário o output será FALSE.\n\nis.list(lista1)\n\n[1] TRUE\n\n\n\n\n1.8.5 Data frames\nOs data frames - ou quadro de dados - são objetos que possuem utilidade semelhante às matrizes, isto é, são ideais para armazenar informações bidimensionais. No entanto, nos data frames não é possível realizar operações algébricas como nas matrizes. Os data frames são exatamente iguais às planilhas do excel, onde cada coluna é uma variável com valores distribuídos entre as linhas. Essa estrutura de dados é inserida em R usando a função data.frame(), de tal modo que o usuário precisa indicar o nome de cada coluna precedida pelos seus valores em um vetor. Por exemplo, se usarmos o exemplo anterior do salário de dois empregos e quisermos colocar as informações dos ganhos em um data frame de nome salario_diario, devemos proceder conforme a seguir:\n\nsalario_diario = data.frame(\n  emprego1 = c(50,52,55,48,60),\n  emprego2 = c(140,160,165,150,155)\n)\n\nprint(salario_diario)\n\n  emprego1 emprego2\n1       50      140\n2       52      160\n3       55      165\n4       48      150\n5       60      155\n\n\nVocê pode mudar os nomes das colunas dos data frames usando a função colnames(). Por exemplo, se quisermos alterar o nome das colunas para trabalho1 e trabalho2, devemos proceder conforme a seguir:\n\ncolnames(salario_diario) = c(\"trabalho1\", \"trabalho2\")\nprint(salario_diario)\n\n  trabalho1 trabalho2\n1        50       140\n2        52       160\n3        55       165\n4        48       150\n5        60       155\n\n\nJá os nomes das linhas podem ser alterados por meio da função rownames().\n\nrownames(salario_diario) = c(\"Seg\", \"Ter\", \"Quar\", \"Qui\", \"Sex\")\nprint(salario_diario)\n\n     trabalho1 trabalho2\nSeg         50       140\nTer         52       160\nQuar        55       165\nQui         48       150\nSex         60       155\n\n\nPara checar se um objeto é um data frame, o usuário deve usar a função is.data.frame() indicando o nome do objeto dentro do parêntesis. Caso o objeto de fato seja um data frame, o output obtido será TRUE, do contrário o output será FALSE.\n\nis.data.frame(salario_diario)\n\n[1] TRUE\n\n\nAssim como em uma planilha excel, as colunas dos data frames podem conter valores numéricos e não numéricos. Maiores detalhes sobre essas possibilidades de valores serão vistos posteriormente quando abordarmos as classes dos elementos.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#exercício-1",
    "href": "intro.html#exercício-1",
    "title": "1  Introdução",
    "section": "1.9 Exercício 1",
    "text": "1.9 Exercício 1\n(1) Crie um objeto de nome valor1 com a operação \\(\\left(\\frac{5^5}{100}\\right)^{0.5}\\).\n(2) Crie um objeto de nome valor2 com a operação \\(\\left(\\frac{3^8}{100}\\right)^{0.5}\\).\n(3) Cheque se \\(\\left(\\frac{5^5}{100}\\right)^{0.5} \\neq \\sqrt{\\left(\\frac{5^5}{100}\\right)}\\).\n(4) Cheque se \\(\\left(\\frac{3^8}{100}\\right)^{0.5} \\neq \\sqrt{\\left(\\frac{3^8}{100}\\right)}\\).\n(5) Verifique se \\(\\left(\\frac{5^5}{100}\\right)^{0.5}  &gt;= \\left(\\frac{3^8}{100}\\right)^{0.5}\\).\n(6) Divida valor1 por valor2 e verifique se o resultado é maior que 1.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#exercício-2",
    "href": "intro.html#exercício-2",
    "title": "1  Introdução",
    "section": "1.10 Exercício 2",
    "text": "1.10 Exercício 2\nConsidere as seguintes planilhas de dados representando os preços das ações das empresas Petrobras, Vale e Itau em uma semana de negociações na bolsa de valores:\n\\[\npetrobras = \\left[\n\\begin{array}{c|ccc}\nDia & Preco & Maximo & Minimo \\\\ \\hline\nSeg & 34.5 & 34.75 & 33.8\\\\\nTer & 34.7 & 35.05 & 34.2\\\\\nQuar & 34.9 & 35.5 & 34.6\\\\\nQui & 34.55 & 34.9 & 34.3\\\\\nSex & 34 & 34.55 & 33.6\n\\end{array}\n\\right]\n\\]\n\\[\nvale = \\left[\n\\begin{array}{c|ccc}\nDia & Preco & Maximo & Minimo \\\\ \\hline\nSeg & 55.5 & 55.75 & 55.1\\\\\nTer & 56 & 56.6 & 55.5\\\\\nQuar & 56.5 & 56.75 & 56\\\\\nQui & 55.8 & 56 & 55.2\\\\\nSex & 55.2 & 55.8 & 55\n\\end{array}\n\\right]\n\\]\n\\[\nitau = \\left[\n\\begin{array}{c|ccc}\nDia & Preco & Maximo & Minimo \\\\ \\hline\nSeg & 28.5 & 28.75 & 28.3\\\\\nTer & 28.7 & 29.05 & 28.5\\\\\nQuar & 28.9 & 29.2 & 28.7\\\\\nQui & 28.6 & 28.9 & 28.5\\\\\nSex & 28.3 & 28.6 & 28.1\n\\end{array}\n\\right]\n\\]\n\nRepasse essas três planilhas para o R na forma de matrizes, nomeando-as de petrobras, vale e itau, assim como esboçado na representação das planilhas. Dê nomes às linhas e às colunas.\n\n(2) Agora repasse as planilhas para o R na forma de data frames, nomeando-os de df_petrobras, df_vale e df_itau. Dê nomes às linhas e às colunas.\n(3) Transforme as matrizes petrobras, vale e itau em data frames, nomeando-os de df_petrobras_2, df_vale_2 e df_itau_2.\n(4) Transforme os data frames df_petrobras, df_vale e df_itau em matrizes, nomeando-as de m_petrobras, m_vale e m_itau.\n(5) Cheque se os objetos petrobras, vale e itau são matrizes.\n(6) Cheque se os objetos df_petrobras, df_vale e df_itau são data frames.\n(7) Repasse as três planilhas para o R em um array nomeando-o de preco_acoes.\n(8) Cheque se o objeto criado na questão anterior é um array.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "Aula4.html",
    "href": "Aula4.html",
    "title": "4  Condições, funções e loops",
    "section": "",
    "text": "4.1 Condições\nNa programação e na análise de dados, muitas vezes é preciso realizar tarefas repetitivas, isto é, tarefas que devem ser aplicadas várias vezes a diferentes objetos ou elementos. Essas tarefas repetitivas podem ser automatizadas usando funções ou loops. Uma função é uma regra que é aplicada a um dado objeto para obter um resultado baseado na regra. Existe um input (semelhante ao domínio de uma função matemática) pelo qual a regra é aplicada para gerar um output (semelhante à imagem de uma função matemática).\nPor sua vez, um loop nada mais é do que uma maneira de aplicar a mesma função para os elementos do domínio dessa função automaticamente sem precisar fazer isso aplicando a função para cada elemento do domínio um a um.\nTanto nas funções quanto nos loops o usuário pode aplicar condições. Essas condições refletem a lógica binária das linguagens de programação e são baseadas na ideia de “se e caso contrário”. Assim, o usuário pode aplicar uma regra indicando que a linguagem de programação retorne um determinado valor ou regra caso uma condição se verifique ou retorne um outro valor caso contrário.\nNesse capítulo vamos nos debruçar sobre esses temas e entender as principais regras e aplicações das condições, funções e loops.\nComo mencionado na seção introdutória do capítulo, as condições são baseadas numa estrutura de se e caso contrário. As condições facilitam a aplicação de regras binárias ou multicategóricas que ocorrem quando se necessita de aplicar uma regra para gerar um resultado baseado em duas possibilidades. Por exemplo, imagine que seja preciso verificar se um número é par ou ímpar. Nesse caso existem duas possibilidades (ou o número é par ou é ímpar). O input da regra é o número indicado e o output (resultado) é o tipo de número (par ou ímpar). Nesse caso, a condição aplicada seria: “Caso o número seja par, retorne uma afirmativa positiva, do contrário retorne uma negação”.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Condições, funções e loops</span>"
    ]
  },
  {
    "objectID": "Aula4.html#condições",
    "href": "Aula4.html#condições",
    "title": "4  Condições, funções e loops",
    "section": "",
    "text": "4.1.1 Condição if\nA condição if é ideal para ser aplicada quando o usuário está interessado apenas no se e não necessita do caso contrário. Por exemplo, no caso da verificação do tipo de número especificada anteriormente, se o usuário apenas quer saber se o número é par e não precisa de um resultado caso o número seja ímpar, então a condição if é ideal. Essa condição é bastante utilizada em tarefas que envolvem programação bruta como elaboração de jogos e sites dinâmicos. Porém, ela é bastante útil na análise de dados e na construção de modelos econômicos. A aplicação da condição if deve seguir a seguinte forma funcional:\n\n#if(condição){\n# resultado caso a condição seja verdadeira\n#}\n\nPara exemplificar, vamos aplicar esse procedimento para saber se o número 10 é par. Mas como saber a regra para obter o resultado nesse caso? A resposta vem da lógica de aplicação da regra e dos conhecimentos das operações básicas de programação vistas no capítulo 1. Sabe-se que os números pares têm o resto da divisão por 2 igual a zero. Assim, se o resto da divisão de 10 por 2 for zero, então 10 é um número par. Vimos no capítulo 1 que o operador de resto da divisão é %%. Assim, a verificação de que 10 é par pode ser exposta da seguinte maneira:\n\nif(10 %% 2 == 0){\n  print(\"O número é par\")\n}\n\n[1] \"O número é par\"\n\n\n\n\n4.1.2 Condição ifelse\nAo usar a condição if, o usuário busca uma resposta para um problema que envolve apenas uma condição de afirmação, isto é, “caso seja verdadeiro, me retorne essa resposta”. No entanto, na maioria das vezes também é necessário obter uma resposta para a condição de negação. No exemplo anterior, o usuário apenas quer obter uma resposta para o caso em que o resto da divisão por 2 seja nula e não está interessado no caso contrário. Contudo, caso o usuário queira uma resposta para o caso contrário, existem algumas maneiras simples de obtê-la. Uma das maneiras mais simples para especificar tanto a condição de afirmação quanto a condição de negação é usando a condição ifelse.\nCom a condição ifelse o usuário pode especificar qual resposta deve ser retornada caso a condição imposta seja verdadeira ou falsa. Essa condição deve ser expressa da seguinte maneira: ifelse(condição, resposta caso a condição seja verdadeira, resposta caso a condição seja falsa). Para exemplificar, vamos continuar com o exemplo em que queremos saber se o número 10 é par. Agora vamos declarar que caso o resto da divisão por dois não seja zero, a resposta retornada deve indicar que se trata de um número ímpar. Para isso devemos proceder conforme a seguir:\n\nifelse(10 %%2 == 0, \"O número é par\", \"O número é ímpar\")\n\n[1] \"O número é par\"\n\n\nNote que, como o resto da divisão de dez por dois é zero, a resposta obtida foi aquela indicada para o caso em que a condição é verdadeira.\n\n\n4.1.3 Condições if e else\nAs condições if e else são apropriadas para exemplos que contêm apenas uma única condição binária (se e caso contrário). Ao contrário da condição if o uso das condições if e else simultaneamente ocorrem quando o usuário de fato está interessado nos resultados tanto do se quanto do caso contrário. A sua aplicação segue a seguinte forma funcional:\n\n#if(condição){\n#resultado caso a condição seja verdadeira} else{\n#resultado caso a condição seja falsa\n#}\n\nPara exemplificar, agora vamos aplicar esse procedimento para saber se o número 10 é par ou ímpar. Note que agora estamos interessados no caso contrário, ou seja, também queremos um resultado para o caso em que 10 não seja par, indicando que apenas a condição if já não é mais suficiente para atender os padrões da regra. Agora, a aplicação da regra baseia-se na lógica de que se o resto da divisão de 10 por 2 for zero, então 10 é um número par, do contrário, 10 é um número ímpar. Assim, a verificação de que 10 é par ou ímpar pode ser exposta da seguinte maneira:\n\nif(10 %% 2 == 0){\n  print(\"O número é par\")\n}else{\n  print(\"O número é ímpar\")\n}\n\n[1] \"O número é par\"\n\n\n\n\n4.1.4 Condição else if\nExistem casos em que é preciso aplicar não apenas uma única condição de afirmação ou negação, mas sim múltiplas condições. Esses casos são específicos para problemas que envolvem múltiplas categorias. Na existência desse tipo de ocasião, o usuário pode fazer uso das condições if e else intercalando-as com subcondições de afirmação e negação. Essas subcondições são aplicadas com o uso do else if que remete à ideia de “do contrário caso ocorra”. Por exemplo, imagine que você seja um economista encarregado de classificar as pessoas de acordo com o grau de pobreza. Suponha que você pode classificar essas pessoas nas seguintes categorias:\n\nExtremamente pobre: Se possui renda menor que meio salário mínimo.\nPobre: Se possui renda maior ou igual a meio salário mínimo e menor três salários mínimos.\nNão pobre: Se possui renda maior ou igual a três salários mínimos.\n\nA condição if e else não é adequada para esse tipo de classificação pois envolvem mais de uma condição de afirmação e negação. Agora o indivíduo pode ser ou não extremamente pobre, ser ou não ser pobre e ser ou não ser não pobre. Agora é preciso usar múltiplas condições de afirmação e negação que podem ser executadas com o else if. Essa condição possui a seguinte forma funcional:\n\n# if(condição de afirmação 1){\n#   resposta caso a condição 1 seja verdadeira\n# }else if(condição de afirmação 2){\n#   resposta caso a condição 2 seja verdadeira\n# }else if (condição de afirmação 3){\n#   resposta caso a condição 3 seja verdadeira\n# }...\n# ...\n# else{\n#   resposta caso nenhuma das condições expressas seja verdadeira\n# }\n\nPara exemplificar, vamos criar um objeto de nome num_salarios e atribuir um valor qualquer representando o número de salários mensal que essa suposta pessoa ganha para testarmos a condição de pobreza da pessoa que ganha esse valor.\n\nnum_salarios = 2.5\n\nif(num_salarios &lt; 0.5){\n  print(\"Extremamente pobre\")\n}else if(num_salarios &gt;= 0.5 & num_salarios &lt; 3){\n  print(\"Pobre\")\n}else{\n  print(\"Não pobre\")\n}\n\n[1] \"Pobre\"\n\n\nNote que, como o número de salários está entre 0.5 e 3, a resposta obtida é que a pessoa deve ser classificada como pobre.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Condições, funções e loops</span>"
    ]
  },
  {
    "objectID": "Aula4.html#funções",
    "href": "Aula4.html#funções",
    "title": "4  Condições, funções e loops",
    "section": "4.2 Funções",
    "text": "4.2 Funções\nAs funções são maneiras eficientes de programar uma tarefa para obter uma resposta de acordo com uma dada regra. As funções são ideais para aplicar regras para diferentes objetos sem precisar escrever a ordem para cada objeto separadamente. Por exemplo, imagine que você precisa fazer 1000 somas de diferentes números. Você pode somar esses números um a um ou pode automatizar essa tarefa em uma função e aplicar essa função a cada número. Nesse caso, o código só é escrito uma vez em vez de 1000.\nNa programação as funções têm a mesma lógica das funções matemáticas. Existem parâmetros de entrada em que uma regra é aplicada para retornar um produto. Por exemplo, considere o caso de uma função afim na matemática:\n\\[\ny = a + bx\n\\]\nNesse caso, os parâmetros de entrada são a, b e x, ao passo que y é o produto e a regra é a soma de a com o resultado da multiplicação entre b e x. Nessa função, é preciso conhecer os valores dos parâmetros de entrada para saber o resultado da regra aplicada. Por exemplo, se \\(a=b=x=1\\), então pela regra y deve ser igual a 2 e esse valor de y muda conforme os parâmetros mudam.\nA lógica é a mesma na programação. O usuário deve informar os parâmetros de entrada e deve indicar qual a regra para que a linguagem de programação calcule o resultado dessa regra no caso em que os parâmetros de entrada tenham os valores informados.\nEm R, as funções são objetos que devem receber um nome e ficam armazenadas no ambiente de trabalho. As funções devem ser expressas com o indicativo function. Esse indicativo é sucedido de um parênteses onde são indicados os parâmetros de entrada. Após o parênteses, a regra deve ser aplicada entre chaves, mostrando qual deve ser o resultado retornado com o indicativo input, isto é:\n\n# nome da função = function(nome do parâmetro 1, nome do parâmetro 2,...nome do parâmetro n){\n#   return(regra)\n# }\n\nPor exemplo, vamos considerar o caso da função afim indicada anteriormente. Nesse caso, deve-se proceder conforme a seguir:\n\nafim = function(a, b, x){\n  y = a + b*x\n  return(y)\n}\n\nAgora, vamos considerar o caso em que a = 1, b = 1 e x=1.\n\nafim(a = 1, b = 1, x = 1)\n\n[1] 2\n\n\nA regra funcionará para quaisquer valores de \\(a, b\\) e \\(x\\). Como um segundo exemplo, vamos programar uma função para saber se um número é par com as condições propostas anteriormente:\n\npar = function(x){\n  if(x %% 2 == 0){\n    return(\"Esse número é par\")\n  }else{\n    return(\"Esse número é ímpar\")\n  }\n}\n\nAgora podemos aplicar essa função a qualquer número e não apenas ao número 10 como vinhamos fazendo. Por exemplo, vamos checar se 1515 é par ou ímpar:\n\npar(x = 1515)\n\n[1] \"Esse número é ímpar\"\n\n\n\n4.2.0.1 Exemplo: Quanto rende o seu dinheiro?\nSuponha que você queira saber quanto rende o seus investimentos na renda fixa dadas as seguintes condições:\n\nTaxa de juros dada.\nInvestimentos possíveis: CDB, RDB, Tesouro direto, LCI, LCA, CRI, CRA, poupança e debêntures.\nIOF de 30% sobre o lucro para resgate em investimentos com prazo menor que 1 mês.\nIRPF de 22.5% sobre o lucro para resgate em investimentos com prazo de até seis meses.\nIRPF de 20.5% sobre o lucro para resgate em investimentos com prazo entre seis meses e um ano.\nIRPF de 17.5% sobre o lucro para resgate em investimentos com prazo entre um ano e três anos.\nIRPF de 15% sobre o lucro para resgate em investimentos com prazo maior que três.\nIRPF de 0% sobre poupança, LCI, LCA, CRI e CRA.\n\nPara tanto, é preciso calcular o valor futuro do investimento dado o valor inicial investido. Para isso é crucial saber qual o tipo de rendimento para aplicar a regra da função. Se o rendimento é dado com juros compostos, então o valor futuro da aplicação \\((VF)\\) é:\n\\[\nVF = VI(1+i)^t\n\\]\nEm que \\(VI\\) é o valor inicial investido, \\(i\\) é a taxa nominal de juros e \\(t\\) é o tempo para o resgate do investimento. No entanto, se os juros são fixos, o valor futuro da aplicação é:\n\\[\nVF = VI(1+i*t)\n\\]\nAssim, os parâmetros de entrada serão a taxa de juros e o tempo para o resgate enquanto a regra deve estar condicionada ao tipo de rendimento. Essas duas equações mostram o valor futuro bruto sem a dedução do imposto de renda. No caso em que se deseja obter o valor futuro líquido, é preciso multiplicar o valor futuro por \\((1-IRPF)\\) e somar o resultado com o alor inicial do investimento. Uma solução para essa tarefa pode ser feita por meio da seguinte função para aplicação em uma periodicidade anual\n\ninvest = function(vi, i, t, tipo_juro, tipo_investimento){\n  # Inicialmente valos modelar o iof\n  if(t &lt; 1/12){\n    iof = 0.3\n  }else{\n    iof = 0\n  }\n  # Agora vamos modelar o irpf\n  if(tipo_investimento != \"poupança\" | tipo_investimento != \"lci\" | tipo_investimento!= \"lca\" | tipo_investimento!= \"cri\" | tipo_investimento!= \"cra\"){\n    if(t&lt;= 0.5){\n      irpf = 0.225\n    }else if(t &gt; 0.5 & t &lt;= 1){\n      irpf = 0.205\n    }else if(t &gt; 1 & t &lt;=3){\n      irpf = 0.175\n    }else{\n      irpf = 0.15\n    }\n  }else{\n    irpf = 0\n  }\n  \n  # Agora vamos modelar o valor futuro bruto e o valor futuro líquido\n  if(tipo_juro == \"composto\"){\n    vfb = vi*(1+i)^t\n    vfl = vi + (vfb - vi)*(1-irpf)\n  }else {\n    vfb = vi*(1+i*t)\n    vfl = vi + (vfb-vi)*(1-irpf)\n  }\n  \n  resultado = c(\"Valor bruto :\", vfb, \"&lt;-&gt;\", \"Valor líquido :\", vfl)\n  \n  return(resultado)\n  \n}\n\nPara testar, vamos considerar um investimento de R$ 2.500,00 em uma LCI por cinco anos a uma taxa de juros compostos de 14% ao ano:\n\ninvest(vi = 2500, i = 0.14, t = 5, tipo_juro = \"composto\", tipo_investimento = \"lci\")\n\n[1] \"Valor bruto :\"   \"4813.536456\"     \"&lt;-&gt;\"             \"Valor líquido :\"\n[5] \"4466.5059876\"   \n\n\n\n\n4.2.0.2 Exemplo: Qual o valor da parcela do meu empréstimo?\nSuponha que você deseja tomar um empréstimo mas que está em dúvida sobre qual o valor da parcela a depender da quantidade de parcelas que você escolha. Se você toma emprestado um valor \\(F\\) a uma taxa de juros \\(j\\) e deseja pagar em \\(n\\) parcelas utilizando o sistema Price de amortização, então o valor de cada parcela \\((VP)\\) é dado por:\n\\[\nVP = \\frac{F*j}{1-(1+j)^{-n}}\n\\]\nNesse caso, os parâmetros de entrada são o valor principal do empréstimo, a taxa de juros e o número de parcelas. A regra a ser aplicada na função é a relação indicada na equação de \\(VP\\) que retornará o valor de cada parcela. Portanto, vamos criar uma função e nomeá-la de valor_parcela para aplicar essa regra e conhecermos o valor de cada parcela de um financiamento.\n\nvalor_parcela = function(f, j, n){\n  vp = f*j/(1-(1+j)^(-n))\n  return(vp)\n}\n\nPara exemplificar, suponha que você precise de um empréstimo de R$ 10.000,00 e que a taxa de juros vigente seja de 1.2% ao mês. Se você quer pagar em 48 parcelas, então o valor de cada parcela será:\n\nvalor_parcela(f = 10000, j = 0.012, n = 48)\n\n[1] 275.2755",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Condições, funções e loops</span>"
    ]
  },
  {
    "objectID": "Aula4.html#loops",
    "href": "Aula4.html#loops",
    "title": "4  Condições, funções e loops",
    "section": "4.3 Loops",
    "text": "4.3 Loops\nUm loop (ou laço) é uma estrutura de controle que permite executar repetidamente um bloco de código enquanto uma condição for verdadeira ou por um número determinado de vezes. Os Loops são usados para:\n\nRepetir tarefas automaticamente (como imprimir uma lista de nomes)\nProcessar grandes volumes de dados\nEvitar repetição manual de código\n\nExistem várias possibilidades de loops, cada uma delas com as suas propriedades e as suas respectivas aplicações. Cabe ao usuário conhecer as necessidades de cada caso e as propriedades de cada loop.\n\n4.3.1 Loop for\nUm loop for é uma estrutura de repetição que executa um bloco de código um número determinado de vezes. Esse tipo de loop é ideal quando o usuário sabe previamente quantas vezes deseja repetir uma ação. Por exemplo, imagine o caso exemplificado anteriormente do valor da parcela de um financiamento. Suponha que o usuário deseja saber o valor da parcela caso ele opte por pagar desde 24 até 48 parcelas. Em vez de calcular a função para cada valor vez após vez é mais prático usar o loop do tipo for para aplicar a função criada para o conjunto que abrange os números entre 24 e 48. O loop for deve ser usado com a seguinte forma funcional:\n\n for(indexador in conjunto){\n   regra aplicada ao indexador\n }\n\nO indexador é um índice que indexa os valores do conjunto em que a regra será aplicada, de modo que o nome desse indexador deve ser informado pelo usuário. Por exemplo, vamos imprimir cada \\(i\\)-ésimo número do conjunto de números entre 1 e 5:\n\nfor(i in 1:5){\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nAgora vamos aplicar o loop for para o caso em que o usuário queira saber o valor da parcela do financiamento caso ele opte por pagar entre 24 e 48 parcelas:\n\nfor(i in 24:48){\n  print(valor_parcela(f = 10000, j = 0.012, n = i))\n}\n\n[1] 482.0207\n[1] 465.373\n[1] 450.015\n[1] 435.8033\n[1] 422.6153\n[1] 410.3448\n[1] 398.9003\n[1] 388.2017\n[1] 378.1792\n[1] 368.7712\n[1] 359.9235\n[1] 351.5881\n[1] 343.7223\n[1] 336.288\n[1] 329.2511\n[1] 322.5811\n[1] 316.2504\n[1] 310.2343\n[1] 304.5101\n[1] 299.0576\n[1] 293.8583\n[1] 288.8952\n[1] 284.1529\n[1] 279.6173\n[1] 275.2755\n\n\n\n\n4.3.2 Loop while\nO loop while é ideal para ser utilizado quando uma operação deve ser aplicada repetidas vezes até que uma dada condição ocorra. Por exemplo, imagine que você queira calcular \\(y = 2^n\\) em que \\(n\\) são os elementos do conjunto dos números naturais e uponha que você quer fazer isso até que \\(y\\) alcance o valor de 10.000. Nesse caso, enquanto \\(y &lt; 10.000\\) a regra deve ser aplicada, ao passo que quando \\(y\\) atingir o valor de 10.000 a operação é abortada. Nesse caso, o loop while é adequado para tal operação e pode ser usado mais eficientemente do que o loop for.\nA aplicação do loop while deve seguir a seguinte forma funcional:\n\n while (condição) {\n   regra\n }\n\nPor exemplo, no caso da potenciação especificada anteiormente, deve-se proceder conforme a seguir:\n\nn = 0\ny = 2^n\nwhile (y &lt; 10000) {\n  y = 2^n\n  print(n)\n  n = n +1\n}\n\n[1] 0\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n\n\nNote que foi preciso criar um objeto \\(n=0\\) e adicionar 1 ao final de cada verificação. Em alguns casos isso é um procedimento necessário.\nOBS: Um loop while pode ser infinito caso a condição seja TRUE. Nesse caso, para parar o loop é preciso executar a função break.\n\n4.3.2.1 Exemplo: Quantos bilhetes devo jogar para acertar na lotofácil\nA lotofácil é uma loteria da caixa econômica federal que consiste no sorteio de quinze números entre 1 e 25. O apostador pode fazer uma aposta mínima de quinze números ou realizar uma aposta com mais números. No concurso nº 3641, realizado no dia 05/08/2025 as dezenas sorteadas foram 02, 03, 04, 05, 06, 08, 09, 10, 11, 13, 18, 19, 21, 23, 25. Apostando 17 números, quantos sorteios aleatórios devem ser feitos para acertar pontualmente essas dezenas?\nPara responder, podemos pedir que o computador faça sorteios aleatórios até acertar exatamente esses números. Em R, sorteios aleatórios são realizados com a função sample. Assim, podemos criar um loop while e pedir que o computador não pare de fazer sorteios aleatórios até que ele acerte os números sorteados no concuros 3641 da lotofácil:\n\n# Primeiro vamos criar um vetor com as dezenas sorteadas\nsorteio = c(2, 3, 4, 5,6, 8,9, 10,11, 13,18, 19, 21,23,25)\n# Agora vamos criar o indexador do loop para contar quantos sorteios foram feitos\nn = 1\n# Agora vamos criar o loop while\nwhile (TRUE) {\n  # vamos sortear 17 números entre 1 e 25 sem possibilidade de repetição\n  aposta = sample(x = 1:25, size = 17, replace = FALSE)\n  # Agora vamos ordenar a aposta na ordem crescente\n  aposta = sort(aposta)\n  if(FALSE %in% c(sorteio %in% aposta)){\n    n = n +1\n  }else{\n    print(n)\n    break\n  }\n}\n\n[1] 41806",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Condições, funções e loops</span>"
    ]
  },
  {
    "objectID": "Aula4.html#exercício-1",
    "href": "Aula4.html#exercício-1",
    "title": "4  Condições, funções e loops",
    "section": "4.4 Exercício 1",
    "text": "4.4 Exercício 1\n(i) Tempo restante para a aposentadoria: Considere que uma pessoa pode se aposentar pelo sistema público de previdência caso obedeça as seguintes condições:\n\nIdade mínima de 65 anos e no mínimo 35 anos de contribuição caso seja do sexo masculino.\nIdade mínima de 62 anos e no mínimo 30 anos de contribuição caso seja do sexo feminino.\nIdade mínima para começar a trabalhar: 14 anos.\n\nCrie uma função para computar quanto tempo falta para a aposentadoria conforme a idade e o tempo de serviço. Ajuste a função para que a pessoa não possa informar valores irreais para o seu tempo de trabalho e de contribuição para a sua idade atual.\n(ii) Considere que um homem começou a trabalhar com 28 anos e a partir desse ponto nunca esteve desempregado. Use um while for para fazer uma contagem regressiva de quanto tempo falta para ele se aposentar conforme os anos passam. Pare o loop quando a contagem regressiva chegar a zero.\n(iii) Crie uma função para indicar se um número é primo e use um loop for para verificar quais os números inteiros entre 1 e 1000 são primos.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Condições, funções e loops</span>"
    ]
  },
  {
    "objectID": "Aula4.html#exercício-2",
    "href": "Aula4.html#exercício-2",
    "title": "4  Condições, funções e loops",
    "section": "4.5 Exercício 2",
    "text": "4.5 Exercício 2\nO código a seguir traz uma versão bastante rústica de um jogo da forca. Nesse jogo, o sistema sorteia uma dentre quatro palavras pré-definidas. O jogador tem cinco chances para acertar a palavra sorteada e deve indicar uma letra que ele julga que esteja presente na palavra em cada chance. A cada chance, se o jogador não acertar a palavra, um degrau a mais da forca é acionado. Na quinta chance, se o jogador não acertar a palavra oculta ele perde o jogo e é “enforcado”.\n\ndesenho = c(\n  \"   ===============\n    ||              I              \n    ||              \n    ||\n    ||\n    ||\n    ||              O\n    ||             /|\\\n    ||             / \\\n    ||             VIVO\n    ||\n   /  \\\n  /    \\\n  --------------------\n  \",\n  \"   ===============\n    ||              I\n    ||              I\n    ||\n    ||\n    ||\n    ||              O\n    ||             /|\\\n    ||             / \\\n    ||             VIVO\n    ||\n   /  \\\n  /    \\\n  --------------------\n  \",\n  \"   ===============\n    ||              I\n    ||              I\n    ||              I\n    ||\n    ||\n    ||              O\n    ||             /|\\\n    ||             / \\\n    ||             VIVO\n    ||\n   /  \\\n  /    \\\n  --------------------\n  \",\n  \"   ===============\n    ||              I\n    ||              I\n    ||              I\n    ||              I\n    ||\n    ||              O\n    ||             /|\\\n    ||             / \\\n    ||             VIVO\n    ||\n   /  \\\n  /    \\\n  --------------------\n  \",\n  \"   ===============\n    ||              I\n    ||              I\n    ||              I\n    ||              I\n    ||              I\n    ||              O\n    ||             /|\\\n    ||             / \\\n    ||          ENFORCADO\n    ||\n   /  \\\n  /    \\\n  --------------------\n  \n  Você perdeu a partida\n  \"\n)\n\n\npalavras = c(\"caminhonete\", \"esquisofrenia\", \"geladeira\", \"juventude\")\n\nsegredo = sample(palavras, 1)\ntracos = rep(\"__\", nchar(segredo))\nletras = c()\npalavras_chutadas = c()\n\nfor(i in 1:5){\n  print(tracos)\n  chute = readline(\"Indique uma letra: \")\n  while(chute %in% letras){\n    cat(\"Você já escolheu essa letra\")\n    chute = readline(\"Indique uma letra: \")\n  }\n  letras = rbind(letras, chute)\n  for(j in 1:nchar(segredo)){\n    if(chute == substr(segredo, j, j)){\n      tracos[j] = chute\n      print(tracos)\n    }\n  }\n  sabe = readline(\"Conhece a palavra? \")\n  if(sabe == \"sim\"){\n    resposta = readline(\"Indique qual é a palavra: \")\n    while (resposta %in% palavras_chutadas) {\n      cat(\"Você já chutou essa palavra\")\n      resposta = readline(\"Indique qual é a palavra: \")\n    }\n    palavras_chutadas = rbind(palavras_chutadas, resposta)\n    if(resposta == segredo){\n      cat(\"\\n----------------------------------------------------\\n\")\n      cat(\"------------------Resposta correta----------------------\\n\")\n      cat(\"------------------Você ganhou o jogo--------------------\\n\")\n      cat(\"\\n----------------------------------------------------\\n\")\n      break\n    }else{\n      cat(\"Resposta errada\")\n      cat(desenho[i])\n    }\n  }else{\n    cat(desenho[i])\n  }\n}\n\n(i) Analise o código e busque entender o papel dos loops e das condições no jogo. O código tem alguns erros e alguns bugs propositalmente inseridos, corrija-os caso os encontre.\n(ii) Insira mais quatro palavras no jogo e aumente o número de chances para seis.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Condições, funções e loops</span>"
    ]
  },
  {
    "objectID": "Aula5.html",
    "href": "Aula5.html",
    "title": "5  Leitura de dados",
    "section": "",
    "text": "5.1 O problema da memória\nTendo visto os fundamentos básicos da programação em R, o próximo passo é aprender a efetuar a leitura de informações para o uso posterior na linguagem. Os dados são a estrutura básica das mais variadas ferramentas interativas geradas pela programação e também consistem na ferramenta fundamental para as constatações científicas empíricas, seja na economia, seja em qualquer outra ciência.\nOs dados são armazenados em diversos tipos de arquivo, cada um deles com as suas respectivas propriedades e usuabilidade. Cada tipo de arquivo possui características que precisam ser levadas em consideração, seja na hora de elaborar uma base de dados do zero, seja na hora de ler uma base de dados pronta. Cabe ao usuário conhecer cada uma dessas propriedades e estar pronto para lidar com as particularidades dos mais variados tipos de arquivos.\nNesse capítulo, iremos conhecer as propriedades dos principais tipos de arquivos comumente utilizados para armazenar informações. Também aprenderemos sobre os principais tipos de dados e os seus possíveis usos. Por fim, serão expostas as principais técnicas que possibilitam a importação e a leitura de bases de dados previamente prontas para a linguagem R. O objetivo principal desse capítulo é repassar ao estudante o conhecimento necessário para que ele possa dominar a leitura de bases de dados em R por meio do domínio de técnicas de importação dos mais variados tipos de arquivo.\nUm dos principais desafios enfrentados na construção de bases de dados é o tamanho dos arquivos. Processar grandes bases de dados exige um grande poder computacional uma vez que, quanto maior o volume de informações, maior é a requisição de memória computacional para realizar o processamento.\nUma base de dados geralmente é composta por objetos que são formados por linhas e colunas. Cada linha e cada coluna adicionada em um objeto aumenta o seu tamanho e por consequência aumenta também a quantidade de memória computacional necessária para processar essas informações. Em vista desse problema, a engenharia de dados está em uma busca constante por soluções que permitam reduzir o tamanho dos arquivos ou a quantidade de memória necessária para processá-lo. Uma das soluções mais fáceis e rápidas para tal é escolher um tipo de arquivo adequado para armazenar as informações. Por exemplo, bases de dados com poucas linhas e poucas colunas podem facilmente ser armazenadas em um arquivo excel, pois apesar de ser uma extensão que exige mais memória, o baixo volume de informações não impedirá um usuário use essa base de dados mesmo com uma máquina com baixo poder computacional. Em contrapartida, uma máquina comum com baixa capacidade de processamento terá dificuldades para gerenciar uma base de dados com inúmeras linhas e colunas armazenadas em um arquivo desse tipo.\nEm vista desses conceitos, esse material lista a seguir as principais extensões de arquivos utilizados para armazenar informações nas bases de dados, esclarecendo as suas principais propriedades e usuabilidades, além de demosntrar as técnicas necessárias para abrir esses arquivos na linguagem R.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#arquivos-nativos-da-linguagem-r",
    "href": "Aula5.html#arquivos-nativos-da-linguagem-r",
    "title": "5  Leitura de dados",
    "section": "5.2 Arquivos nativos da linguagem R",
    "text": "5.2 Arquivos nativos da linguagem R\nA linguagem R possui duas extensões de arquivos nativas, a extensão .Rdata e a extensão .Rds. Quando o usuário possui múltiplos objetos no seu ambiente de trabalho e deseja salvar todos esses objetos em um único arquivo, então o ideal é usar a extensão .Rdata. Esse procedimento também é conhecido como “salvar objetos como imagem”. Nesse caso, o usuário pode salvar o seu ambiente de trabalho completo ou parte dele em um único arquivo que poderá ser usado posteriormente. Para demonstrar, vamos importar três bases de dados nativas para o ambiente de trabalho:\n\nbase1 = mtcars\nbase2 = CO2\nbase3 = ChickWeight\n\nImagine que seja necessário salvar todo o ambiente de trabalho com as três bases de dados incluídas nele em um único arquivo. Nesse caso, salvar como uma imagem .Rdata pode ser a melhor alternativa. Para tanto, o primeiro passo é informar à linguagem em qual pasta da sua máquina os arquivos devem ser salvos. Isso é feito indicando um diretório de trabalho por meio do comando setwd(), indicando dentro do parênteses a pasta de interesse entre aspas. Nota: no sistema Windows as barras à esquerda devem sempre ser substituídas por barras duplas na fixação do diretório de trabalho.\n\nsetwd(\"Endereço da pasta em que os arquivos serão salvos\")\n\nApós fixar o diretório de trabalho, o próximo passo é salvar o diretório de trabalho como imagem .Rdata. Para tanto, deve-se usar o comando save.image() e indicar o nome pelo qual o arquivo será salvo sucedido do indicativo do formato .Rdata. Por exemplo, imagine que queiramos salvar todo o ambiente de trabalho com o nome bases_de_dados. Nesse caso, deve-se proceder da seguinte maneira:\n\nsave.image(\"bases_de_dados.Rdata\")\n\nUma vez que o arquivo está salvo no seu diretório de trabalho com a extensão .Rdata, para importá-lo para a linguagem R basta usar o comando load() indicando no parênteses e entre aspas o nome do arquivo que será importado.\n\nload(\"bases_de_dados.Rdata\")\n\nJá a extensão .rds é aplicada quando o usuário quer salvar um único arquivo do ambiente de trabalho no diretório da sua máquina. Diferente da extensão .Rdata, na extensão .rds o salvamento dos arquivos ocorre com o comando saveRDS(), onde dentro do parênteses deve ser indicado o nome do objeto que está no ambiente de trabalho e que será salvo, sucedido do nome pelo qual o usuário deseja salvar o arquivo. Por exemplo, imagine que queiramos salvar o objeto de nome base1 com o nome base1.rds. Nesse caso, devemos proceder conforme indicado a seguir:\n\nsaveRDS(base1, file = \"base1.rds\")\n\nUma vez que o objeto está salvo com a extensão .rds na sua máquina, para importá-lo para a linguagem R basta usar o comando readRDS(), indicando no parênteses e entre aspas o nome do arquivo de interesse. Por exemplo, para ler o arquivo salvo com o nome base1.rds deve-se proceder conforme indicado a seguir:\n\nreadRDS(\"base1.rds\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#arquivos-em-formato-.csv",
    "href": "Aula5.html#arquivos-em-formato-.csv",
    "title": "5  Leitura de dados",
    "section": "5.3 Arquivos em formato .csv",
    "text": "5.3 Arquivos em formato .csv\nOs arquivos .csv geralmente são utilizados para guardar informações textuais, ou seja, são ideais para armazenar textos. Assim, um arquivo nessa extensão sempre terá uma única coluna, podendo conter, entretanto, múltiplas linhas. No entanto, esse tipo de arquivo pode ser utilizado para armazenar informações em múltiplas colunas desde que essas colunas estejam dispersas em uma única coluna comum sendo separadas por um separador. Por exemplo, considere a tabela a seguir:\n\n\n\nNome\nIdade\nSexo\n\n\n\n\nJoão\n28\nM\n\n\nMaria\n26\nF\n\n\nAna\n21\nF\n\n\n\nEm uma estrutura de texto, todas essas informações estariam unidas na mesma coluna, isto é:\n\n\n\nNomeIdadeSexo\n\n\n\n\nJoão28M\n\n\nMaria26F\n\n\nAna21F\n\n\n\nEm uma estrutura do tipo .csv todas as informações também estarão na mesma coluna, porém, o final de cada coluna pode ser identificado por um separador de colunas. Para exemplificar, suponha que no caso do exemplo anterior esse separador seja a vírgula. Nesse caso, a tabela anterior passa a ser escrita como:\n\n\n\nNome,Idade,Sexo\n\n\n\n\nJoão,28,M\n\n\nMaria,26,F\n\n\nAna,21,F\n\n\n\nComo esse separador de colunas éconhecido, então fica fácil reconhecer as informações armazenadas nesse arquivo de texto.\nEm R, a leitura de arquivos no formato .csv pode ser feita de diferentes maneiras. Uma das formas mais comuns de executar essa tarefa é por meio do uso da função read.csv que é uma função nativa e não necessita de instalação. O uso da função deve obedecer a seguinte forma funcional:\n\nread.csv(\n  \"Endereço/nome do arquivo.csv\",\n  header = TRUE, # TRUE se a primeira linha indica o nome das colunas e FALSE caso contrário\n  sep = \",\" # aqui o separador de colunas deve ser indicado entre aspas\n)\n\n\n5.3.1 Exemplo: Importando dados via link url\nPara exemplificar, considere a planilha de registros fictícios de clientes disponível no endereço https://drive.google.com/uc?id=1zO8ekHWx9U7mrbx_0Hoxxu6od7uxJqWw&export=download. A planilha possui 100 linhas, cada uma delas correspondendo às informações de um cliente específico. Caso o usuário baixe esse arquivo em sua máquina e abra esse arquivo em um editor de texto, notará que as colunas estão delimitadas por uma vírgula. Vamos importar esse arquivo no formato de um data frame nomeando-o de “clientes”.\n\nclientes = read.csv(\n  file = \"https://drive.google.com/uc?id=1zO8ekHWx9U7mrbx_0Hoxxu6od7uxJqWw&export=download\",\n  header = TRUE, # indicando que a primeira linha contém o nome das colunas\n  sep = \",\", # indicando que as colunas estão separadas por vírgula\n  dec = \".\" #indicando que o separador decimal é o ponto\n)\n\nhead(clientes) # mostra as primeiras linhas da planilha\n\nCaso esse arquivo esteja em uma pasta do seu computador em vez de um link url, etão no parâmetro file você deverá proceder como file = Endereço da pasta que contém o arquivo/nome do arquivo.csv”.\nAgora considere essa mesma planilha disponível no endereço https://drive.google.com/uc?id=1vPCLNpy6LEhHDvQlHtFBu5L2QzB5bTnv&export=download. Note que se replicarmos o script anterior alterando o endereço para esse link um erro será reportado. Isso ocorre porque nesse caso há um cabeçalho na planilha, isto é, existem linhas na parte superior da planilha que não possuem as mesmas especificações textuais do restante do csv e devem ser desconsideradas no ato da importação. Em outras palavras, as linhas do cabeçalho precisam ser “puladas”. Isso é feito por meio do parâmetro skip dentro da função read.csv. Esse parâmetro recebe a quantidade de linhas que precisam ser puladas. Como o cabeçalho desse exemplo possui duas linhas, então deve-se adicionar skip = 2 no comando, ou seja:\n\nclientes = read.csv(\n  file = \"https://drive.google.com/uc?id=1vPCLNpy6LEhHDvQlHtFBu5L2QzB5bTnv&export=download\",\n  header = TRUE, # indicando que a primeira linha contém o nome das colunas\n  sep = \",\", # indicando que as colunas estão separadas por vírgula\n  dec = \".\", #indicando que o separador decimal é o ponto\n  skip = 2 # Pula as duas primeiras linhas da planilha\n)\n\nhead(clientes) # mostra as primeiras linhas da planilha\n\nO usuário pode testar que quando skip &lt; 2, o erro será reportado mesmo assim, ao passo que quando skip &gt; 2, a importação funciona, porém, ajustes precisam ser feitos para que o nome das colunas apareça de maneira correta no data frame.\nÉ importante ressaltar que a função read.csv possui vários outros parâmetros além desses aqui especificados. O usuário pode checar as demais possibilidades de uso de parâmetros da função executando o comando ?read.csv.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#arquivos-excel-.xlsx",
    "href": "Aula5.html#arquivos-excel-.xlsx",
    "title": "5  Leitura de dados",
    "section": "5.4 Arquivos excel (.xlsx)",
    "text": "5.4 Arquivos excel (.xlsx)\nOs arquivos gerados no excel têm linhas e colunas bem definidas e por isso costumam ser maiores do que os arquivos em formato .csv. Ao contrário dos arquivos .csv que são usados para armazenar texto, os arquivos do excel podem guardar informações de diversos formatos com grande utilidade. Esses arquivos remetem à ideia central de um data frame (quadro de dados), onde as linhas representam os indivíduos observados e as colunas mostram as características desses indivíduos.\nExistem várias maneiras de importar arquivos .xlsx para a linguagem R, porém, esse material recomenda o uso da biblioteca openxlsx. Essa biblioteca foi criada especialmente para abrir arquivos com esse formato em R e as suas especificações de uso podem ser acessadas em https://cran.r-project.org/web/packages/openxlsx/openxlsx.pdf.\nComo vamos utilizar uma biblioteca não nativa, o primeiro passo para possibilitar o uso é fazer a instalação da biblioteca. O usuário pode consultar se a biblioteca já está instalada na sua máquina acessando no Rstudio a aba Packages e procurando pelo nome da biblioteca na guia de busca. Ou pode checar se a biblioteca está instalada usando o seguinte comando:\n\n\"openxlsx\" %in% installed.packages()\n\nSe o output for FALSE, significa que a biblioteca precisa ser instalada. Nesse caso, deve-se usar a função install.packages(), indicando dentro do parênteses e entre aspas o nome da biblioteca que se deseja instalar. Nesse caso, deve-se proceder conforme a seguir:\n\ninstall.packages(\"openxlsx\")\n\nTendo instalado a biblioteca, o próximo passo é liberá-la para o uso. Isso é feito por meio da função library(), indicando dentro do parênteses e entre aspas o nome da biblioteca que se deseja liberar para o uso. Nesse caso, deve-se proceder conforme a seguir:\n\nlibrary(openxlsx)\n\nPara abrir um arquivo com extensão .xlsx com a biblioteca openxlsx, deve-se usar a função read.xlsx. O usuário pode consultar as instruções de uso dessa função executando o comando ?openxlsx. Basicamente, essa função tem a seguinte estrutura de uso:\n\nread.xlsx(\n  xlsxFile = \"endereço do arquivo/nome do arquivo.xlsx\",\n  startRow = \"Número da linha em que começa a planilha\",\n  sheet = \"Número ou nome da planilha contida no arquivo\",\n  colNames = \"TRUE se a primeira linha mostra os nomes das colunas e FALSE caso contrário\"\n)\n\nPara demonstrar, considere que precisamos importar uma planilha com os valores nominais do PIB dos estados do Brasil desde 2002 até 2021 e que essa tabela está disponível no endereço https://drive.google.com/uc?id=1d9dyf5gh4GIdP2YX77b-Q0paAzar0O6b&export=download. As primeiras três linhas da planilha compõem o cabeçalho e devem ser desconsideradas, isto é, a planilha só inicia de fato na linha 4. Assim, a importação deve ser feita conforme a seguir:\n\npib = read.xlsx(\n  xlsxFile = \"https://drive.google.com/uc?id=1d9dyf5gh4GIdP2YX77b-Q0paAzar0O6b&export=download\",\n  startRow = 4,\n  colNames = TRUE,\n  sheet = 1\n)\nhead(pib)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#arquivos-excel-.xls",
    "href": "Aula5.html#arquivos-excel-.xls",
    "title": "5  Leitura de dados",
    "section": "5.5 Arquivos excel (.xls)",
    "text": "5.5 Arquivos excel (.xls)\nOs arquivos com extensão .xls são visivelmente semelhantes aos arquivos com extensão .xlsx, inclusive, com as mesmas funcionalidades. A principal diferença entre essas extensões está na estrutura computacional pela qual as duas extensões são formadas. Enquanto os arquivos .xls são criados em uma estrutura binária simples, os arquivos .xlsx. possuem uma ideia de estruturação mais sofisticada e segura baseado em XML. Em termos práticos, a extensão .xls era usada em versões antigas do pacote office, em versões iguais ou anteriores ao Excel 2003. Já a extensão .xlsx passou a ser implementada no excel a partir do office 2007.\nAssim como no caso dos arquivos .xlsx, recomenda-se o uso de uma biblioteca para a importação dos arquivos .xls para a linguagem R. Nesse caso, recomenda-se a biblioteca readxl, a qual possui suas suas especificações de uso detalhadas em https://cran.r-project.org/web/packages/readxl/readxl.pdf e instruções exemplificadas de uso em https://readxl.tidyverse.org/.\nOs passos são os mesmos indicados na biblioteca utilizada para abrir arquivos .xlsx, ou seja, deve-se verificar se a biblioteca está previamente instalada e proceder com a instalação caso não esteja. Tendo feito a instalação, deve-se liberar a biblioteca para o uso conforme especificado a seguir:\n\ninstall.packages(\"readxl\")\n\n\nlibrary(readxl)\n\nPara importar aquivos na extensão .xls, recomenda-se o uso da função read_xls(). Um detalhe importante a ser esclarecido é que no caso da biblioteca readxl, não é possível importar arquivos diretamente da url, nesse caso, é preciso baixar o arquivo na sua máquina e em seguida usar o endereço da pasta em que o arquivo foi baixado em vez da url. Outra saída é baixar o arquivo em uma pasta temporária criada pelo R e em seguida realizar a importação a partir dessa pasta, que é o que será feito aqui.\nBasicamente, a função read_xls() possui a seguinte especificação de uso:\n\nread_xls(\n  path = \"endereço/nome do arquivo.xls\",\n  sheet = \"número da planilha\",\n  col_names = \"TRUE se a primeira linha mostra os nomes das colunas e FALSE caso contrário\",\n  skip = \"número de linhas que devem ser puladas\"\n)\n\nPara exemplificar, considere a mesma planilha do PIB dos estados especificada no exemplo anterior, porém, no formato .xls, disponível no link https://drive.google.com/uc?id=141Tws9jifN8Lk4OpuyHpc9dATED9eZKC&export=download. Inicialmente, vamos criar uma pasta temporária e baixar essa planilha nessa pasta. Porém, o usuário pode baixar o arquivo em uma pasta do seu computador sem a necessidade de realização desse passo:\n\nurl &lt;- \"https://drive.google.com/uc?id=141Tws9jifN8Lk4OpuyHpc9dATED9eZKC&export=download\"\ndestfile &lt;- tempfile(fileext = \".xls\") # criando a pasta e nomeando-a de destfile\ndownload.file(url, destfile, mode = \"wb\") # baixando o xls na pasta criada\n\nTendo criado a basta e baixado o arquivo nela, o próximo passo é ler esse arquivo. Para tanto, deve-se proceder conforme a seguir:\n\npib = read_xls(\n  path = destfile,\n  skip = 3,\n  col_names = TRUE,\n  sheet = 1\n)\n\nhead(pib)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#dados-em-coluna-fixa",
    "href": "Aula5.html#dados-em-coluna-fixa",
    "title": "5  Leitura de dados",
    "section": "5.6 Dados em coluna fixa",
    "text": "5.6 Dados em coluna fixa\nO armazenamento de dados em coluna fixa geralmente é feito em um padrão textual, com uma estrutura semelhante aos arquivos .csv, porém, com o detelhe de que as colunas não estão separadas e não possuem um separador. No caso dos dados em coluna fixa, cada coluna possui um tamanho que corresponde ao número máximo de caracteres que a coluna pode agrupar. Por exemplo, supõe-se que nenhum humano pode chegar a uma idade de quatro dígitos, mas que é possível atingir uma idade de três dígitos. Assim, uma coluna contendo a idade das pessoas deverá ter um tamanho 3 que é o número máximo de caracteres possíveis de se agrupar nessa coluna.\nCada coluna também tem uma posição inicial e uma posição final que corresponde ao número de caracteres da linha onde a coluna começa e termina. Para exemplificar, considere a tabela a seguir contendo a idade e o sexo de cinco pessoas identificadas por um id:\n\n\n\nID\nIdade\nSexo\n\n\n\n\n1\n25\nM\n\n\n2\n28\nM\n\n\n3\n65\nF\n\n\n4\n75\nM\n\n\n5\n101\nF\n\n\n\nCaso esses dados sejam agrupados na estrutura de coluna fixa, eles passam a ter apenas uma coluna disposta da seguinte maneira:\n\n\n\n1025M\n\n\n2028M\n\n\n3065F\n\n\n4075M\n\n\n5101F\n\n\n\nA primeira coluna só possui um caracter, começa na posição inicial 1, termina na posição final 1 e tem tamanho 1. A segunda coluna possui 3 caracteres, começa na posição inicial 2, termina na posição final 4 e tem tamanho 3. A terceira coluna possui apenas um caracter começa na posição inicial 5, termina na posição final 5 e tem tamanho 1. Geralmente os arquivos de dados em coluna fixa dispõem de um dicionário indicando qual a posição inicial, a posição final e o tamanho das colunas.\nEsse tipo de estrutura é comumente utilizada pelo IBGE em suas pesquisas pela capacidade de armazenar mais informações em menos espaço no computador. Como exemplo, a Pesquisa Nacional Por Amostra de Domicílios Contínua (PNAD-Contínua) utiliza essa estrutura de armazenamento de dados.\nPara importar esse tipo de arquivo na forma de um data frame no R também é recomendado utilizar uma biblioteca externa. O presente material recomenda o uso da biblioteca readr. Os passos são os mesmos indicados nas bibliotecas anteriores, ou seja, deve-se verificar se a biblioteca está previamente instalada e proceder com a instalação caso não esteja. Tendo feito a instalação, deve-se liberar a biblioteca para o uso conforme especificado a seguir:\n\ninstall.packages(\"readr\")\n\n\nlibrary(readr)\n\nPara ler os arquivos em coluna fixa, recomenda-se o uso da função read_fwf(), a qual possui a seguinte esttrutura de uso:\n\nread_fwf(\n  file = \"Endereço/nome do arquivo.extensão do arquivo\",\n  fwf_cols(\n    nome da coluna = c(posição inicial, posição final)\n  )\n)\n\nPara exemplificar, vamos usar os dados da PNAD-Contínua trimestral referente ao segundo trimestre de 2024. Para tanto, defina um diretório no computador e crie uma pasta com um dado nome. Aqui, vamos nomeá-la de pnad2024. Em seguida, fixe o diretório de trabalho nessa pasta com a função setwd() conforme especificado a seguir:\n\nsetwd(\"D:/pnad2024\")\n\nEm seguida, acesse o endereço https://www.ibge.gov.br/estatisticas/downloads-estatisticas.html?caminho=Trabalho_e_Rendimento/Pesquisa_Nacional_por_Amostra_de_Domicilios_continua/Trimestral/Microdados/2024 e baixe o arquivo nomeado PNADC_022024.zip na pasta criada anteriormente. Clique com o botão direito no arquivo baixado e escolha a opçao “extrair aqui” (Obs: é preciso ter um programa de gerenciamento de arquivos compactados instalado na sua máquina).\nPara ter acesso ao dicionário indicando os detalhes sobre a posição e o tamanho das colunas, acesse o endereço https://www.ibge.gov.br/estatisticas/downloads-estatisticas.html?caminho=Trabalho_e_Rendimento/Pesquisa_Nacional_por_Amostra_de_Domicilios_continua/Trimestral/Microdados/Documentacao e baixe o arquivo de nome Dicionario_e_input_20221031.zip. Em seguida, clique com o botão direito sobre esse arquivo e escolha a opção “extrair aqui”. O dicionário é o arquivo de nome dicionario_PNADC_microdados_trimestral.xls.\nAo abrir o dicionário, o usuário irá se deparar com os detalhes técnicos da pesquisa, incluindo o nome das colunas, a descrição da coluna e o significado dos valores. A primeira coluna do dicionário a posição inicial de cada coluna enquanto a segunda coluna do dicionário mostra o tamanho. Para saber a posição inicial, basta fazer posição inicial + tamanho - 1. Por exemplo, a posição final da coluna trimestre de referência é 5 + 1 - 1 = 5.\nPara demonstrar o processo de importação, vamos importar as quatro primeiras colunas da pesquisa: Ano, Trimestre, UF e Capital. Os procedimentos estão demonstrados a seguir:\n\npnad2024 = read_fwf(\n  file = \"PNADC_022024.txt\",\n  fwf_cols(\n    Ano = c(1,4),\n    Trimestre = c(5, 5),\n    UF = c(6,7)\n  )\n)\n\n\nhead(pnad2024)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#dados-geográficos",
    "href": "Aula5.html#dados-geográficos",
    "title": "5  Leitura de dados",
    "section": "5.7 Dados geográficos",
    "text": "5.7 Dados geográficos\nDados geográficos - ou em outra notação, dados georreferenciados - são uma categoria de informações em que uma das dimensões observadas está associada a uma dada localização geográfica. Essas informações podem ser dispostas de várias maneiras, por exemplo, cada indivíduo pode estar associado a um ponto de coordenadas geográficas em um plano cartesiano, da mesma forma que em vez de um ponto específico, os indivíduos podem estar associados a um polígono ou a uma área delimitada dentro do plano cartesiano.\nOs dados georreferenciados podem ser disponibilizadas em várias extensões de arquivos a depender do tipo de informação que esses arquivos carregam. Por exemplo, dados climáticos como a temperatuda da atmosfera no decorrer do dia geralmente são armazenados em um arquivo de imagem georreferenciada com extensão .tif. No entanto, nesse material vamos direcionar os nossos esforços para dominar a importação de um tipo de arquivo, os shapefiles.\nShapefiles são tabelas de dados em que cada linha da tabela carrega uma informação correspondente a um ponto ou polígono no espaço. Por exemplo, imagine um mapa que mostra o PIB dos municípios brasileiros. Esse mapa provém de um shapefile onde cada linha representa um município que é uma polígono definido no espaço. Um shapefile geralmente depende da construção de quatro arquivos, sendo os dois principais com extensão .dbf e .shp. O arquivo com extensão .dbf carrega a planilha com as informações associadas aos indivíduos referenciados no espaço, os quais estão “desenhados” no arquivo com extensão .shp. Os demais arquivos do shapefile interligam essas duas extensões para que cada linha do .dbf seja corretamente associada a um indivíduo no arquivo .shp.\nApesas de existirem maneiras bastante simples de construir um shapefile, os economistas geralmente usam arquivos prontos que são elaborados por institutos de pesquisa ou órgãos competentes com a devida confiança. Como exemplo, o IBGE disponibiliza uma série de shapefiles em seu sistema de malhas cartográficas disponíveis aqui. O IPEA também disponibiliza um sistema semelhante que pode ser acessado clicando aqui.\n\n5.7.1 Abrindo shapefiles via sf\nUma das maneiras mais eficientes de importar shapefiles para a linguagem R é usando a biblioteca sf. Essa biblioteca disponibiliza uma série de funções bastante úteis na manipulação e no gerenciamento de dados georreferenciados. A título de recomendação, caso o usuário desse material queira se especializar em gerenciamento de dados espaciais, recomenda-se o guia elaborado por Pebesma e Bivand (2025) disponibilizado gratuitamente aqui.\nO primeiro passo para a utilização da biblioteca sf é a instalação (caso a biblioteca não esteja previamente instalada). Para tanto, deve-se proceder conforme a seguir:\n\ninstall.packages(\"sf\")\n\nTendo instalado a biblioteca, o usuário deve liberá-la para o uso, procedendo conforme a seguir:\n\nlibrary(sf)\n\nEm seguida, escolha uma pasta do seu computador para baixar os arquivos shapefiles e fixe o diretório de uso para essa pasta específica usando a função setwd().\n\nsetwd(\"endereço da pasta escolhida\")\n\nPara exemplificar, vamos importar o shapefile de estados do Brasil, disponibilizado pelo IBGE e que pode ser baixado clicando aqui. Baixe o arquivo na pasta selecionada e em seguida extraia os arquivos da pasta .zip usando um gerenciador de arquivos compactados. Tendo baixado e descompactado os arquivos, busque pelo pelo arquivo com extensão .shp. Note que o arquivo é nomeado de BR_UF_2024.shp.\nPara abrir o shapefile em R usando a biblioteca sf, vamos usar a função read-sf(), indicando dentro do parênteses e entre aspas o nome do arquivo com a extensão .shp. Para tanto, vamos criar um objeto de nome estados que armazenará o shapefile importado.\n\nestados = read_sf(\"BR_UF_2024.shp\")\nhead(estados)\n\nEsse procedimento vai gerar um data frame onde a última coluna possui as delimitações geográficas de cada indivíduo. Essas delimitações servirão para gerar figuras como mapas e dispersões espaciais. Estudaremos como gerar mapas a partir desses arquivos nos próximos capítulos.\n\n\n5.7.2 geobr, uma ferramenta para importar shapefiles brasileiros\ngeobr é uma biblioteca em R desenvolvida para permitir acesso rápido e fácil a um variado conjunto de shapefiles e dados espaciais brasileiros. A biblioteca possui uma série de funções que facilita a importação de shapefiles disponibilizados por fontes confiáveis. O guia de utilização da biblioteca pode ser acessado clicando aqui. Assim como a biblioteca sf, o usuário precisa efetuar a instalação (caso ainda não a tenha feito) e a liberação para o uso antes de executar qualquer uma das funções da biblioteca.\n\ninstall.packages(\"geobr\")\n\n\nlibrary(geobr)\n\nAs principais funções da biblioteca geobr que podem ser bastante úteis para um economista que trabalha com dados espaciais são:\n\nread_municipality: Importa o shapefile de municípios brasileiros.\nread_micro_region: Importa o shapefile de microrregiões do Brasil.\nread_meso_region: Importa o shapefile de mesorregiões do Brasil.\nread_state: Importa o shapefile de estados do Brasil.\nread_region: Importa o shapefile de regiões do Brasil:\nread_country: Importa o shapefile do Brasil como um todo.\n\nPara exemplificar, vamos criar um objeto de nome meso que armazenará o shapefile de mesorregiões brasileiras usando a função read_meso_region. Esse procedimento pode ser feito conforme delimitado a seguir:\n\nmeso = read_meso_region()\nhead(meso)\n\nEsse procedimento vai gerar um arquivo com as mesmas especificações de um data frame gerado pela biblioteca sf, porém, com as delimitações espaciais das mesorregiões do Brasil.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#dados-de-outras-linguagens",
    "href": "Aula5.html#dados-de-outras-linguagens",
    "title": "5  Leitura de dados",
    "section": "5.8 Dados de outras linguagens",
    "text": "5.8 Dados de outras linguagens\nA escolha de uma linguagem de programação para uso no cotidiano é bastante particular na vida profissional do economista e envolve critérios que vão desde a identificação com os princípios da linguagem até a familiaridade com esses princípios. Por esse motivo, os economistas usam linguagens distintas que atendem as suas demandas de acordo com o seu domínio, otimizando o seu tempo de trabalho. Como consequência, alguns arquivos de dados são salvos em formatos que são particulares de uma linguagem específica. Por exemplo, economistas que usam a linguagem stata salvam seus dados em arquivos com extensão .dta, enquanto os economistas que usam matlab salvam seus dados em arquivos com extensão .mat.\nVez ou outra, um economista que usa uma linguagem de programação precisa usar arquivos salvos com extensões nativas de outras linguagens de programação. Por exemplo, é comum que os usuários da linguagem R precisem abrir arquivos gerados na linguagem stata. Como proceder nesse caso? A solução indicada nesse material é que o economista use a biblioteca foreign. Essa biblioteca possui uma série de funções que possibilitam importar para a lingagem R uma série de arquivos provenientes de outras linguagens.\nAssim como nos casos anteriores onde o uso de uma biblioteca externa foi necessário, neste caso é preciso que o usuário instale a biblioteca (caso ainda não tenha instalado) e libere-a para o uso.\n\ninstall.packages(\"foreign\")\n\n\nlibrary(foreign)\n\n\n5.8.1 Arquivos Stata (.dta)\nPara abrir arquivos com a extensão .dta é necessário usar a função read.dta(), indicando dentro do parêntesis e entre aspas o nome do arquivo que se deseja abrir. Para exemplificar, considere importar o arquivo stata disponível no link drive.google.com/uc?id=176sePIlFsqMH9mrtueX9RtHJZmZtWd-0&export=download. Nesse caso, deve-se proceder conforme a seguir:\n\ndt = read.dta(\"https://drive.google.com/uc?id=176sePIlFsqMH9mrtueX9RtHJZmZtWd-0&export=download\")\nhead(dt)\n\nCaso o arquivo estivesse presente na sua máquina em vez de um endereço url, bastaria proceder de acordo com a seguinte especificação:\n\ndt = read.dta(\"Endereço da pasta onde o arquivo está armazenado/nome do arquivo.dta\")\n\nAbaixo segue uma lista de funções com o mesmo layout de uso para importar arquivos de outras linguagens.\n\nread.dbf: Ideal para importar arquivos do libre office calc salvos na extensão .dbf.\nread.octave: Ideal para importar arquivos do Matlab e Octave salvos na extensão .mat.\nread.spss: Ideal para importar arquivos do SPSS salvos na extensão .sav.\nread.ssd: Ideal para importar arquivos do SAS salvos na extensão .sas7bdat.\n\nAlém de importar os arquivos, também é possível salvar os arquivos presentes no ambiente de trabalho em uma extensão Stata. Por exemplo, para salvar o data frame mtcars na extensão .dta, use a função write.dta, procedendo conforme a seguir:\n\nwrite.dta(mtcars, file = \"mtcars.dta\")\n\nO arquivo mtcars.dta será salvo na pasta em que o diretório de trabalho está fixado. No geral, a funçãos write.dta segue as seguintes especificações de uso:\n\nwrite.dta(nome do data frame no diretório de trabalho, file = \"Endereço da pasta/nome do arquivo salvo.dta\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula5.html#exercício",
    "href": "Aula5.html#exercício",
    "title": "5  Leitura de dados",
    "section": "5.9 Exercício",
    "text": "5.9 Exercício\n(i) O IBGE calcula anualmente as estimativas de população para cada município brasileiro. Para o ano de 2024, essas informações podem ser acessadas no formato .csv no seguinte endereço https://sidra.ibge.gov.br/geratabela?format=br.csv&name=tabela6579.csv&terr=NC&rank=-&query=t/6579/n6/all/v/all/p/2024/l/v,p,t. Leia corretamente essa tabela com a linguagem R usando a função read.csv().\n(ii) A mesma tabela da questão anterior está disponível no formato .xlsx no endereço https://sidra.ibge.gov.br/geratabela?format=xlsx&name=tabela6579.xlsx&terr=NC&rank=-&query=t/6579/n6/all/v/all/p/2024/l/v,p,t. Leia corretamente essa tabela com a linguagem R usando a função read.xlsx() da biblioteca openxlsx.\n(iii) Usando a biblioteca geobr, importe para a linguagem R.\n\nO shapefile de municípios brasileiros.\nO shapefile de estados brasileiros.\nO shapefile de microrregiões do Brasil.\nO shapefile de mesorregiões do Brasil.\n\n(iv) Leia atentamente o material desse capítulo e use a biblioteca readr para importar todas as colunas da PNAD-Contínua do segundo trimestre de 2024.\n(v) Desafio: Acesse o repositório de dados eleitorais do TSE e busque pelo conjunto de dados de resultados das eleições. Busque pelos resultados das eleições de 2020 e navegue até o endereço https://dadosabertos.tse.jus.br/dataset/resultados-2020. Nesse endereço estão dispostos as votações nominais por município e zona eleitoral de cada estado brasileiro referente ao ano de 2020. As informações estão dispostas por estado de modo que cada estado está em uma pasta zip. Dentro dessa pasta há um arquivo na extensão .csv contendo os dados desejados. Siga os seguintes passos para ler os arquivos:\n\nCrie uma pasta temporária com a função tempfile.\nElabore um loop for para automatizar as importações de dados pelo endereço url dos arquivos .zip.\nDentro do loop, baixe as pastas zip com a função download.file.\nUse a função unz para descompartar o csv e a função read.csv para ler os arquivos de cada estado.\nEmpilhe tudo em um único data frame.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Leitura de dados</span>"
    ]
  },
  {
    "objectID": "Aula6.html",
    "href": "Aula6.html",
    "title": "6  Manipulação de dados",
    "section": "",
    "text": "6.1 Introdução\nTendo conhecido os tópicos fundamentais a respeito da lógica de programação nos quatro primeiros capítulos e tendo em mãos os conhecimentos básicos a respeito da leitura de arquivos de dados com base no conteúdo visto no capítulo anterior, o próximo passo do aprendizado da introdução à programação e à ciência de dados é entender os fundamentos básicos da manipulação de dados.\nEntende-se por manipulação de dados as técnicas necessárias para organizar bases de dados de acordo com um determinado objetivo, corrigindo erros, implementando melhorias e deixando-as com as propriedades desejadas. É fundamental que o economista domine as técnicas de manipulação de dados pois a etapa de tratamento das informações requer esse conhecimento e deve ser aplicada antes de qualquer análise empírica.\nÉ comum que informações distintas estejam hospedadas em diferentes fontes. Mas também é comum que múltiplas bases de dados sejam necessárias para gerar uma única informação. Por exemplo, o pib per capita requer duas bases de dados, o pib e a população, as quais estão em diferentes fontes. Assim, o economista terá de importar ambas as bases de dados, uní-las em uma única planilha e em seguida fazer as devidas manipulações para transformar o pib e a população no pib per capita.\nPor esse motivo, esse capítulo é subdividido em duas etapas fundamentais. Na primeira etapa, são repassadas as técnicas de junção de bases de dados, onde o aluno irá aprender a unir objetos sob diferentes perspectivas de união. Em seguida, na segunda etapa são repassadas as técnicas de manipulação de dados, onde o aluno aprenderá as principais ferramentas úteis no gerenciamento de informações.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulação de dados</span>"
    ]
  },
  {
    "objectID": "Aula6.html#introdução",
    "href": "Aula6.html#introdução",
    "title": "6  Manipulação de dados",
    "section": "",
    "text": "6.1.1 Bibliotecas necessárias\nUsaremos duas bibliotecas indispensáveis na manipulação de dados com R, a biblioteca dplyr e a biblioteca tidyr. Essas bibliotecas dispõem de funções úteis no gerenciamento de bases de dados que dão uma intérfase simples e compreensível às técnicas de gerenciamento de dados. Portanto, antes de mais nada é preciso instalar as bibliotecas e librerá-las para o uso.\n\ninstall.packages(\"dplyr\")\ninstall.packages(\"tidyr\")\n\n\nlibrary(dplyr)\n\nFALSE \nFALSE Attaching package: 'dplyr'\n\n\nFALSE The following objects are masked from 'package:stats':\nFALSE \nFALSE     filter, lag\n\n\nFALSE The following objects are masked from 'package:base':\nFALSE \nFALSE     intersect, setdiff, setequal, union\n\nlibrary(tidyr)\n\n\n\n[[1]]\n[1] TRUE\n\n[[2]]\n[1] TRUE\n\n\n\n\n6.1.2 A função pip (%&gt;%)\nA biblioteca tidyr possui uma função que permite agrupar múltiplas linhas de comando em apenas um único comando. Essa função é conhecida como pip e o seu uso é ativado por meio do comando %&gt;%. Esse procedimento facilita a manipulação de dados uma vez que permite que múltiplas tarefas sejam executadas em um único bloco de ordens ao computador. Para exemplificar, considere a base nativa sobre carros mtcars. Suponha que queiramos preservar apenas os carros com câmbio automático e checar o consumo médio desses carros. Sem as bibliotecas de manipulação, essa tarefa seria realizada em duas linhas de comando separadamente, conforme demonstrado a seguir:\n\ndt = mtcars[mtcars$am == 1,]\nmean(dt$mpg)\n\n[1] 24.39231\n\n\nCom a função pip, é possível associar a segunda linha à primeira e criar um bloco de ordens em um único comando. Assim, o output gerado será o resultado das ordens indicadas no bloco de ordens. No caso do exemplo anterior, devemos dar a ordem para preservar apenas am = 1, acionamos o pip e em seguida ordenamos para calcular a média do consumo, conforme demonstrado a seguir:\n\nmtcars[mtcars$am == 1,] %&gt;% summarise(mean(mpg))\n\n  mean(mpg)\n1  24.39231\n\n\nNote que o resultado é o mesmo em ambas as abordagens.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulação de dados</span>"
    ]
  },
  {
    "objectID": "Aula6.html#união-de-bases-de-dados-join",
    "href": "Aula6.html#união-de-bases-de-dados-join",
    "title": "6  Manipulação de dados",
    "section": "6.2 União de bases de dados (join)",
    "text": "6.2 União de bases de dados (join)\nMuitas vezes os economistas se deparam com a necessidade de unir bases de dados para obter informações úteis. Por exemplo, um economista que busca analisar o PIB per capita precisa operacionalizar com uma base de dados de crescimento (PIB) e uma base de dados sobre população. Um economista que busca estudar mercados de capitais pode precisar lidar com uma base de dados sobre preços de ações e outra base sobre taxas de câmbio. Em resumo, os economistas precisam lidar com múltiplas bases de dados e precisam conhecer as técnicas de junção de bases de dados distintas.\nA biblioteca dplyr possui um conjunto de funções que facilita a união de bases de dados de acordo com a necessidade e a configuração dos dados. As junções de bases de dados devem ser feitas com base em um código de identificação dos indivíduos. Imagine que queiramos unir as duas tabelas a seguir:\n\\[\nx = \\left[\\begin{array}{ccc}\nID & X1 & X2\\\\\n1 & A & E\\\\\n2 & B & F\\\\\n3 & C & G\\\\\n4 & D & H\\\\\n\\end{array}\\right]\n\\quad \\quad \\quad  \\quad\ny = \\left[\\begin{array}{cc}\nID & X3\\\\\n1 & I\\\\\n3 & J\\\\\n5 & K\\\\\n\\end{array}\\right]\n\\]\nSe ID é a identificação do indivíduo, então as duas tabelas podem ser unidas de acordo com essa identificação. No entanto, alguns elementos em x não estão disponíveis em y do mesmo modo que alguns elementos em y não estão disponíveis em x. É preciso, portanto, que o usuário saiba quais informações são do seu interesse em cada tabela para fazer a união das bases.\nBaseado nisso, a biblioteca dplyr possui uma série de funções ideais para a junção de bases de dados que permite que o usuário una duas planilhas de acordo com um código de identificação e com base no procedimento ideal para a junção. Basicamente são seis tipos de junções que podem ser efetuadas. As funções e os tipos de junção possibilitados por essas funções estão listados a seguir:\n\nleft_join(x,y): Junção à esquerda. Mantém inalterados todos os indivíduos da tabela a esquerda (Tabela x) e posiciona os valores correspondentes da tabela da direita (Tavela y) à direita das colunas da primeira tabela.\nright_join(x,y): Junção à direita. Mantém inalterados todos os indivíduos da tabela a direita (Tabela y) e posiciona os valores correspondentes da tabela da esquerda (Tavela x) à direita das colunas da segunda tabela.\ninner_join(x,y): Intersecção. Gera uma tabela z com as colunas de x e y contendo apenas os indivíduos que possuem informações em ambas as tabelas.\nsemi_join(x,y): Intersecção. Gera uma tabela semelhante à tabela x, sem as colunas da tabela y, porém, contendo apenas os indivíduos que estão presentes em x e y.\nfull_join(x,y): União de tabelas. Gera uma tabela com todas as colunas e todas as linhas de x e y. Nesse caso, todos os indivíduos presentes em x e y são preservados no output.\nanti_join(x,y): Gera uma tabela contendo todos os indivíduos da tabela x que não estão presentes na tabela y.\n\nEssas definições podem ser facilmente visualizadas na figura a seguir:\n\n\n6.2.1 Junção à esquerda (left_join(x,y))\nConsidere as tabelas x e y apresentadas anteriormente. Suponha que queiramos colocar a coluna X3 da tabela y ao lado da coluna X2 da tabela x, preservando todos os quatro indivíduos da tabela x. Nesse caso, podemos usar o left_join(), posicionando x à esquerda e y à direita. Para tanto, vamos digitar as tabelas como data frames e vamos nomeá-las de “tabela1” e “tabela2”.\n\ntabela1 = data.frame(\n  ID = 1:4, X1 = LETTERS[1:4], X2 = LETTERS[5:8]\n)\ntabela2 = data.frame(\n  ID = c(1,3,5), X3 = LETTERS[9:11]\n)\n\nAgora vamos gerar uma tabela3, unindo as duas tabelas com o left_join(). Para tanto, precisamos indicar qual das tabelas será posicionada à esquerda e à direita nos parâmetros x e y da função, respectivamente, e também precisamos indicar o código de identificação do indivíduo entre aspas no parâmetro by da função. Esse procedimento pode ser feito conforme a seguir:\n\ntabela3 = left_join(x = tabela1, y = tabela2, by = \"ID\")\n\nEsse procedimento gera um data frame com as seguintes propriedades:\n\nprint(tabela3)\n\n  ID X1 X2   X3\n1  1  A  E    I\n2  2  B  F &lt;NA&gt;\n3  3  C  G    J\n4  4  D  H &lt;NA&gt;\n\n\nNote que os indivíduos com ID 2 e 4 apresentam valores NA na coluna X3. Isso ocorre porque esses indivíduos não estão presentes na tabela2 e mesmo assim permanecem no output. Como não existem valores de referência para esses indivíduos nessa coluna, a linguagem retorna valores vazios.\n\n\n6.2.2 Junção à direita (right_join(x,y))\nSuponha agora que precisamos preservar apenas os indivíduos da tabela2, colocando as colunas da tabela1 à direita das colunas da tabela2. Nesse caso, o ideal é usar o right-join(). Nesse tipo de junção, o parâmetro y indica qual planilha permanecerá com as linhas inteiramente preservadas, ao passo que o parâmetro x mostra a planilha que aparecerá à esquerda da tabela2 no output. Esse procedimento pode ser feito conforme indicado a seguir:\n\ntabela3 = right_join(x = tabela1, y = tabela2, by = \"ID\")\nprint(tabela3)\n\n  ID   X1   X2 X3\n1  1    A    E  I\n2  3    C    G  J\n3  5 &lt;NA&gt; &lt;NA&gt;  K\n\n\nNote que agora as colunas X1 e X2 apresentam NAs para o indivíduo 5. Isso ocorre porque esse indivíduo não está presente na tabela1 mas está presente na tabela2. Como todas as linhas da tabela2 são preservadas nesse tipo de junção, então a linguagem atribui valores vazios para essas células.\n\n\n6.2.3 Intersecção (inner_join(x,y))\nConsidere agora o caso em que seja necessário preservar no output apenas os indivíduos que estão tanto na tabela1 quanto na tabela2. Nesse caso, o ideal é fazer uma intersecção usando o inner_join(). A planilha resultante irá mostrar as colunas de ambas as tabelas, porém, contendo apenas as linhas comuns às duas planilhas. Esse procedimento pode ser feito conforme demonstrado a seguir:\n\ntabela3 = inner_join(x = tabela1, y = tabela2, by = \"ID\")\nprint(tabela3)\n\n  ID X1 X2 X3\n1  1  A  E  I\n2  3  C  G  J\n\n\nNote que o output resultante só possui os indivíduos 1 e 2. Isso ocorre porque esses são os únicos indivíduos que estão nas duas planilhas.\n\n\n6.2.4 Intersecção (semi_join(x,y))\nConsidere agora o caso em que seja necessário preservar apenas os indivíduos que estão presentes em ambas as planilhas assim como no caso anterior. Porém, considere que não seja necessário preservar as colunas da tabela2 no output, isto é, estamos interessados em preservar apenas as colunas da tabela1, mas mantendo apenas as linhas referentes aos indivíduos que estão presentes em ambas as planilhas. Nesse caso, o ideal é usar o semi_join(), procedendo conforme demonstrado a seguir:\n\ntabela3 = semi_join(x = tabela1, y = tabela2, by = \"ID\")\nprint(tabela3)\n\n  ID X1 X2\n1  1  A  E\n2  3  C  G\n\n\nRepare que apenas os indivíduos 1 e 2 são preservados no output, assim como no caso do inner_join(). Porém, note que agora a coluna X3 não aparece no output.\n\n\n6.2.5 União (full_join(x,y))\nAgora considere o caso em que seja necessário preservar todos os indivíduos presentes em ambas as tabelas, mantendo também todas as colunas presentes nas duas tabelas. Nesse caso, o ideal é usar o full_join(), procedendo conforme indicado a seguir:\n\ntabela3 = full_join(x = tabela1, y = tabela2, by = \"ID\")\nprint(tabela3)\n\n  ID   X1   X2   X3\n1  1    A    E    I\n2  2    B    F &lt;NA&gt;\n3  3    C    G    J\n4  4    D    H &lt;NA&gt;\n5  5 &lt;NA&gt; &lt;NA&gt;    K\n\n\n\n\n6.2.6 Exclusão (anti_join(x,y))\nPor fim, considere o caso em que seja necessário gerar uma tabela preservando todos os indivíduos que estão na tabela1 mas que não aparecem na tabela2. Nesse caso, o ideal é usar o anti_join(), procedendo conforme indicado a seguir:\n\ntabela3 = anti_join(x = tabela1, y = tabela2, by = \"ID\")\nprint(tabela3)\n\n  ID X1 X2\n1  2  B  F\n2  4  D  H\n\n\nNote que a coluna X3 não aparece no output. Isso é esperado dado que não faz sentido incluir essa coluna na planilha resultante pois X3 só está presente na tabela2 e os indivíduos contidos no output não estão presentes na tabela2. Como consequência, incluir X3 no output resultaria em uma coluna de NAs.\n\n\n\n6.2.7 Exemplo: Unindo o pib e a população\nAcessando o sistema SIDRA do IBGE, podemos encontrar o pib das regiões georgáficas brasileiras para o ano de 2021 em R$ 1000 no link https://sidra.ibge.gov.br/geratabela?format=br.csv&name=tabela5938.csv&terr=NS&rank=-&query=t/5938/n2/all/v/37/p/last%201/d/v37%200/l/v,p,t. Também podemos encontrar a população residente estimada no link https://sidra.ibge.gov.br/geratabela?format=br.csv&name=tabela6579.csv&terr=NS&rank=-&query=t/6579/n2/all/v/all/p/2021/l/v,p,t. Vamos importar o pib para o R como um data frame de nome pib e a população como um data frame de nome pop.\n\npib = read.csv(\n  \"https://sidra.ibge.gov.br/geratabela?format=br.csv&name=tabela5938.csv&terr=NS&rank=-&query=t/5938/n2/all/v/37/p/last%201/d/v37%200/l/v,p,t\",\n  skip = 3,\n  header = TRUE,\n  sep = \";\"\n)\n\npib = pib[1:5,]\ncolnames(pib) = c(\"Nivel\", \"regiao\", \"pib\")\n\npop = read.csv(\n  \"https://sidra.ibge.gov.br/geratabela?format=br.csv&name=tabela6579.csv&terr=NS&rank=-&query=t/6579/n2/all/v/all/p/2021/l/v,p,t\",\n  skip = 3,\n  header = TRUE,\n  sep = \";\"\n)\n\npop = pop[1:5,-1]\ncolnames(pop) = c(\"regiao\", \"populacao\")\n\n\nprint(pib)\n\n  Nivel       regiao        pib\n1    GR        Norte  564063747\n2    GR     Nordeste 1243103280\n3    GR      Sudeste 4712981720\n4    GR          Sul 1559827628\n5    GR Centro-Oeste  932165625\n\n\n\nprint(pop)\n\n        regiao populacao\n1        Norte  18906962\n2     Nordeste  57667842\n3      Sudeste  89632912\n4          Sul  30402587\n5 Centro-Oeste  16707336\n\n\nNote que o nome da região está presente em ambas as planilhas. Agora vamos unir as duas planilhas usando o inner_join() criando um data frame de nome pib_regioes usando o nome da região como código de identificação.\n\npib_regioes = inner_join(x = pib, y = pop, by = \"regiao\")\nprint(pib_regioes)\n\n  Nivel       regiao        pib populacao\n1    GR        Norte  564063747  18906962\n2    GR     Nordeste 1243103280  57667842\n3    GR      Sudeste 4712981720  89632912\n4    GR          Sul 1559827628  30402587\n5    GR Centro-Oeste  932165625  16707336\n\n\nPodemos agora adicionar uma nova coluna contendo o pib per capita de cada região, que é a razão entre o pib e a população.\n\npib_regioes$pib_percapita = pib_regioes$pib/pib_regioes$populacao\nprint(pib_regioes)\n\n  Nivel       regiao        pib populacao pib_percapita\n1    GR        Norte  564063747  18906962      29.83365\n2    GR     Nordeste 1243103280  57667842      21.55626\n3    GR      Sudeste 4712981720  89632912      52.58093\n4    GR          Sul 1559827628  30402587      51.30575\n5    GR Centro-Oeste  932165625  16707336      55.79379\n\n\nPodemos também apresentar esses valores em uma figura (conteúdo que será abordado nos próximos capítulos).\n\nbarplot(\n  pib_regioes$pib_percapita, \n  col = \"cyan\", \n  names.arg = pib_regioes$regiao, \n  main = \"Pib per capita das regiões do Brasil\", \n  xlab = \"Região\", \n  ylab = \"Pib per capita (R$ 1000,00)\",\n  ylim = c(0,60)\n)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulação de dados</span>"
    ]
  },
  {
    "objectID": "Aula6.html#gerando-estatísticas-com-summarise",
    "href": "Aula6.html#gerando-estatísticas-com-summarise",
    "title": "6  Manipulação de dados",
    "section": "6.3 Gerando estatísticas com summarise",
    "text": "6.3 Gerando estatísticas com summarise\nImagine o caso em que seja preciso extrair estatísticas de uma base de dados. Nesse caso, o usuário pode usar a indexação pela coluna para realizar essa tarefa. Por exemplo, para obter o peso médio dos carros na base de dados mtcars, o usuário pode fazer o seguinte:\n\nmean(mtcars$wt)\n\n[1] 3.21725\n\n\nNo entanto, caso seja necessário calcular essa mesma estatística ou outras estatísticas para múltiplas colunas, a escrita do código pode tornar-se repetitiva e ineficiente. Para contornar esse problema, a biblioteca dplyr disponibiliza a função summarise que é ideal para calcular estatísticas com base em informações de um dado objeto. Para utilizar essa função, o usuário deve proceder com a seguinte lógica:\n\nnome da base de dados %&gt;% \n  summarise(\n    nome da estatistica 1 = estatística 1,\n    nome da estatistica 2 = estatística 2,\n    ...\n    nome da estatistica n = n-ésima estatística\n  )\n\nPor exemplo, caso seja necessário calcular o peso médio, o consumo médio e o número total de carros na base mtcars, o usuário deve proceder conforme a seguir:\n\nmtcars %&gt;% \n  summarise(\n    peso_medio = mean(wt),\n    consumo_medio = mean(mpg),\n    numero_carros = length(mpg)\n  )\n\n  peso_medio consumo_medio numero_carros\n1    3.21725      20.09062            32\n\n\n\n6.3.1 Gerando estatísticas para todas as colunas\nCaso o usuário precise gerar estatísticas para todas as variáveis de uma base de dados, ele pode usar a função summarise_all para escrever o comando em uma única linha em vez de escrever as estatísticas uma a uma na função summarise, o que deixaria o código maior e menos eficiente. A lógica de uso da função summarise_all é a seguinte:\n\nnome da base de dados %&gt;% \n  summarise_all(.funs = c(\"função 1\", \"função 2\", ...  \"função n\"))\n\nPara exemplificar, imagine que seja preciso calcular a média, o desvio padrão e a mediana de todas as variáveis da base de dados mtcars. Nesse caso, deve-se proceder conforme indicado a seguir:\n\nmtcars %&gt;% \n  summarise_all(.funs = c(\"mean\", \"sd\", \"median\"))\n\n  mpg_mean cyl_mean disp_mean  hp_mean drat_mean wt_mean qsec_mean vs_mean\n1 20.09062   6.1875  230.7219 146.6875  3.596563 3.21725  17.84875  0.4375\n  am_mean gear_mean carb_mean   mpg_sd   cyl_sd  disp_sd    hp_sd   drat_sd\n1 0.40625    3.6875    2.8125 6.026948 1.785922 123.9387 68.56287 0.5346787\n      wt_sd  qsec_sd     vs_sd     am_sd   gear_sd carb_sd mpg_median\n1 0.9784574 1.786943 0.5040161 0.4989909 0.7378041  1.6152       19.2\n  cyl_median disp_median hp_median drat_median wt_median qsec_median vs_median\n1          6       196.3       123       3.695     3.325       17.71         0\n  am_median gear_median carb_median\n1         0           4           2\n\n\n\n\n6.3.2 Gerando estatísticas para colunas específicas\nCaso as mesmas estatísticas devam ser aplicadas apenas a uma parte das variáveis da base de dados, então provavelmente seja mais eficiente usar a função summarise_at. Essa função permite que o usuário indique as variáveis e as estatísticas que devem ser calculadas em uma única linha sem a necessidade de repetir os métodos de cálculo das estatísticas com o summarise. A lógica de uso do summarise_at está delimitada a seguir:\n\n{r, eval=FALSE}\nnome da base de dados %&gt;% \n  summarise_all(\n    .vars = c(\"variável 1\", \"variável 2\", ...  \"variável n\")\n    .funs = c(\"função 1\", \"função 2\", ...  \"função n\")\n  )\n\nPara exemplificar, suponha que seja necessário calcuar a média, o desvio padrão e a mediana das colunas mpg, wt e qseq da base de dados mtcars. Nesse caso, o usuário deve proceder conforme a seguir:\n\nmtcars %&gt;% \n  summarise_at(\n    .vars = c(\"mpg\", \"wt\", \"qsec\"),\n    .funs = c(\"mean\", \"sd\", \"median\")\n  )\n\n  mpg_mean wt_mean qsec_mean   mpg_sd     wt_sd  qsec_sd mpg_median wt_median\n1 20.09062 3.21725  17.84875 6.026948 0.9784574 1.786943       19.2     3.325\n  qsec_median\n1       17.71\n\n\nCaso existam valores NAs na base de dados, o usuário pode adicionar o na.rm = TRUE antes de fechar o parênteses principal da função, ou seja:\n\nmtcars %&gt;% \n  summarise_at(\n    .vars = c(\"mpg\", \"wt\", \"qsec\"),\n    .funs = c(\"mean\", \"sd\", \"median\"),\n    na.rm = TRUE\n  )\n\n  mpg_mean wt_mean qsec_mean   mpg_sd     wt_sd  qsec_sd mpg_median wt_median\n1 20.09062 3.21725  17.84875 6.026948 0.9784574 1.786943       19.2     3.325\n  qsec_median\n1       17.71\n\n\n\n\n6.3.3 Gerando estatísticas condicionais\nImagine o caso em que seja preciso calcular uma estatística específica apenas para as variáveis que atendam a uma dada condição. Por exemplo, imagine que seja necessário calcular a média apenas para as colunas que tenham elementos numéricos. Nesse caso, o usuário pode usar a função summarise_if, da biblioteca dpplyr. Essa função permite que as estatísticas desejadas sejam obtidas apenas para as variáveis que atendam a uma dada condição especificada pelo usuário. Essa condição especificada precisa, contudo, advir de uma função com output TRUE ou FALSE, de modo que as estatísticas serão calculadas para as variáveis que obedecerem a condição de afirmação. Para usar o summarise_if, o usuário deve seguir a seguinte lógica:\n\nnome da base de dados %&gt;% \n  summarise_if(condição dada por função, .funs = c(\"estatística\"))\n\nPara exemplificar, considere que seja necessário calcular a média, o desvio padrão e a mediana apenas das variáveis da base de dados mtcars que possuem soma maior que 100. Nesse caso, é preciso criar uma função que especifique essa condição e aplicá-la no summarise_if. Esse procedimento é demonstrado a seguir:\n\nf = function(x){\n  if(x &gt; 100){\n    return(TRUE)\n  }else{\n    return(FALSE)\n  }\n}\n\n\nmtcars %&gt;% \n  summarise_if(f, .funs = c(\"mean\",\"sd\", \"median\"))\n\n  disp_mean  hp_mean  disp_sd    hp_sd disp_median hp_median\n1  230.7219 146.6875 123.9387 68.56287       196.3       123",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulação de dados</span>"
    ]
  },
  {
    "objectID": "Aula6.html#criando-variáveis-mutate",
    "href": "Aula6.html#criando-variáveis-mutate",
    "title": "6  Manipulação de dados",
    "section": "6.4 Criando Variáveis (mutate)",
    "text": "6.4 Criando Variáveis (mutate)\nNos primeiros capítulos vimos que é possível adicionar variáveis em um objeto por meio da indexação. Por exemplo, usando a base sobre carros mtcars, se quisermos adicionar uma coluna de nome cambio com valor “manual” se am = 0 e “automatico” se am = 1, poderíamos fazer:\n\nmtcars$manual = ifelse(mtcars$am == 0, \"manual\", \"automatico\")\n\nSimilarmente, poderíamos fazer essa mesma tarefa usando a indexação pelo nome da coluna:\n\nmtcars[,\"cambio\"] = ifelse(mtcars[,\"am\"] == 0, \"manual\", \"automatico\")\n\nEsses procedimentos são perfeitamente válidos e funcionam de maneira irrestrita. Porém, note que cada coluna adicionada precisa ser criada em uma linha específica. Note também que a indexação sempre precisa ser informada, tornando a escrita repetitiva e ineficiente. Para melhorar a eficiência da escrita, a biblioteca dplyr disponibiliza uma função nomeada mutate. Essa função permite que múltiplas colunas sejam criadas sem a necessidade de informar a indexação em cada linha de comando. Para melhorar o seu uso, recomenda-se que a função mutate seja usada em conjunto com a função pip, o que permite que a linguagem R reconheça as indexações das colunas sem a necessidade de declará-las. A usuabilidade dessa função segue conforme a seguir:\n\nnome da base de dados %&gt;% \n  mutate(\n    nome da coluna criada  = operação para criar a coluna,\n    nome da outra coluna criada = operação para criar mais uma coluna,\n    ...\n    nome da outra coluna criada = operação para criar mais uma coluna\n  )\n\nPor exemplo, para adicionarmos a coluna cambio especificada anteriormente na base de carros mtcars, podemos proceder conforme a seguir:\n\ndt = mtcars %&gt;% \n  mutate(\n    cambio = ifelse(am == 1, \"automatico\", \"manual\")\n  )\n\nhead(dt)\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb     manual\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 automatico\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 automatico\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 automatico\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1     manual\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2     manual\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1     manual\n                      cambio\nMazda RX4         automatico\nMazda RX4 Wag     automatico\nDatsun 710        automatico\nHornet 4 Drive        manual\nHornet Sportabout     manual\nValiant               manual\n\n\nNote que agora já não é mais necessário utilizar o cifrão ou indexar pelo nome das colunas.\n\n6.4.1 Adicionando variáveis multicategóricas (mutate + case_when)\nA função ifelse é bastante útil para usar em conjunto com o mutate para gerar variáveis de duas categorias, uma vez que essa função baseia-se nas condições de afirmação e negação. Contudo, quando se trata de variáveis com múltiplas categorias, o ifelse pode ser complicado e ineficiente. Para contornar essa dificuldade, a biblioteca dplyr disponibiliza a função case_when que permite que o usuário realize operações com múltiplas condições ao mesmo tempo. De maneira rústica, o case_when funciona como um ifelse agrupado para múltiplas condições de afirmação e negação. Seu método de uso deve seguir as seguintes propriedades.\n\ncase_when(\n  condição para a categoria 1 ~ resposta para a categoria 1,\n  condição para a categoria 2 ~ resposta para a categoria 2,\n  condição para a categoria 3 ~ resposta para a categoria 3,\n  ...\n  TRUE ~ resposta para o caso contrário\n)\n\nPara exemplificar, suponha que queremos adicionar na base de dados mtcars uma coluna de nome potencia classificando a potência do carro conforme o número de cilindros, seguindo as categorias listadas a seguir:\n\nPotência baixa -&gt; Carros com 4 cilindros.\nPotência média: Carros com 6 cilindros.\nPotência alta: Carros com 8 cilindros.\n\nNesse caso, devemos proceder conforme a seguir:\n\ndt = mtcars %&gt;% \n  mutate(\n    potencia = case_when(\n      cyl == 4 ~ \"Potência baixa\",\n      cyl == 6 ~ \"Potência média\",\n      TRUE ~ \"Potência alta\"\n    )\n  )\n\nhead(dt)\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb     manual\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 automatico\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 automatico\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 automatico\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1     manual\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2     manual\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1     manual\n                      cambio       potencia\nMazda RX4         automatico Potência média\nMazda RX4 Wag     automatico Potência média\nDatsun 710        automatico Potência baixa\nHornet 4 Drive        manual Potência média\nHornet Sportabout     manual  Potência alta\nValiant               manual Potência média",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulação de dados</span>"
    ]
  },
  {
    "objectID": "Aula6.html#filtrando-valores-nas-colunas",
    "href": "Aula6.html#filtrando-valores-nas-colunas",
    "title": "6  Manipulação de dados",
    "section": "6.5 Filtrando valores nas colunas",
    "text": "6.5 Filtrando valores nas colunas\nNos capítulos anteriores vimos que é possível apagar ou manter valores nas colunas usando a indexação. Por exemplo, caso seja preciso apagar os carros com câmbio manual (am = 0) na base mtcars e manter apenas os carros com câmbio automático (am = 1), podemos proceder conforme a seguir:\n\ndt = mtcars[mtcars$am == 1,]\n\nNo entanto, o uso da indexação para filtrar valores pode ser complicado e ineficiente quando é necessário aplicar múltiplass condições de escolha de valores. Para contornar esse detalhe, a biblioteca dplyr disponibiliza a função filter que permite que o usuário selecione ou remova valores dos objetos com múltiplas condições de seleção de valores sem a necessidade de usar a indexação. O uso dessa função deve seguir as propriedades listadas a seguir:\n\nnome do objeto %&gt;% \n  filter(\n    primeira condição de seleção ou remoção de valor,\n    segunda condição de seleção ou remoção de valor,\n    terceira condição de seleção ou remoção de valor,\n    ...\n    n-ésima condição de seleção ou remoção de valor\n  )\n\nPara exemplificar, considere que seja necessário preservar na base de dados mtcars apenas os carros com câmbio automático (am = 1) que tenham seis cilindros (cyl = 6), que tenham pelo menos quatro carburadores \\((carb 4 \\geq 6)\\) e que pesem mais de duas toneladas \\((wt&gt;2)\\). Nesse caso, devemos proceder conforme a seguir:\n\ndt = mtcars %&gt;% \n  filter(\n    am == 1,\n    cyl == 6,\n    carb &gt;= 4,\n    wt &gt; 2\n  )\n\nhead(dt)\n\n               mpg cyl disp  hp drat    wt  qsec vs am gear carb     manual\nMazda RX4     21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 automatico\nMazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 automatico\nFerrari Dino  19.7   6  145 175 3.62 2.770 15.50  0  1    5    6 automatico\n                  cambio\nMazda RX4     automatico\nMazda RX4 Wag automatico\nFerrari Dino  automatico",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulação de dados</span>"
    ]
  },
  {
    "objectID": "Aula6.html#selecionando-colunas-na-planilha-select",
    "href": "Aula6.html#selecionando-colunas-na-planilha-select",
    "title": "6  Manipulação de dados",
    "section": "6.6 Selecionando colunas na planilha (select)",
    "text": "6.6 Selecionando colunas na planilha (select)\nEm muitas ocasiões, algumas colunas de uma base de dados não são de interesse do economista ou não têm utilidade na tarefa designada. Por exemplo, se o economista precisa computar o pib per capita, ele precisa apenas do pib e da população, e quaisquer outras colunas presentes na planilha de informações podem ser desconsideradas. A tarefa de deletar essas colunas pode ser feita usando a indexação, porém, para facilitar essa tarefa, a biblioteca dplyr disponibiliza a função select, que permite que o usuário preserve na base de dados apenas aquelas colunas do seu interesse sem a necessidade de usar a indexação, reduzindo o número de linhas do código e melhorando a sua eficiência.\nA função select possui as seguintes propriedades de uso:\n\nnome da base de dados %&gt;% \n  select(nomes das colunas que devem permanecer na planilha separados por vírgula)\n\nOu\n\nnome da base de dados %&gt;% \n  select(-nomes das colunas que devem desaparecer da planilha separados por vírgula)\n\nPara exemplificar, considere a base de dados mtcars e suponha que só seja necessário usar as colunas am, mpg e wt, de modo que as demais colunas podem ser deletadas. Usando a função select, podemos fazer essa tarefa procedendo conforme indicado a seguir:\n\nmtcars %&gt;% \n  select(am, mpg, wt)\n\n                    am  mpg    wt\nMazda RX4            1 21.0 2.620\nMazda RX4 Wag        1 21.0 2.875\nDatsun 710           1 22.8 2.320\nHornet 4 Drive       0 21.4 3.215\nHornet Sportabout    0 18.7 3.440\nValiant              0 18.1 3.460\nDuster 360           0 14.3 3.570\nMerc 240D            0 24.4 3.190\nMerc 230             0 22.8 3.150\nMerc 280             0 19.2 3.440\nMerc 280C            0 17.8 3.440\nMerc 450SE           0 16.4 4.070\nMerc 450SL           0 17.3 3.730\nMerc 450SLC          0 15.2 3.780\nCadillac Fleetwood   0 10.4 5.250\nLincoln Continental  0 10.4 5.424\nChrysler Imperial    0 14.7 5.345\nFiat 128             1 32.4 2.200\nHonda Civic          1 30.4 1.615\nToyota Corolla       1 33.9 1.835\nToyota Corona        0 21.5 2.465\nDodge Challenger     0 15.5 3.520\nAMC Javelin          0 15.2 3.435\nCamaro Z28           0 13.3 3.840\nPontiac Firebird     0 19.2 3.845\nFiat X1-9            1 27.3 1.935\nPorsche 914-2        1 26.0 2.140\nLotus Europa         1 30.4 1.513\nFord Pantera L       1 15.8 3.170\nFerrari Dino         1 19.7 2.770\nMaserati Bora        1 15.0 3.570\nVolvo 142E           1 21.4 2.780\n\n\nRepare que todas as colunas que não foram especificadas no parênteses foram deletadas da planilha.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulação de dados</span>"
    ]
  },
  {
    "objectID": "Aula6.html#separando-valores-por-um-separador-comum",
    "href": "Aula6.html#separando-valores-por-um-separador-comum",
    "title": "6  Manipulação de dados",
    "section": "6.7 Separando valores por um separador comum",
    "text": "6.7 Separando valores por um separador comum\nEm alguns casos, uma coluna específica possui duas informações que estão delimitadas em um único valor. Por exemplo, o IBGE identifica os municípios por um código de identificação composto por sete números. Desses sete números, os dois primeiros correspondem ao código da unidade da federação, isto é, na mesma coluna é possível identificar o estado e o município. No entanto, para identificar o estado em uma coluna é preciso separara esses valores do código do município.\nQuando esses dois valores estão separados por um separador comum, é possível criar colunas adicionais contendo cada valor específico por meio da função separateda biblioteca tidyr. Nesse caso, basta indicar qual coluna possui a informação, informar o nome das novas colunas que serão criadas e o separador comum. Para exemplificar, considere a seguinte planilha:\n\ndf = data.frame(\n  x1 = 1:10,\n  x2 = c(paste(sample(LETTERS[1:26], 10), sample(1:100, 10), sep = \"-\"))\n)\ndf\n\n   x1   x2\n1   1 Y-59\n2   2 D-14\n3   3 Z-95\n4   4 Q-40\n5   5 N-10\n6   6 A-45\n7   7 G-38\n8   8 R-15\n9   9 P-56\n10 10 B-76\n\n\nNote que a coluna \\(x_2\\) possui dois valores separados por um hífen. Suponha que precisamos criar duas novas colunas, de nome \\(x_3\\) e \\(x_4\\) contendo esses valores separadamente. Nesse caso, o ideal é usar a função separate, procedendo de acordo com o código a seguir:\n\ndf %&gt;% \nseparate(\n  col = x2, # Coluna que será separada\n  into = c(\"x3\", \"x4\"), # nomes das novas colunas que serão criadas\n  sep = \"-\", # separador comum\n  remove = FALSE # TRUE se quiser remover a coluna x2 e FALSE caso contrário\n) \n\n   x1   x2 x3 x4\n1   1 Y-59  Y 59\n2   2 D-14  D 14\n3   3 Z-95  Z 95\n4   4 Q-40  Q 40\n5   5 N-10  N 10\n6   6 A-45  A 45\n7   7 G-38  G 38\n8   8 R-15  R 15\n9   9 P-56  P 56\n10 10 B-76  B 76",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulação de dados</span>"
    ]
  },
  {
    "objectID": "Aula6.html#agrupando-valores-group_by",
    "href": "Aula6.html#agrupando-valores-group_by",
    "title": "6  Manipulação de dados",
    "section": "6.8 Agrupando valores (group_by)",
    "text": "6.8 Agrupando valores (group_by)\nFrequentemente os economistas precisam agrupar valores para obter indicadores ou variáveis agregadas. Por exemplo, imagine o caso em que uma pesquisa amostral com consumidores do Brasil mostre os gastos com consumo de carne e que um economista precise calcular a média de gasto com carne para cada estado do Brasil. Nesse caso, é preciso agrupar os dados da pesquisa por estado e efetuar o cálculo da média por cada grupo. Em outro exemplo, imagine o caso em que tenhamos o PIB municipal ao longo de dez anos e queiramos calcular o PIB estadual para cada ano. Nesse caso, precisaremos agrupar os dados ao nível de estado e ano e em seguida somar o PIB dos municípios dentro de cada estado agrupado.\nPara facilitar esse processo, a biblioteca dplyr disponibiliza a função group_by que agrupa os dados pelas colunas indicadas pelo usuário e permite o cálculo de estatísticas e a criação de novas colunas com os valores agrupados. Essa função geralmente é usada de duas maneiras, conforme listado a seguir:\n\n6.8.1 (1) agrupando toda a base de dados (group_by + summarise)\nSe o usuário quer que toda a base de dados seja agrupada em uma única base de dados contendo apenas as colunas criadas com os valores agrupados, então o ideal é usar o group_by em conjunto com a função summarise. O layout de uso dessas funções deve seguir os seguintes procedimentos:\n\nnome da base de dados %&gt;% \n  group_by(nome das colunas indicando o nível de agrupamento) %&gt;% \n  summarise(\n    nome da coluna criada = estatística para criar a coluna\n  )\n\nPara exemplificar, imagine que precisamos calcular o peso médio dos carros de acordo com o número de cilindros na base mtcars. Essa tarefa pode ser executada com o seguinte procedimento:\n\ndt = mtcars %&gt;% \n  group_by(cyl) %&gt;% \n  summarise(\n    peso_medio = mean(wt)\n  )\n\nhead(dt)\n\n# A tibble: 3 x 2\n    cyl peso_medio\n  &lt;dbl&gt;      &lt;dbl&gt;\n1     4       2.29\n2     6       3.12\n3     8       4.00\n\n\nNote que todas as colunas desapareceram, permanecendo no data frame apenas a coluna de agrupamento (cyl) e a coluna com o resultado da estatística agrupada (peso_medio). Esse é o padrão de output quando se concilia as funções group_by e summarise.\n\n\n6.8.2 (2) Preservando toda a base de dados (group_by + mutate)\nNesse caso, todas as linhas e todas as colunas da base de dados são preservadas e uma nova coluna é adicionada com os valores agrupados. Esse procedimento é ideal para o caso em que se necessita apenas de uma nova coluna com dados agrupados para uma dada categoria. Para esses casos, a função group_by deve ser usada em conjunto com a função mutate em vez da função summarise.\nPara exemplificar, considere o mesmo caso do exemplo anterior, porém, com a diferença de que agora precisamos manter todas as linhas e todas as colunas da base de dados. Nesse caso, deve-se proceder conforme indicado a seguir:\n\ndt = mtcars %&gt;% \n  group_by(cyl) %&gt;% \n  mutate(\n    peso_medio = mean(wt)\n  )\n\nhead(dt[3:12])\n\n# A tibble: 6 x 10\n   disp    hp  drat    wt  qsec    vs    am  gear  carb manual    \n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;     \n1   160   110  3.9   2.62  16.5     0     1     4     4 automatico\n2   160   110  3.9   2.88  17.0     0     1     4     4 automatico\n3   108    93  3.85  2.32  18.6     1     1     4     1 automatico\n4   258   110  3.08  3.22  19.4     1     0     3     1 manual    \n5   360   175  3.15  3.44  17.0     0     0     3     2 manual    \n6   225   105  2.76  3.46  20.2     1     0     3     1 manual",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulação de dados</span>"
    ]
  },
  {
    "objectID": "Aula6.html#transformando-colunas-em-variáveis-pivot_wider",
    "href": "Aula6.html#transformando-colunas-em-variáveis-pivot_wider",
    "title": "6  Manipulação de dados",
    "section": "6.9 Transformando colunas em variáveis (pivot_wider)",
    "text": "6.9 Transformando colunas em variáveis (pivot_wider)\nImagine que você se depare com a situação em que seja preciso transformar em variáveis as categorias especificadas em uma coluna. Por exemplo, observe a coluna \\(x_2\\) na tabela a seguir:\n\n\n\n\\(x_1\\)\n\\(x_2\\)\n\\(x_3\\)\n\n\n\n\n1\nA\n5\n\n\n1\nC\n1\n\n\n1\nB\n3\n\n\n2\nC\n1\n\n\n2\nB\n3\n\n\n2\nA\n5\n\n\n3\nA\n5\n\n\n3\nB\n3\n\n\n3\nC\n1\n\n\n\nImagine que seja preciso gerar 3 colunas com os valores da coluna \\(x_3\\) referentes a cada elemento da coluna \\(x_2\\) (A, B e C), aumentando a quantidade de colunas da tabela conforme delimitado a seguir:\n\n\n\n\\(x_1\\)\nA\nB\nC\n\n\n\n\n1\n5\n1\n3\n\n\n2\n5\n1\n3\n\n\n3\n5\n1\n3\n\n\n\nEssa tarefa é bastante comum quando os dados estão empilhados (painel de dados) e os economistas precisam trabalhar com uma planilha desagregada (tipo crossection). Para esta tarefa, a biblioteca tidyr disponibiliza a função pivot_wider, que facilita a execução dessa tarefa. Essa função possui a seguinte especificação de uso:\n\npivot_wider(\n  names_from = nome da coluna que terá os seus valores convertidos em variáveis,\n  values_from = nome da coluna que irá compor os valores da coluna especificada no parâmetro names_from\n)\n\nPara exemplificar, vamos considerar o caso do exemplo da tabela especificada.\n\ndt = data.frame(\n  x1 = c(1,1,1,2,2,2,3,3,3),\n  x2 = c(\"A\", \"C\", \"B\", \"C\", \"B\", \"A\", \"A\", \"B\", \"C\"),\n  x3 = c(5,1,3,1,3,5,5,3,1)\n)\n\ndt\n\n  x1 x2 x3\n1  1  A  5\n2  1  C  1\n3  1  B  3\n4  2  C  1\n5  2  B  3\n6  2  A  5\n7  3  A  5\n8  3  B  3\n9  3  C  1\n\n\nAgora vamos usar a função pivot_wider para transformar os dados agrupados em uma planilha crossection.\n\ndt1 = dt %&gt;% \n  pivot_wider(names_from = x2, values_from = x3)\n\ndt1\n\n# A tibble: 3 x 4\n     x1     A     C     B\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     5     1     3\n2     2     5     1     3\n3     3     5     1     3\n\n\nNota: A coluna especificada no parâmetro names_from deve ser da classe character.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulação de dados</span>"
    ]
  },
  {
    "objectID": "Aula6.html#transformando-variáveis-em-colunas-pivot_longer",
    "href": "Aula6.html#transformando-variáveis-em-colunas-pivot_longer",
    "title": "6  Manipulação de dados",
    "section": "6.10 Transformando variáveis em colunas (pivot_longer)",
    "text": "6.10 Transformando variáveis em colunas (pivot_longer)\nAssim como os economistas precisam frequentemente transformar painéis de dados em planilhas crossection, vez ou outra é preciso fazer a tarefa inversa e transformar planilhas crossection em painéis de dados empilhados. Para esta tarefa, a biblioteca tidyr disponibiliza a função pivot_longer, que permite que um conjunto de colunas específicas sejam empilhadas em uma única coluna, reduzindo a largura e aumentando o comprimento das tabelas. Essa função possui as seguintes propriedades de uso:\n\npivot_longer(\n  cols = colunas usadas na transformação da planilha,\n  names_to = nome da nova coluna (entre aspas) que será criada com os nomes das antigas colunas,\n  values_to = nome da nova coluna (entre aspas) que será criada com os dados agrupados\n)\n\nPara exemplificar, vamos retornar a planilha gerada anteriormente (dt1) na planilha original (dt) com dados crossection. Nesse caso, A, B e C são as colunas que serão empilhadas, de modo que o parâmetro names_to deve receber o valor x1 e o parâmetro values_to deve receber o valor x2.\n\ndt2 = dt1 %&gt;% \n  pivot_longer(\n    cols = c(A, B, C),\n    names_to = \"x2\",\n    values_to = \"x3\"\n  )\n\ndt2\n\n# A tibble: 9 x 3\n     x1 x2       x3\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 A         5\n2     1 B         3\n3     1 C         1\n4     2 A         5\n5     2 B         3\n6     2 C         1\n7     3 A         5\n8     3 B         3\n9     3 C         1\n\n\nNote que, apesar de os valores não estarem posicionados na mesma ordem da planilha dt, eles estão distribuídos igualmente entre os indivíduos conforme a planilha correspondente.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulação de dados</span>"
    ]
  },
  {
    "objectID": "Aula6.html#exemplo-gerando-uma-tabela-de-estatísticas-descritivas",
    "href": "Aula6.html#exemplo-gerando-uma-tabela-de-estatísticas-descritivas",
    "title": "6  Manipulação de dados",
    "section": "6.11 Exemplo: Gerando uma tabela de estatísticas descritivas",
    "text": "6.11 Exemplo: Gerando uma tabela de estatísticas descritivas\nNos capítulos anteriores foi demonstrado como criar uma tabela de estatísticas descritivas usando apenas a indexação das colunas e funções nativas da linguagem R. O roteiro para criar essa tabela foi bastante longo e o código de execução foi bastante ineficiente. Usando as bibliotecas de manipulação de dados dplyr e tidyr é possível executar essa mesma tarefa com maior eficiência e com menos trabalho.\nPara exemplificar, vamos criar uma tabela de estatísticas descritivas de todas as colunas da base de dados mtcars, contendo o número de observações, a média, o desvio padrão, o valor mínimo e o valor máximo. Esse procedimento pode ser feito conforme demonstrado a seguir:\n\nmtcars %&gt;% \n  summarise_all(.funs = c(\"length\", \"mean\", \"sd\", \"min\", \"max\")) %&gt;% \n  pivot_longer(\n    cols = everything(), # selecionando todas as colunas\n    names_to = \"variavel\",\n    values_to = \"valorEstatistica\"\n  ) %&gt;% \n  separate(variavel, into = c(\"coluna\", \"estatistica\"), sep = \"_\") %&gt;% \n  pivot_wider(\n    names_from = \"estatistica\",\n    values_from = \"valorEstatistica\"\n  ) %&gt;% \n  rename(\n    Variavel = coluna,\n    Observacoes= length,\n    Media = mean,\n    Desvio_padrao = sd,\n    Minino = min,\n    Maximo = max\n  )\n\n# A tibble: 11 x 6\n   Variavel Observacoes   Media Desvio_padrao Minino Maximo\n   &lt;chr&gt;          &lt;dbl&gt;   &lt;dbl&gt;         &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 mpg               32  20.1           6.03   10.4   33.9 \n 2 cyl               32   6.19          1.79    4      8   \n 3 disp              32 231.          124.     71.1  472   \n 4 hp                32 147.           68.6    52    335   \n 5 drat              32   3.60          0.535   2.76   4.93\n 6 wt                32   3.22          0.978   1.51   5.42\n 7 qsec              32  17.8           1.79   14.5   22.9 \n 8 vs                32   0.438         0.504   0      1   \n 9 am                32   0.406         0.499   0      1   \n10 gear              32   3.69          0.738   3      5   \n11 carb              32   2.81          1.62    1      8",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulação de dados</span>"
    ]
  },
  {
    "objectID": "Aula6.html#exercício",
    "href": "Aula6.html#exercício",
    "title": "6  Manipulação de dados",
    "section": "6.12 Exercício",
    "text": "6.12 Exercício\nO link a seguir possui uma planilha excel (.xlsx) com o valor da produção agrícola dos municípios do Brasil no ano de 2024 em R$ 1.000,00.\n\nhttps://sidra.ibge.gov.br/geratabela?format=xlsx&name=tabela5457.xlsx&terr=NC&rank=-&query=t/5457/n6/all/v/215/p/last%201/c782/0/l/v,p%2Bc782,t\n\nO link a seguir contém uma planilha excel (.xlsx) com a área plantada (em hectares) dos municípios do estdo do Brasil em 2024.\n\nhttps://sidra.ibge.gov.br/geratabela?format=xlsx&name=tabela5457.xlsx&terr=NC&rank=-&query=t/5457/n6/all/v/8331/p/last%201/c782/0/l/v,p%2Bc782,t\n\nResponda:\n(i) Revise o capítulo anterior e utilize a biblioteca openxlsx para importar as duas planilhas para a linguagem R.\n(ii) Una as duas planilhas pelo código do município.\n(iii) Crie uma nova coluna de nome produtividade mostrando a produtividade da terra (valor da produção por hectare).\n(iv) Agrupe por estado e calcule a média, o desvio padrão o mínimo e o máximo da produtividade da terra para cada unidade da Federação.\n(v) Preserve na base de dados resultante apenas os estados da região Nordeste.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulação de dados</span>"
    ]
  }
]